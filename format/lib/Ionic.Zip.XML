<?xml version="1.0"?>
<doc>
  <assembly>
    <name>Ionic.Zip</name>
  </assembly>
  <members>
    <member name="T:Ionic.LogicalConjunction">
      <summary>
            Enumerates the options for a logical conjunction. This enum is intended for use 
            internally by the FileSelector class.
            </summary>
    </member>
    <member name="T:Ionic.FileSelector">
      <summary>
             FileSelector encapsulates logic that selects files from a source
             - a zip file or the filesystem - based on a set of criteria.  This class is used 
             internally by the DotNetZip library, but you may also find utility in using it 
             externally. 
             </summary>
      <remarks>
        <para>
             Typically, an application that creates or manipulates Zip archives will not directly
             interact with the FileSelector class.  The FileSelector class is used internally by the
             ZipFile class for selecting files for inclusion into the ZipFile, when the <see cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String,System.String)" /> method is called.
             </para>
        <para>
             But, some applications may wish to use the FileSelector class directly, to select
             files from disk volumes based on a set of criteria, without creating or querying Zip
             archives.  The file selection criteria include: a pattern to match the filename; the
             last modified, created, or last accessed time of the file; the size of the file; and
             the attributes of the file.
             </para>
      </remarks>
    </member>
    <member name="M:Ionic.FileSelector.#ctor">
      <summary>
            The default constructor.  
            </summary>
      <remarks>
            Typically, applications won't use this constructor.  Instead they'll call the
            constructor that accepts a selectionCriteria string.  If you use this constructor,
            you'll want to set the SelectionCriteria property on the instance before calling
            SelectFiles().
            </remarks>
    </member>
    <member name="M:Ionic.FileSelector.#ctor(System.String)">
      <summary>
            Constructor that allows the caller to specify file selection criteria.
            </summary>
      <remarks>
        <para>
            This constructor allows the caller to specify a set of criteria for selection of files.
            </para>
        <para>
            See <see cref="P:Ionic.FileSelector.SelectionCriteria" /> for a description of the syntax of 
            the selectionCriteria string.
            </para>
      </remarks>
      <param name="selectionCriteria">The criteria for file selection.</param>
    </member>
    <member name="M:Ionic.FileSelector.ToString">
      <summary>
            Returns a string representation of the FileSelector object.
            </summary>
      <returns>The string representation of the boolean logic statement of the file
            selection criteria for this instance. </returns>
    </member>
    <member name="M:Ionic.FileSelector.SelectFiles(System.String)">
      <summary>
             Returns the names of the files in the specified directory
             that fit the selection criteria specified in the FileSelector.
             </summary>
      <remarks>
             This is equivalent to calling <see cref="M:Ionic.FileSelector.SelectFiles(System.String,System.Boolean)" /> 
             with recurseDirectories = false.
             </remarks>
      <param name="directory">
             The name of the directory over which to apply the FileSelector criteria.
             </param>
      <returns>
             A collection of strings containing fully-qualified pathnames of files
             that match the criteria specified in the FileSelector instance.
             </returns>
    </member>
    <member name="M:Ionic.FileSelector.SelectFiles(System.String,System.Boolean)">
      <summary>
             Returns the names of the files in the specified directory that fit the selection
             criteria specified in the FileSelector, optionally recursing through subdirectories.
             </summary>
      <remarks>
             This method applies the file selection criteria contained in the FileSelector to the 
             files contained in the given directory, and returns the names of files that 
             conform to the criteria. 
             </remarks>
      <param name="directory">
             The name of the directory over which to apply the FileSelector criteria.
             </param>
      <param name="recurseDirectories">
             Whether to recurse through subdirectories when applying the file selection criteria.
             </param>
      <returns>
             An collection of strings containing fully-qualified pathnames of files
             that match the criteria specified in the FileSelector instance.
             </returns>
    </member>
    <member name="M:Ionic.FileSelector.SelectEntries(Ionic.Zip.ZipFile)">
      <summary>
             Retrieve the ZipEntry items in the ZipFile that conform to the specified criteria.
             </summary>
      <remarks>
        <para>
             This method applies the criteria set in the FileSelector instance (as described in
             the <see cref="P:Ionic.FileSelector.SelectionCriteria" />) to the specified ZipFile.  Using this
             method, for example, you can retrieve all entries from the given ZipFile that
             have filenames ending in .txt.
             </para>
        <para>
             Normally, applications would not call this method directly.  This method is used 
             by the ZipFile class.
             </para>
        <para>
             Using the appropriate SelectionCriteria, you can retrieve entries based on size,
             time, and attributes. See <see cref="P:Ionic.FileSelector.SelectionCriteria" /> for a
             description of the syntax of the SelectionCriteria string.
             </para>
      </remarks>
      <param name="zip">The ZipFile from which to retrieve entries.</param>
      <returns>a collection of ZipEntry objects that conform to the criteria.</returns>
    </member>
    <member name="M:Ionic.FileSelector.SelectEntries(Ionic.Zip.ZipFile,System.String)">
      <summary>
             Retrieve the ZipEntry items in the ZipFile that conform to the specified criteria.
             </summary>
      <remarks>
        <para>
             This method applies the criteria set in the FileSelector instance (as described in
             the <see cref="P:Ionic.FileSelector.SelectionCriteria" />) to the specified ZipFile.  Using this
             method, for example, you can retrieve all entries from the given ZipFile that
             have filenames ending in .txt.
             </para>
        <para>
             Normally, applications would not call this method directly.  This method is used 
             by the ZipFile class.
             </para>
        <para>
             This overload allows the selection of ZipEntry instances from the ZipFile to be restricted 
             to entries contained within a particular directory in the ZipFile.
             </para>
        <para>
             Using the appropriate SelectionCriteria, you can retrieve entries based on size,
             time, and attributes. See <see cref="P:Ionic.FileSelector.SelectionCriteria" /> for a
             description of the syntax of the SelectionCriteria string.
             </para>
      </remarks>
      <param name="zip">The ZipFile from which to retrieve entries.</param>
      <param name="directoryPathInArchive">
             the directory in the archive from which to select entries. If null, then 
             all directories in the archive are used. 
             </param>
      <returns>a collection of ZipEntry objects that conform to the criteria.</returns>
    </member>
    <member name="P:Ionic.FileSelector.SelectionCriteria">
      <summary>
             The string specifying which files to include when retrieving.
             </summary>
      <remarks>
        <para>
             Specify the criteria in statements of 3 elements: a noun, an operator, and a value.
             Consider the string "name != *.doc" .  The noun is "name".  The operator is "!=",
             implying "Not Equal".  The value is "*.doc".  That criterion, in English, says "all
             files with a name that does not end in the .doc extension."
             </para>
        <para>
             Supported nouns include "name" for the filename; "atime", "mtime", and "ctime" for
             last access time, last modfied time, and created time of the file, respectively;
             "attributes" for the file attributes; and "size" for the file length (uncompressed).
             The "attributes" and "name" nouns both support = and != as operators.  The "size",
             "atime", "mtime", and "ctime" nouns support = and !=, and &gt;, &gt;=, &lt;, &lt;=
             as well.
             </para>
        <para>
             Specify values for the file attributes as a string with one or more of the
             characters H,R,S,A,I in any order, implying Hidden, ReadOnly, System, Archive,
             and NotContextIndexed, 
             respectively.  To specify a time, use YYYY-MM-DD-HH:mm:ss as the format.  If you
             omit the HH:mm:ss portion, it is assumed to be 00:00:00 (midnight). The value for a
             size criterion is expressed in integer quantities of bytes, kilobytes (use k or kb
             after the number), megabytes (m or mb), or gigabytes (g or gb).  The value for a
             name is a pattern to match against the filename, potentially including wildcards.
             The pattern follows CMD.exe glob rules: * implies one or more of any character,
             while ? implies one character.  If the name pattern contains any slashes, it is
             matched to the entire filename, including the path; otherwise, it is matched
             against only the filename without the path.  This means a pattern of "*\*.*" matches 
             all files one directory level deep, while a pattern of "*.*" matches all files in 
             all directories.    
             </para>
        <para>
             To specify a name pattern that includes spaces, use single quotes around the pattern.
             A pattern of "'* *.*'" will match all files that have spaces in the filename.  The full 
             criteria string for that would be "name = '* *.*'" . 
             </para>
        <para>
             Some examples: a string like "attributes != H" retrieves all entries whose
             attributes do not include the Hidden bit.  A string like "mtime &gt; 2009-01-01"
             retrieves all entries with a last modified time after January 1st, 2009.  For
             example "size &gt; 2gb" retrieves all entries whose uncompressed size is greater
             than 2gb.
             </para>
        <para>
             You can combine criteria with the conjunctions AND, OR, and XOR. Using a string like
             "name = *.txt AND size &gt;= 100k" for the selectionCriteria retrieves entries whose
             names end in .txt, and whose uncompressed size is greater than or equal to 100
             kilobytes.
             </para>
        <para>
             For more complex combinations of criteria, you can use parenthesis to group clauses
             in the boolean logic.  Absent parenthesis, the precedence of the criterion atoms is
             determined by order of appearance.  Unlike the C# language, the AND conjunction does
             not take precendence over the logical OR.  This is important only in strings that
             contain 3 or more criterion atoms.  In other words, "name = *.txt and size &gt; 1000
             or attributes = H" implies "((name = *.txt AND size &gt; 1000) OR attributes = H)"
             while "attributes = H OR name = *.txt and size &gt; 1000" evaluates to "((attributes
             = H OR name = *.txt) AND size &gt; 1000)".  When in doubt, use parenthesis.
             </para>
        <para>
             Using time properties requires some extra care. If you want to retrieve all entries
             that were last updated on 2009 February 14, specify "mtime &gt;= 2009-02-14 AND
             mtime &lt; 2009-02-15".  Read this to say: all files updated after 12:00am on
             February 14th, until 12:00am on February 15th.  You can use the same bracketing
             approach to specify any time period - a year, a month, a week, and so on.
             </para>
        <para>
             The syntax allows one special case: if you provide a string with no spaces, it is treated as
             a pattern to match for the filename.  Therefore a string like "*.xls" will be equivalent to 
             specifying "name = *.xls".  
             </para>
        <para>
             There is no logic in this class that insures that the inclusion criteria
             are internally consistent.  For example, it's possible to specify criteria that
             says the file must have a size of less than 100 bytes, as well as a size that
             is greater than 1000 bytes.  Obviously no file will ever satisfy such criteria,
             but this class does not check and find such inconsistencies.
             </para>
      </remarks>
      <exception cref="T:System.Exception">
             Thrown in the setter if the value has an invalid syntax.
             </exception>
    </member>
    <member name="T:Ionic.EnumUtil">
      <summary>
            Summary description for EnumUtil.
            </summary>
    </member>
    <member name="M:Ionic.EnumUtil.GetDescription(System.Enum)">
      <summary>
            Returns the value of the DescriptionAttribute if the specified Enum value has one.
            If not, returns the ToString() representation of the Enum value.
            </summary>
      <param name="value">The Enum to get the description for</param>
      <returns>
      </returns>
    </member>
    <member name="M:Ionic.EnumUtil.Parse(System.Type,System.String)">
      <summary>
            Converts the string representation of the name or numeric value of one or more 
            enumerated constants to an equivalent enumerated object.
            Note: use the DescriptionAttribute on enum values to enable this.
            </summary>
      <param name="enumType">The System.Type of the enumeration.</param>
      <param name="stringRepresentation">A string containing the name or value to convert.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Ionic.EnumUtil.Parse(System.Type,System.String,System.Boolean)">
      <summary>
            Converts the string representation of the name or numeric value of one or more 
            enumerated constants to an equivalent enumerated object.
            A parameter specified whether the operation is case-sensitive.
            Note: use the DescriptionAttribute on enum values to enable this.
            </summary>
      <param name="enumType">The System.Type of the enumeration.</param>
      <param name="stringRepresentation">A string containing the name or value to convert.</param>
      <param name="ignoreCase">Whether the operation is case-sensitive or not.</param>
      <returns>
      </returns>
    </member>
    <member name="T:Ionic.Zip.WinZipAesCrypto">
      <summary> 
            This is a helper class supporting WinZip AES encryption.  
            This class is intended for use only by the DotNetZip library.
            </summary>
      <remarks>
            Most uses of the DotNetZip library will not involve direct calls into the
            WinZipAesCrypto class.  Instead, the WinZipAesCrypto class is instantiated and used by
            the ZipEntry() class when WinZip AES encryption or decryption on an entry is employed.
            </remarks>
    </member>
    <member name="T:Ionic.Zip.WinZipAesCipherStream">
      <summary>
            A stream that encrypts as it writes, or decrypts as it reads.  The Crypto is AES in 
            CTR (counter) mode, which is 
            compatible with the AES encryption employed by WinZip 12.0.
            </summary>
    </member>
    <member name="M:Ionic.Zip.WinZipAesCipherStream.#ctor(System.IO.Stream,Ionic.Zip.WinZipAesCrypto,System.Int64,Ionic.Zip.CryptoMode)">
      <summary>
            The constructor.
            </summary>
      <param name="s">The underlying stream</param>
      <param name="mode">To either encrypt or decrypt.</param>
      <param name="cryptoParams">The pre-initialized WinZipAesCrypto object.</param>
      <param name="length">The maximum number of bytes to read from the stream.</param>
    </member>
    <member name="P:Ionic.Zip.WinZipAesCipherStream.FinalAuthentication">
      <summary>
            Returns the final HMAC-SHA1-80 
            </summary>
    </member>
    <member name="T:Ionic.Zip.ZipException">
      <summary>
            Base class for all exceptions defined by and throw by the Zip library.
            </summary>
    </member>
    <member name="M:Ionic.Zip.ZipException.#ctor">
      <summary>
            Default ctor.
            </summary>
    </member>
    <member name="M:Ionic.Zip.ZipException.#ctor(System.String)">
      <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
      <param name="message">The message in the exception.</param>
    </member>
    <member name="M:Ionic.Zip.ZipException.#ctor(System.String,System.Exception)">
      <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
      <param name="message">The message in the exception.</param>
      <param name="innerException">The innerException for this exception.</param>
    </member>
    <member name="M:Ionic.Zip.ZipException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
      <param name="serializationInfo">The serialization info for the exception.</param>
      <param name="streamingContext">The streaming context from which to deserialize.</param>
    </member>
    <member name="T:Ionic.Zip.BadPasswordException">
      <summary>
            Issued when an <c>ZipEntry.ExtractWithPassword()</c> method is invoked
            with an incorrect password.
            </summary>
    </member>
    <member name="M:Ionic.Zip.BadPasswordException.#ctor">
      <summary>
            Default ctor.
            </summary>
    </member>
    <member name="M:Ionic.Zip.BadPasswordException.#ctor(System.String)">
      <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
      <param name="message">The message in the exception.</param>
    </member>
    <member name="M:Ionic.Zip.BadPasswordException.#ctor(System.String,System.Exception)">
      <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
      <param name="message">The message in the exception.</param>
      <param name="innerException">The innerException for this exception.</param>
    </member>
    <member name="M:Ionic.Zip.BadPasswordException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
      <param name="serializationInfo">The serialization info for the exception.</param>
      <param name="streamingContext">The streaming context from which to deserialize.</param>
    </member>
    <member name="T:Ionic.Zip.BadReadException">
      <summary>
            Indicates that a read was attempted on a stream, and bad or incomplete data was
            received.  
            </summary>
    </member>
    <member name="M:Ionic.Zip.BadReadException.#ctor">
      <summary>
            Default ctor.
            </summary>
    </member>
    <member name="M:Ionic.Zip.BadReadException.#ctor(System.String)">
      <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
      <param name="message">The message in the exception.</param>
    </member>
    <member name="M:Ionic.Zip.BadReadException.#ctor(System.String,System.Exception)">
      <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
      <param name="message">The message in the exception.</param>
      <param name="innerException">The innerException for this exception.</param>
    </member>
    <member name="M:Ionic.Zip.BadReadException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
      <param name="serializationInfo">The serialization info for the exception.</param>
      <param name="streamingContext">The streaming context from which to deserialize.</param>
    </member>
    <member name="T:Ionic.Zip.BadCrcException">
      <summary>
            Issued when an CRC check fails upon extracting an entry from a zip archive.
            </summary>
    </member>
    <member name="M:Ionic.Zip.BadCrcException.#ctor">
      <summary>
            Default ctor.
            </summary>
    </member>
    <member name="M:Ionic.Zip.BadCrcException.#ctor(System.String)">
      <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
      <param name="message">The message in the exception.</param>
    </member>
    <member name="M:Ionic.Zip.BadCrcException.#ctor(System.String,System.Exception)">
      <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
      <param name="message">The message in the exception.</param>
      <param name="innerException">The innerException for this exception.</param>
    </member>
    <member name="M:Ionic.Zip.BadCrcException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
      <param name="serializationInfo">The serialization info for the exception.</param>
      <param name="streamingContext">The streaming context from which to deserialize.</param>
    </member>
    <member name="T:Ionic.Zip.SfxGenerationException">
      <summary>
            Issued when errors occur saving a self-extracting archive.
            </summary>
    </member>
    <member name="M:Ionic.Zip.SfxGenerationException.#ctor">
      <summary>
            Default ctor.
            </summary>
    </member>
    <member name="M:Ionic.Zip.SfxGenerationException.#ctor(System.String)">
      <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
      <param name="message">The message in the exception.</param>
    </member>
    <member name="M:Ionic.Zip.SfxGenerationException.#ctor(System.String,System.Exception)">
      <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
      <param name="message">The message in the exception.</param>
      <param name="innerException">The innerException for this exception.</param>
    </member>
    <member name="M:Ionic.Zip.SfxGenerationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
      <param name="serializationInfo">The serialization info for the exception.</param>
      <param name="streamingContext">The streaming context from which to deserialize.</param>
    </member>
    <member name="T:Ionic.Zip.BadStateException">
      <summary>
            Indicates that an operation was attempted on a ZipFile which was not possible
            given the state of the instance. For example, if you call <c>Save()</c> on a ZipFile 
            which has no filename set, you can get this exception. 
            </summary>
    </member>
    <member name="M:Ionic.Zip.BadStateException.#ctor">
      <summary>
            Default ctor.
            </summary>
    </member>
    <member name="M:Ionic.Zip.BadStateException.#ctor(System.String)">
      <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
      <param name="message">The message in the exception.</param>
    </member>
    <member name="M:Ionic.Zip.BadStateException.#ctor(System.String,System.Exception)">
      <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
      <param name="message">The message in the exception.</param>
      <param name="innerException">The innerException for this exception.</param>
    </member>
    <member name="M:Ionic.Zip.BadStateException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
      <param name="serializationInfo">The serialization info for the exception.</param>
      <param name="streamingContext">The streaming context from which to deserialize.</param>
    </member>
    <member name="T:Ionic.Zip.SharedUtilities">
      <summary>
            Collects general purpose utility methods.
            </summary>
    </member>
    <member name="M:Ionic.Zip.SharedUtilities.#ctor">
            private null constructor
        </member>
    <member name="M:Ionic.Zip.SharedUtilities.TrimVolumeAndSwapSlashes(System.String)">
      <summary>
            Utility routine for transforming path names. 
            </summary>
      <param name="pathName">source path.</param>
      <returns>transformed path</returns>
    </member>
    <member name="M:Ionic.Zip.SharedUtilities.FindSignature(System.IO.Stream,System.Int32)">
      <summary>
            Finds a signature in the zip stream. This is useful for finding 
            the end of a zip entry, for example. 
            </summary>
      <param name="stream">
      </param>
      <param name="SignatureToFind">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Ionic.Zip.SharedUtilities.GetTempFilename">
      <summary>
            Return a random filename, suitable for use as a temporary file.
            </summary>
      <remarks>
            The System.IO.Path.GetRandomFileName() method is not available on the Compact
            Framework, so this library provides its own substitute. 
            </remarks>
      <returns>a filename of the form DotNetZip-xxxxxxxx.tmp, where xxxxxxxx is replaced 
            by randomly chosen characters.</returns>
    </member>
    <member name="M:Ionic.Zip.SharedUtilities.ReadWithRetry(System.IO.Stream,System.Byte[],System.Int32,System.Int32,System.String)">
      <summary>
            Workitem 7889: handle ERROR_LOCK_VIOLATION during read
            </summary>
      <remarks>
            This could be gracefully handled with an extension attribute, but
            This assembly is built for .NET 2.0, so I cannot use them. 
            </remarks>
    </member>
    <member name="T:Ionic.Zip.CountingStream">
      <summary> 
            A Stream wrapper, used for bookkeeping on input or output
            streams.  In some cases, it is not possible to get the Position
            of a stream, let's say, on a write-only output stream like
            ASP.NET's Response.Output, or on a different write-only stream
            provided as the destination for the zip by the application.
            In this case, we can use this counting stream to count the bytes
            read or written.
            </summary>
    </member>
    <member name="M:Ionic.Zip.CountingStream.#ctor(System.IO.Stream)">
      <summary>
            The  constructor.
            </summary>
      <param name="s">The underlying stream</param>
    </member>
    <member name="T:Ionic.Zip.ZipCrypto">
      <summary> 
            This class implements the "traditional" or "classic" PKZip encryption,
            which today is considered to be weak. On the other hand it is
            ubiquitous. This class is intended for use only by the DotNetZip library.
            </summary>
      <remarks>
            Most uses of the DotNetZip library will not involve direct calls into the
            ZipCrypto class.  Instead, the ZipCrypto class is instantiated and used by
            the ZipEntry() class when encryption or decryption on an entry is employed.
            If for some reason you really wanted to use a weak encryption algorithm
            in some other application, you might use this library.  But you would be much
            better off using one of the built-in strong encryption libraries in the 
            .NET Framework, like the AES algorithm or SHA. 
            </remarks>
    </member>
    <member name="M:Ionic.Zip.ZipCrypto.#ctor">
      <summary>
             The default constructor for ZipCrypto.
             </summary>
      <remarks>
             This class is intended for internal use by the library only. It's probably not useful to you. Seriously.
             Stop reading this documentation.  It's a waste of your time.  Go do something else.
             Check the football scores. Go get an ice cream with a friend.  Seriously.
             </remarks>
    </member>
    <member name="M:Ionic.Zip.ZipCrypto.DecryptMessage(System.Byte[],System.Int32)">
      <summary> 
            Call this method on a cipher text to render the plaintext. You must
            first initialize the cipher with a call to InitCipher.
            </summary>
      <example>
        <code>
            var cipher = new ZipCrypto();
            cipher.InitCipher(Password);
            // Decrypt the header.  This has a side effect of "further initializing the
            // encryption keys" in the traditional zip encryption. 
            byte[] DecryptedMessage = cipher.DecryptMessage(EncryptedMessage);
            </code>
      </example>
      <param name="cipherText">The encrypted buffer.</param>
      <param name="length">
            The number of bytes to encrypt.  
            Should be less than or equal to CipherText.Length.
            </param>
      <returns>The plaintext.</returns>
    </member>
    <member name="M:Ionic.Zip.ZipCrypto.EncryptMessage(System.Byte[],System.Int32)">
      <summary>
            This is the converse of DecryptMessage.  It encrypts the plaintext
            and produces a ciphertext. 
            </summary>
      <param name="plaintext">The plain text buffer.</param>
      <param name="length">
            The number of bytes to encrypt.  
            Should be less than or equal to PlainText.Length.
            </param>
      <returns>The ciphertext.</returns>
    </member>
    <member name="M:Ionic.Zip.ZipCrypto.InitCipher(System.String)">
      <summary>
             This initializes the cipher with the given password. 
             See AppNote.txt for details. 
             </summary>
      <param name="passphrase">The passphrase for encrypting or decrypting with this cipher.
             </param>
      <remarks>
        <code>
             Step 1 - Initializing the encryption keys
             -----------------------------------------
             Start with these keys:        
             Key(0) := 305419896 (0x12345678)
             Key(1) := 591751049 (0x23456789)
             Key(2) := 878082192 (0x34567890)
             
             Then, initialize the keys with a password:
             
             loop for i from 0 to length(password)-1
                 update_keys(password(i))
             end loop
             
             Where update_keys() is defined as:
             
             update_keys(char):
               Key(0) := crc32(key(0),char)
               Key(1) := Key(1) + (Key(0) bitwiseAND 000000ffH)
               Key(1) := Key(1) * 134775813 + 1
               Key(2) := crc32(key(2),key(1) rightshift 24)
             end update_keys
             
             Where crc32(old_crc,char) is a routine that given a CRC value and a
             character, returns an updated CRC value after applying the CRC-32
             algorithm described elsewhere in this document.
            
             </code>
        <para>
             After the keys are initialized, then you can use the cipher to encrypt
             the plaintext. 
             </para>
        <para>
             Essentially we encrypt the password with the keys, then discard the 
             ciphertext for the password. This initializes the keys for later use.
             </para>
      </remarks>
    </member>
    <member name="P:Ionic.Zip.ZipCrypto.MagicByte">
      <summary> 
            From AppNote.txt:
            unsigned char decrypt_byte()
                local unsigned short temp
                temp :=- Key(2) | 2
                decrypt_byte := (temp * (temp ^ 1)) bitshift-right 8
            end decrypt_byte
            </summary>
    </member>
    <member name="T:Ionic.Zip.ZipCipherStream">
      <summary>
            A Stream for reading and concurrently decrypting data from a zip file, 
            or for writing and concurrently encrypting data to a zip file.
            </summary>
    </member>
    <member name="M:Ionic.Zip.ZipCipherStream.#ctor(System.IO.Stream,Ionic.Zip.ZipCrypto,Ionic.Zip.CryptoMode)">
      <summary>
            The  constructor.
            </summary>
      <param name="s">The underlying stream</param>
      <param name="mode">To either encrypt or decrypt.</param>
      <param name="cipher">The pre-initialized ZipCrypto object.</param>
    </member>
    <member name="T:Ionic.Zip.ZipEntry">
      <summary>
            Represents a single entry in a ZipFile. Typically, applications get a ZipEntry
            by enumerating the entries within a ZipFile, or by adding an entry to a ZipFile.
            </summary>
    </member>
    <member name="M:Ionic.Zip.ZipEntry.ReadDirEntry(System.IO.Stream,System.Text.Encoding)">
      <summary>
            Reads one entry from the zip directory structure in the zip file. 
            </summary>
      <param name="s">the stream from which to read.</param>
      <param name="expectedEncoding">
            The text encoding to use if the entry is not marked UTF-8.
            </param>
      <returns>the entry read from the archive.</returns>
    </member>
    <member name="M:Ionic.Zip.ZipEntry.IsNotValidZipDirEntrySig(System.Int32)">
      <summary>
            Returns true if the passed-in value is a valid signature for a ZipDirEntry. 
            </summary>
      <param name="signature">the candidate 4-byte signature value.</param>
      <returns>true, if the signature is valid according to the PKWare spec.</returns>
    </member>
    <member name="M:Ionic.Zip.ZipEntry.#ctor">
      <summary>
            Default constructor.  
            </summary>
      <remarks>
            Applications should never need to call this directly.  It is exposed to
            support COM Automation environments.
            </remarks>
    </member>
    <member name="M:Ionic.Zip.ZipEntry.SetNtfsTimes(System.DateTime,System.DateTime,System.DateTime)">
      <summary>
             Sets the NTFS Creation, Access, and Modified times for the given entry.
             </summary>
      <remarks>
        <para>
             When adding an entry from a file or directory, these quantities are automatically 
             set from the filesystem values. When adding an entry from a stream or string, 
             the values are implicitly set to DateTime.Now.  The application may wish to set
             these values to some arbitrary value, before saving the archive.  If you set the times 
             using this method, the <see cref="P:Ionic.Zip.ZipEntry.LastModified" /> property also gets set, to the 
             same value provided for mtime.
             </para>
        <para>
             The values you set here will be retrievable with the <see cref="P:Ionic.Zip.ZipEntry.Mtime" />, <see cref="P:Ionic.Zip.ZipEntry.Ctime" /> and <see cref="P:Ionic.Zip.ZipEntry.Atime" /> read-only properties.
             </para>
        <para>
             DateTime values provided here without a DateTimeKind are assumed to be Local Time.
             </para>
      </remarks>
      <param name="ctime">the creation time of the entry.</param>
      <param name="atime">the last access time of the entry.</param>
      <param name="mtime">the last modified time of the entry.</param>
    </member>
    <member name="M:Ionic.Zip.ZipEntry.Read(Ionic.Zip.ZipFile,System.Boolean)">
      <summary>
            Reads one ZipEntry from the given stream.  If the entry is encrypted, we don't
            decrypt at this point.  We also do not decompress.  Mostly we read metadata.
            </summary>
      <param name="zf">the zipfile this entry belongs to.</param>
      <param name="first">true of this is the first entry being read from the stream.</param>
      <returns>the ZipEntry read from the stream.</returns>
    </member>
    <member name="M:Ionic.Zip.ZipEntry.Extract">
      <summary>
             Extract the entry to the filesystem, starting at the current working directory. 
             </summary>
      <overloads>
             This method has a bunch of overloads! One of them is sure to be
             the right one for you... If you don't like these, check out the 
             <c>ExtractWithPassword()</c> methods.
             </overloads>
      <seealso cref="P:Ionic.Zip.ZipEntry.ExtractExistingFile" />
      <seealso cref="M:Ionic.Zip.ZipEntry.Extract(System.Boolean)" />
      <remarks>
        <para> This method extracts an entry from a zip file into the current working
             directory.  The path of the entry as extracted is the full path as specified in
             the zip archive, relative to the current working directory.  After the file is
             extracted successfully, the file attributes and timestamps are set.  </para>
        <para>
             The action taken when extraction an entry would overwrite an existing file
             is determined by the <see cref="P:Ionic.Zip.ZipEntry.ExtractExistingFile" /> property. 
             </para>
        <para>
             See the remarks the <see cref="P:Ionic.Zip.ZipEntry.LastModified" /> property, for some details 
             about how the last modified time of the file is set after extraction.
             </para>
      </remarks>
    </member>
    <member name="M:Ionic.Zip.ZipEntry.Extract(System.Boolean)">
      <summary>
            Extract the entry to a file in the filesystem, potentially overwriting
            any existing file. This method is Obsolete.
            </summary>
      <remarks>
        <para>
            This method is Obsolete, please don't use it.  Please use method <see cref="M:Ionic.Zip.ZipEntry.Extract(Ionic.Zip.ExtractExistingFileAction)" /> instead.
            </para>
        <para>
            See the remarks on the <see cref="P:Ionic.Zip.ZipEntry.LastModified" /> property, for some details 
            about how the last modified time of the created file is set after extraction.
            </para>
      </remarks>
      <param name="overwrite">
            true if the caller wants to overwrite an existing bfile 
            by the same name in the filesystem.
            </param>
      <seealso cref="M:Ionic.Zip.ZipEntry.Extract(Ionic.Zip.ExtractExistingFileAction)" />
    </member>
    <member name="M:Ionic.Zip.ZipEntry.Extract(Ionic.Zip.ExtractExistingFileAction)">
      <summary>
            Extract the entry to a file in the filesystem, using the specified behavior 
            when extraction would overwrite an existing file.
            </summary>
      <remarks>
        <para>
            See the remarks on the <see cref="P:Ionic.Zip.ZipEntry.LastModified" /> property, for some details 
            about how the last modified time of the file is set after extraction.
            </para>
      </remarks>
      <param name="extractExistingFile">The action to take if extraction would 
            overwrite an existing file.</param>
    </member>
    <member name="M:Ionic.Zip.ZipEntry.Extract(System.IO.Stream)">
      <summary>
            Extracts the entry to the specified stream. 
            </summary>
      <remarks>
        <para> For example, the caller could specify <c>Console.Out</c>, or a
            <c>MemoryStream</c>, or ASP.NET's <c>Response.OutputStream</c>.  The content
            will be decrypted and decompressed as necessary. If the entry is encrypted and
            no password is provided, this method will throw.  </para>
      </remarks>
      <param name="stream">the stream to which the entry should be extracted.  </param>
    </member>
    <member name="M:Ionic.Zip.ZipEntry.Extract(System.String)">
      <summary>
             Extract the entry to the filesystem, starting at the specified base directory. 
             </summary>
      <param name="baseDirectory">the pathname of the base directory</param>
      <seealso cref="P:Ionic.Zip.ZipEntry.ExtractExistingFile" />
      <seealso cref="M:Ionic.Zip.ZipEntry.Extract(System.String,Ionic.Zip.ExtractExistingFileAction)" />
      <seealso cref="M:Ionic.Zip.ZipFile.Extract(System.String)" />
      <example>
             This example extracts only the entries in a zip file that are .txt files, 
             into a directory called "textfiles".
             <code lang="C#">
             using (ZipFile zip = ZipFile.Read("PackedDocuments.zip"))
             {
               foreach (string s1 in zip.EntryFilenames)
               {
                 if (s1.EndsWith(".txt")) 
                 {
                   zip[s1].Extract("textfiles");
                 }
               }
             }
             </code><code lang="VB">
               Using zip As ZipFile = ZipFile.Read("PackedDocuments.zip")
                   Dim s1 As String
                   For Each s1 In zip.EntryFilenames
                       If s1.EndsWith(".txt") Then
                           zip(s1).Extract("textfiles")
                       End If
                   Next
               End Using
             </code></example>
      <remarks>
        <para> Using this method, existing entries in the filesystem will not be
             overwritten. If you would like to force the overwrite of existing files, see the
             <see cref="P:Ionic.Zip.ZipEntry.ExtractExistingFile" /> property, or call <see cref="M:Ionic.Zip.ZipEntry.Extract(System.String,Ionic.Zip.ExtractExistingFileAction)" />. </para>
        <para>
             See the remarks on the LastModified property, for some details 
             about how the last modified time of the created file is set.
             </para>
      </remarks>
    </member>
    <member name="M:Ionic.Zip.ZipEntry.Extract(System.String,System.Boolean)">
      <summary>
             Extract the entry to the filesystem, starting at the specified base directory, 
             and potentially overwriting existing files in the filesystem. 
             </summary>
      <remarks>
        <para>
             See the remarks on the LastModified property, for some details 
             about how the last modified time of the created file is set.
             </para>
      </remarks>
      <param name="baseDirectory">the pathname of the base directory</param>
      <param name="overwrite">If true, overwrite any existing files if necessary
             upon extraction.</param>
      <seealso cref="M:Ionic.Zip.ZipEntry.Extract(System.String,Ionic.Zip.ExtractExistingFileAction)" />
    </member>
    <member name="M:Ionic.Zip.ZipEntry.Extract(System.String,Ionic.Zip.ExtractExistingFileAction)">
      <summary>
            Extract the entry to the filesystem, starting at the specified base directory, and
            using the specified behavior when extraction would overwrite an existing file.
            </summary>
      <remarks>
        <para>
            See the remarks on the LastModified property, for some details 
            about how the last modified time of the created file is set.
            </para>
      </remarks>
      <param name="baseDirectory">the pathname of the base directory</param>
      <param name="extractExistingFile">The action to take if extraction would
            overwrite an existing file.</param>
    </member>
    <member name="M:Ionic.Zip.ZipEntry.ExtractWithPassword(System.String)">
      <summary>
             Extract the entry to the filesystem, using the current working directory
             and the specified password. 
             </summary>
      <overloads>
             This method has a bunch of overloads! One of them is sure to be
             the right one for you...
             </overloads>
      <seealso cref="P:Ionic.Zip.ZipEntry.ExtractExistingFile" />
      <seealso cref="M:Ionic.Zip.ZipEntry.ExtractWithPassword(Ionic.Zip.ExtractExistingFileAction,System.String)" />
      <remarks>
        <para> Existing entries in the filesystem will not be overwritten. If you would
             like to force the overwrite of existing files, see the <see cref="P:Ionic.Zip.ZipEntry.ExtractExistingFile" />property, or call <see cref="M:Ionic.Zip.ZipEntry.ExtractWithPassword(Ionic.Zip.ExtractExistingFileAction,System.String)" />.</para>
        <para>
             See the remarks on the <see cref="P:Ionic.Zip.ZipEntry.LastModified" /> property for some details 
             about how the "last modified" time of the created file is set.
             </para>
      </remarks>
      <example>
             In this example, entries that use encryption are extracted using a particular password.
             <code>
             using (var zip = ZipFile.Read(FilePath))
             {
                 foreach (ZipEntry e in zip)
                 {
                     if (e.UsesEncryption)
                         e.ExtractWithPassword("Secret!");
                     else
                         e.Extract();
                 }
             }
             </code><code lang="VB">
             Using zip As ZipFile = ZipFile.Read(FilePath)
                 Dim e As ZipEntry
                 For Each e In zip
                     If (e.UsesEncryption)
                       e.ExtractWithPassword("Secret!")
                     Else
                       e.Extract
                     End If 
                 Next
             End Using
             </code></example>
      <param name="password">The Password to use for decrypting the entry.</param>
    </member>
    <member name="M:Ionic.Zip.ZipEntry.ExtractWithPassword(System.String,System.String)">
      <summary>
             Extract the entry to the filesystem, starting at the specified base directory,
             and using the specified password. 
             </summary>
      <seealso cref="P:Ionic.Zip.ZipEntry.ExtractExistingFile" />
      <seealso cref="M:Ionic.Zip.ZipEntry.ExtractWithPassword(System.String,Ionic.Zip.ExtractExistingFileAction,System.String)" />
      <remarks>
        <para> Existing entries in the filesystem will not be overwritten. If you would
             like to force the overwrite of existing files, see the <see cref="P:Ionic.Zip.ZipEntry.ExtractExistingFile" />property, or call <see cref="M:Ionic.Zip.ZipEntry.ExtractWithPassword(Ionic.Zip.ExtractExistingFileAction,System.String)" />.</para>
        <para>
             See the remarks on the LastModified property, for some details 
             about how the last modified time of the created file is set.
             </para>
      </remarks>
      <param name="baseDirectory">The pathname of the base directory.</param>
      <param name="password">The Password to use for decrypting the entry.</param>
    </member>
    <member name="M:Ionic.Zip.ZipEntry.ExtractWithPassword(System.Boolean,System.String)">
      <summary>
            Extract the entry to a file in the filesystem, potentially overwriting
            any existing file.
            </summary>
      <remarks>
        <para>
            See the remarks on the LastModified property, for some details 
            about how the last modified time of the created file is set.
            </para>
      </remarks>
      <param name="overwrite">true if the caller wants to overwrite an existing 
            file by the same name in the filesystem.</param>
      <param name="password">The Password to use for decrypting the entry.</param>
      <seealso cref="M:Ionic.Zip.ZipEntry.ExtractWithPassword(Ionic.Zip.ExtractExistingFileAction,System.String)" />
    </member>
    <member name="M:Ionic.Zip.ZipEntry.ExtractWithPassword(Ionic.Zip.ExtractExistingFileAction,System.String)">
      <summary>
            Extract the entry to a file in the filesystem, relative to the current directory,
            using the specified behavior when extraction would overwrite an existing file.
            </summary>
      <remarks>
        <para>
            See the remarks on the LastModified property, for some details 
            about how the last modified time of the created file is set.
            </para>
      </remarks>
      <param name="password">The Password to use for decrypting the entry.</param>
      <param name="extractExistingFile">
            The action to take if extraction would overwrite an existing file.
            </param>
    </member>
    <member name="M:Ionic.Zip.ZipEntry.ExtractWithPassword(System.String,System.Boolean,System.String)">
      <summary>
             Extract the entry to the filesystem, starting at the specified base directory, 
             and potentially overwriting existing files in the filesystem. 
             </summary>
      <remarks>
             See the remarks on the LastModified property, for some details 
             about how the last modified time of the created file is set.
             </remarks>
      <param name="baseDirectory">the pathname of the base directory</param>
      <param name="overwrite">If true, overwrite any existing files if necessary
             upon extraction.</param>
      <param name="password">The Password to use for decrypting the entry.</param>
      <seealso cref="M:Ionic.Zip.ZipEntry.ExtractWithPassword(System.String,Ionic.Zip.ExtractExistingFileAction,System.String)" />
    </member>
    <member name="M:Ionic.Zip.ZipEntry.ExtractWithPassword(System.String,Ionic.Zip.ExtractExistingFileAction,System.String)">
      <summary>
             Extract the entry to the filesystem, starting at the specified base directory, and
             using the specified behavior when extraction would overwrite an existing file.
             </summary>
      <remarks>
             See the remarks on the LastModified property, for some details 
             about how the last modified time of the created file is set.
             </remarks>
      <param name="baseDirectory">the pathname of the base directory</param>
      <param name="extractExistingFile">The action to take if extraction would
             overwrite an existing file.</param>
      <param name="password">The Password to use for decrypting the entry.</param>
    </member>
    <member name="M:Ionic.Zip.ZipEntry.ExtractWithPassword(System.IO.Stream,System.String)">
      <summary>
            Extracts the entry to the specified stream, using the specified Password.
            For example, the caller could extract to Console.Out, or to a MemoryStream.
            </summary>
      <remarks>
            See the remarks on the LastModified property, for some details 
            about how the last modified time of the created file is set.
            </remarks>
      <param name="stream">the stream to which the entry should be extracted.  </param>
      <param name="password">The password to use for decrypting the entry.</param>
    </member>
    <member name="M:Ionic.Zip.ZipEntry.OpenReader">
      <summary>
            Opens the backing stream for the zip entry in the archive, for reading. 
            </summary>
      <remarks>
        <para>
            The ZipEntry has methods that extract the entry to an already-opened stream, writing
            data to a stream your application provides.  This is an alternative method for those
            applications that wish to read data directly from the stream.
            </para>
        <para>
            The <see cref="T:Ionic.Zlib.CrcCalculatorStream" /> that is returned is just a regular
            read-only stream - you can use it as you would any stream.  The data you get will be
            decrypted and decompressed.  The one additional feature the CrcCalculatorStream adds
            is that it calculates a CRC32 on the bytes of the stream as it is read.  This CRC
            *should* be used by the application to validate the content of the ZipEntry, when the
            read is complete.  You don't have to validate the CRC, but you should. Check the
            example for how to do this.
            </para>
        <para>
            If the entry is protected with a password, then you need to set the password either on the
            entry, or on the ZipFile itself, prior to calling <see cref="M:Ionic.Zip.ZipEntry.OpenReader" />.
            </para>
      </remarks>
      <example>
            In this example, we open a zipfile, then read in a named entry via a stream, scanning
            the bytes in the entry as we go.  Finally, the CRC and the size of the entry are verified.
            <code>
            using (ZipFile zip = new ZipFile(ZipFileToRead))
            {
              ZipEntry e1= zip["Elevation.mp3"];
              using (Ionic.Zlib.CrcCalculatorStream s = e1.OpenReader())
              {
                byte[] buffer = new byte[4096];
                int n, totalBytesRead= 0;
                do {
                  n = s.Read(buffer,0, buffer.Length);
                  totalBytesRead+=n; 
                } while (n&gt;0);
                 if (s.Crc32 != e1.Crc32)
                  throw new Exception(string.Format("The Zip Entry failed the CRC Check. (0x{0:X8}!=0x{1:X8})", s.Crc32, e1.Crc32));
                 if (totalBytesRead != e1.UncompressedSize)
                  throw new Exception(string.Format("We read an unexpected number of bytes. ({0}!={1})", totalBytesRead, e1.UncompressedSize));
              }
            }
            </code><code lang="VB">
              Using zip As New ZipFile(ZipFileToRead)
                  Dim e1 As ZipEntry = zip.Item("Elevation.mp3")
                  Using s As Ionic.Zlib.CrcCalculatorStream = e1.OpenReader
                      Dim n As Integer
                      Dim buffer As Byte() = New Byte(4096) {}
                      Dim totalBytesRead As Integer = 0
                      Do
                          n = s.Read(buffer, 0, buffer.Length)
                          totalBytesRead = (totalBytesRead + n)
                      Loop While (n &gt; 0)
                      If (s.Crc32 &lt;&gt; e1.Crc32) Then
                          Throw New Exception(String.Format("The Zip Entry failed the CRC Check. (0x{0:X8}!=0x{1:X8})", s.Crc32, e1.Crc32))
                      End If
                      If (totalBytesRead &lt;&gt; e1.UncompressedSize) Then
                          Throw New Exception(String.Format("We read an unexpected number of bytes. ({0}!={1})", totalBytesRead, e1.UncompressedSize))
                      End If
                  End Using
              End Using
            </code></example>
      <seealso cref="M:Ionic.Zip.ZipEntry.Extract(System.IO.Stream)" />
      <returns>The Stream for reading.</returns>
    </member>
    <member name="M:Ionic.Zip.ZipEntry.OpenReader(System.String)">
      <summary>
            Opens the backing stream for an encrypted zip entry in the archive, for reading. 
            </summary>
      <remarks>
        <para>
            See the documentation on the <see cref="M:Ionic.Zip.ZipEntry.OpenReader" /> method for full details.  
            This overload allows the application to specify a password for the ZipEntry to be read. 
            </para>
      </remarks>
      <param name="password">The password to use for decrypting the entry.</param>
      <returns>The Stream for reading.</returns>
    </member>
    <member name="P:Ionic.Zip.ZipEntry.AttributesIndicateDirectory">
      <summary>
            True if the referenced entry is a directory.  
            </summary>
    </member>
    <member name="P:Ionic.Zip.ZipEntry.LastModified">
      <summary>
             The time and date at which the file indicated by the ZipEntry was last modified. 
             </summary>
      <remarks>
        <para>
             The DotNetZip library sets the LastModified value for an entry, equal to the
             Last Modified time of the file in the filesystem.  If an entry is added from
             a stream, in which case no Last Modified attribute is available, the library
             uses <c>System.DateTime.Now</c> for this value, for the given entry.
             </para>
        <para>
             This property allows the application to retrieve and possibly set the
             LastModified value on an entry, to an arbitrary value.  DateTime values
             without a DateTimeKind setting are assumed to be expressed in Local Time.
             </para>
        <para>
             Be aware that because of the way the PKZip specification describes how times
             are stored in the zip file, the full precision of the <c>System.DateTime</c>
             datatype is not stored for the last modified time when saving zip files.
             For more information on how times are formatted, see the PKZip
             specification.
             </para>
        <para> The actual last modified time of a file can be stored in two ways in the
             zip file: first in the so-called "DOS" format, which has a 2-second
             precision. Values are rounded to the nearest even second. For example, if the
             time on the file is 12:34:43, then it will be stored as 12:34:44. This first
             value is accessible via the <c>LastModified</c> property.  Also, the last
             modified time can optionally be stored as an 8-byte integer quantity expressed
             as the number of 1/10 milliseconds (in other words the number of 100 nanosecond
             units) since January 1, 1601 (UTC).  This is the so-called Win32 time.  This
             time is accessible via the <c>Mtime</c> property.  Zip tools and libraries will
             always at least handle (read or write) the DOS time, and may also handle the
             Win32 time. When reading ZIP files, The DotNetZip library reads the Win32 time,
             if it is stored in the entry, and sets both <c>LastModified</c> and <c>Mtime</c>
             to that value. When writing ZIP files, the DotNetZip library will write both
             time quantities.  </para>
        <para>
             The last modified time of the file created upon a call to
             <c>ZipEntry.Extract()</c> may be adjusted during extraction to compensate
             for differences in how the .NET Base Class Library deals with daylight
             saving time (DST) versus how the Windows filesystem deals with daylight
             saving time.  Raymond Chen <see href="http://blogs.msdn.com/oldnewthing/archive/2003/10/24/55413.aspx">provides
             some good context</see>.
             </para>
        <para>
             In a nutshell: Daylight savings time rules change regularly.  In 2007, for
             example, the inception week of DST changed.  In 1977, DST was in place all
             year round. In 1945, likewise.  And so on.  Win32 does not attempt to guess
             which time zone rules were in effect at the time in question.  It will
             render a time as "standard time" and allow the app to change to DST as
             necessary.  .NET makes a different choice.
             </para>
        <para>
             Compare the output of FileInfo.LastWriteTime.ToString("f") with what you
             see in the Windows Explorer property sheet for a file that was last
             written to on the other side of the DST transition. For example, suppose
             the file was last modified on October 17, 2003, during DST but DST is not
             currently in effect. Explorer's file properties reports Thursday, October
             17, 2003, 8:45:38 AM, but .NETs FileInfo reports Thursday, October 17,
             2003, 9:45 AM.
             </para>
        <para>
             Win32 says, "Thursday, October 17, 2002 8:45:38 AM PST". Note: Pacific
             STANDARD Time. Even though October 17 of that year occurred during Pacific
             Daylight Time, Win32 displays the time as standard time because that's
             what time it is NOW.
             </para>
        <para>
             .NET BCL assumes that the current DST rules were in place at the time in
             question.  So, .NET says, "Well, if the rules in effect now were also in
             effect on October 17, 2003, then that would be daylight time" so it
             displays "Thursday, October 17, 2003, 9:45 AM PDT" - daylight time.
             </para>
        <para>
             So .NET gives a value which is more intuitively correct, but is also
             potentially incorrect, and which is not invertible. Win32 gives a value
             which is intuitively incorrect, but is strictly correct.
             </para>
        <para>
             Because of this funkiness, this library adds one hour to the LastModified
             time on the extracted file, if necessary.  That is to say, if the time in
             question had occurred in what the .NET Base Class Library assumed to be
             DST. This assumption may be wrong given the constantly changing DST
             rules, but it is the best we can do.
             </para>
      </remarks>
    </member>
    <member name="P:Ionic.Zip.ZipEntry.Mtime">
      <summary>
             Last Modified time for the file represented by the entry.
             </summary>
      <remarks>
        <para> This value corresponds to the "last modified" time in the NTFS file times
             as described in <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">the Zip
             specification</see>.  This value is different from <see cref="P:Ionic.Zip.ZipEntry.LastModified" />.
             </para>
        <para> Let me explain. Originally, waaaaay back in 1989 when the ZIP
             specification was originally described by the esteemed Mr. Phil Katz, the
             dominant operating system of the time was MS-DOS. MSDOS stored file times with a
             2-second precision, because, c'mon, <em>who is ever going to need better
             resolution than THAT?</em> And so ZIP files, regardless of the platform on which
             the zip file was created, store file times in exactly <see href="http://www.vsft.com/hal/dostime.htm">the same format that DOS used in
             1989</see>.  </para>
        <para> Since then, the ZIP spec has evolved, but the internal format for file
             timestamps remains the same.  Despite the fact that the way times are stored in
             a zip file is rooted in DOS heritage, any program on any operating system can
             format a time in this way, and most zip tools and libraries DO - they round file
             times to the nearest even second and store it just like DOS did 20 years ago.
             </para>
        <para> PKWare extended the ZIP specification to allow a zip file to store what
             is called "NTFS Times" for a file.  These are the <em>last write</em>, <em>last
             access</em>, and <em>file creation</em> times of a particular file. These
             metadata are not actually specific to NTFS. They are tracked for each file by
             NTFS, but they are also tracked by other filesystems. DotNetZip represents this
             with the <c>Mtime</c>, <c>Atime</c> and <c>Ctime</c> properties on a
             <c>ZipEntry</c>.</para>
        <para> Inside a zip file, these three distinct timestamps are stored in the same
             format that Windows NTFS uses to store file times. Rather than a resolution of 2
             seconds, NTFS times have a resolution of 100 nanoseconds. And, just as with the
             DOS time, any tool or library on any operating system is capable of formatting a
             time in this way and embedding it into the zip file. The key is, not all zip
             tools or libraries do.  Storing the higher-precision times for each entry is
             optional for zip files, and many tools and libraries don't use the option,
             though it is much nicer than the DOS time.  And futher, there are also cases
             where the timestamp of the file entry is not known, and is not stored. For
             example, this happens when content for the entry is obtained from a stream.  The
             bottom line is that the higher-resolution time is not guaranteed to be present
             for a ZipEntry.  The old DOS time, represented by <see cref="P:Ionic.Zip.ZipEntry.LastModified" />, is
             guaranteed to be present, though it sometimes unset. </para>
        <para> Ok, getting back to the question about how the <c>LastModified</c>
             property relates to this <c>Mtime</c> property... <c>LastModified</c> is always
             set, while <c>Mtime</c> is not. (The other times stored in the <em>NTFS times
             extension</em>, <c>Ctime</c> and <c>Atime</c> also may not be set on an entry
             that is read from an existing zip file.) When reading a zip file, then
             <c>LastModified</c> takes the DOS time that is stored with the file. If the DOS time
             has been stored as zero in the zipfile, then this library will use
             <c>DateTime.Now</c> for the <c>LastModified</c> value.  If the ZIP file was
             created by an evolved tool, then there will also be NTFS times in the zip file.
             In that case, this library will read those times, and set <c>LastModified</c>
             and <c>Mtime</c> to the same value, the one corresponding to the last write time
             of the file.  If there are no "NTFS times" stored for the entry, then
             <c>Mtime</c> remains unset (likewise <c>Atime</c> and <c>Ctime</c>), and
             <c>LastModified</c> keeps its DOS time. </para>
        <para> When creating zip files with this library, then the NTFS time properties
             (<c>Mtime</c>, <c>Atime</c>, and <c>Ctime</c>) are always set on the ZipEntry
             instance, and these data are always stored in the zip archive for each entry. If
             you add an entry from an actual filesystem file, then the entry gets the actual
             NTFS times for that file.  If you add an entry from a stream, or a string, then
             the times get the value <c>DateTime.Now</c>.  In this case <c>LastModified</c>
             and <c>Mtime</c> will be identical, to 2 seconds of precision.  You can
             explicitly set the <c>Ctime</c>, <c>Atime</c>, and <c>Mtime</c> of an entry
             using <see cref="M:Ionic.Zip.ZipEntry.SetNtfsTimes(System.DateTime,System.DateTime,System.DateTime)" />. Those changes
             are not made permanent in the zip file until you call <see cref="M:Ionic.Zip.ZipFile.Save" /> or one of its cousins.  </para>
        <para>
             And that is why <c>Mtime</c> may or may not be meaningful, and it may or may not agree 
             exactly with the <c>LastModified</c> time on the <c>ZipEntry</c>.
             </para>
        <para>
             I'll bet you didn't think one person could type so much about time, eh?  And reading
             it was so enjoyable, too!  Well, in appreciation, <see href="http://cheeso.members.winisp.net/DotNetZipDonate.aspx">maybe you should
             donate</see>?
             </para>
      </remarks>
      <seealso cref="P:Ionic.Zip.ZipEntry.LastModified" />
    </member>
    <member name="P:Ionic.Zip.ZipEntry.Atime">
      <summary>
            Last Access time for the file represented by the entry.
            </summary>
      <remarks>
            This value may or may not be meaningful.  If the ZipEntry was read from an existing
            Zip archive, this information may not be available. For an explanation of why, see
            <see cref="P:Ionic.Zip.ZipEntry.Mtime" />.
            </remarks>
    </member>
    <member name="P:Ionic.Zip.ZipEntry.Ctime">
      <summary>
             The file creation time for the file represented by the entry.
             </summary>
      <remarks> This value may or may not be meaningful.  If the ZipEntry was read
             from an existing Zip archive, and the creation time was not set on the entry
             when the zip file was created, then this property may be meaningless. For an
             explanation of why, see <see cref="P:Ionic.Zip.ZipEntry.Mtime" />.  </remarks>
    </member>
    <member name="P:Ionic.Zip.ZipEntry.Attributes">
      <summary>
             The file attributes for the entry.
             </summary>
      <remarks>
        <para>
             The <see cref="T:System.IO.FileAttributes">attributes</see> in NTFS include
             ReadOnly, Archive, Hidden, System, and Indexed.  When adding a ZipEntry to a
             ZipFile, these attributes are set implicitly when adding an entry from the
             filesystem.  When adding an entry from a stream or string, the Attributes are
             not set.
             </para>
        <para>
             When reading a ZipEntry from a ZipFile, the attributes are set according to the data
             stored in the ZipFile. If you extract the entry from the archive to a disk file,
             DotNetZip will set the attributes on the resulting file accordingly.
             </para>
        <para>
             The attributes can be set explicitly by the application for whatever purpose.  For
             example the application may wish to set the FileAttributes.ReadOnly bit for all
             entries added to an archive, so that on unpack, this attribute will be set on the
             extracted file.  Any changes you make to this property are made permanent only when
             you call a Save() method on the ZipFile instance that contains the ZipEntry.
             </para>
        <para>
             For example, an application may wish to zip up a directory and set the ReadOnly bit on
             every file in the archive, so that upon later extraction, the resulting files will be
             marked as ReadOnly.  Not every extraction tool respects these attributes, but if you
             unpack with DotNetZip, then the attributes will be set as they are stored in the
             ZipFile.
             </para>
        <para>
             These attributes may not be interesting or useful if the resulting archive is
             extracted on a non-Windows platform.  How these attributes get used upon extraction
             depends on the platform and tool used.
             </para>
      </remarks>
    </member>
    <member name="P:Ionic.Zip.ZipEntry.ForceNoCompression">
      <summary>
             Disables compression for the entry when calling ZipFile.Save().
             </summary>
      <remarks>
        <para>
             By default, the library compresses entries when saving them to archives. 
             When this property is set to true, the entry is not compressed when written to 
             the archive.  For example, the application might want to set flag to <c>true</c>
             this when zipping up JPG or MP3 files, which are already compressed.  The application
             may also want to turn off compression for other reasons.
             </para>
        <para> When updating a ZipFile, you may not turn off compression on an entry
             that has been encrypted.  In other words, if you read an existing ZipFile with
             one of the <c>ZipFile.Read()</c> methods, and then change the
             <c>CompressionMethod</c> on an entry that has <c>Encryption</c> not equal to
             <c>None</c>, you will receive an exception.  There is no way to modify the
             compression on an encrypted entry, without extracting it and re-adding it into
             the ZipFile.  </para>
      </remarks>
      <seealso cref="P:Ionic.Zip.ZipFile.ForceNoCompression" />
      <seealso cref="P:Ionic.Zip.ZipEntry.CompressionMethod" />
    </member>
    <member name="P:Ionic.Zip.ZipEntry.LocalFileName">
      <summary>
            The name of the filesystem file, referred to by the ZipEntry. 
            </summary>
      <remarks>
        <para>
            This may be different than the path used in the archive itself. What I mean is, 
            if you call <c>Zip.AddFile("fooo.txt", AlternativeDirectory)</c>, then the 
            path used for the ZipEntry within the zip archive will be different than this path.  
            This path is used to locate the thing-to-be-zipped on disk. 
            </para>
        <para>
            If the entry is being added from a stream, then this is null (Nothing in VB).
            </para>
      </remarks>
      <seealso cref="P:Ionic.Zip.ZipEntry.FileName" />
    </member>
    <member name="P:Ionic.Zip.ZipEntry.FileName">
      <summary>
             The name of the file contained in the ZipEntry. 
             </summary>
      <remarks>
        <para> This is the name of the entry in the ZipFile itself.  When creating or
             updating a zip file, this name may be different than the name of the filesystem
             file used to create the entry (LocalFileName). In fact, there may be no
             filesystem file at all, if the entry is created from a stream or a string.  When
             reading a zip file, this property takes the value of the entry name as stored in
             the zip file. If you extract such an entry, the extracted file will take the name
             given by this property.</para>
        <para> When setting this property, the value is made permanent only after a call
             to one of the <c>ZipFile.Save()</c> methods on the <c>ZipFile</c> that contains
             the ZipEntry. By reading in a <c>ZipFile</c>, then explicitly setting the
             FileName on an entry contained within the <c>ZipFile</c>, and then calling
             <c>Save()</c>, you will effectively rename the entry within the zip archive.
             </para>
        <para> When writing a zip, this value written to the zip file replaces
             backslashes with forward slashes, according to <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">the Zip
             specification</see>, for compatibility with Unix(tm) and ... get this.... Amiga!
             </para>
      </remarks>
    </member>
    <member name="P:Ionic.Zip.ZipEntry.InputStream">
      <summary>
             The stream that provides content for the ZipEntry.
             </summary>
      <remarks>
        <para> The application can use this property to set the input stream for an
             entry on a just-in-time basis. Imagine a scenario where the application
             creates a <c>ZipFile</c> comprised of content obtained from hundreds of
             files, via calls to <c>AddFile()</c>. The DotNetZip library opens streams on
             these files on a just-in-time basis, only when writing the entry out to an
             external store within the scope of a <c>ZipFile.Save()</c> call.  Only one
             input stream is opened at a time, as each entry is being written
             out. </para>
        <para> Now imagine a different application that creates a zipfile with
             content obtained from hundreds of streams, added through <see cref="M:Ionic.Zip.ZipFile.AddFileFromStream(System.String,System.String,System.IO.Stream)" />.
             Normally the application would supply an open stream to that call.  But when
             large numbers of streams are being added, this can mean many open streams at
             one time, unnecessarily.  </para>
        <para> To avoid this, at the time of calling
             <c>ZipFile.AddFileFromStream</c> for each entry, the application can supply
             Stream.Null as the value of the stream parameter. The application
             can then open the stream on a just-in-time basis, setting this property, and
             thus insuring, as with the latter example, that only one stream need be
             opened at a time while constructing and saving the ZipFile.  </para>
        <para> To do this, the application should set the <c>InputStream</c>
             property within the context of the <see cref="E:Ionic.Zip.ZipFile.SaveProgress" /> event,
             when the event type is <see cref="F:Ionic.Zip.ZipProgressEventType.Saving_BeforeWriteEntry" />. The application
             should only set <see cref="P:Ionic.Zip.ZipEntry.InputStream" /> for a ZipEntry which has the <see cref="P:Ionic.Zip.ZipEntry.Source" /> equal to <see cref="F:Ionic.Zip.ZipEntrySource.Stream" />.  When
             the input stream is provided by the application in this way, the application
             is also responsible for closing or disposing the stream.  This would
             normally be done in the <see cref="E:Ionic.Zip.ZipFile.SaveProgress" /> event, when the
             event type is <see cref="F:Ionic.Zip.ZipProgressEventType.Saving_AfterWriteEntry" />. See
             the example code provided here for how this can be done. </para>
        <para> Setting the value of this property when the entry was not added from
             a stream (for example, when the ZipEntry was added with <see cref="M:Ionic.Zip.ZipFile.AddFile(System.String)" /> or <see cref="M:Ionic.Zip.ZipFile.AddDirectory(System.String)" />, or when the entry was added by
             reading an existing zip archive) will throw an exception.  </para>
      </remarks>
      <example>
        <para> This example adds a large number of entries to a ZipFile. The
             application uses the just-in-time stream provisioning mechanism to avoid
             keeping all the streams open simultaneiously. </para>
        <code lang="C#">
             public static void ProvisionStreams(object sender, SaveProgressEventArgs e)
             {
                 if (e.EventType == ZipProgressEventType.Saving_BeforeWriteEntry)
                 {
                     if (e.CurrentEntry.Source == ZipEntrySource.Stream &amp;&amp;
                           e.CurrentEntry.InputStream == Stream.Null)
                     {
                         System.IO.Stream s = MyStreamOpener(e.CurrentEntry.FileName);
                         e.CurrentEntry.InputStream = s;
                     }
                 }
                 else if (e.EventType == ZipProgressEventType.Saving_AfterWriteEntry)
                 {
                     if (e.CurrentEntry.InputStreamWasJitProvided)
                     {
                         e.CurrentEntry.InputStream.Close();
                     }
                 }
             }
            
             public void CreateZip()
             {
                 using (ZipFile zip = new ZipFile())
                 {
                     // add content into a "content" dir in the zip archive
                     foreach (string s in namesOfStreamsToZip)
                         zip.AddFileFromStream(s, "content", null);
                     // set up the event handler to provision streams "just-in-time"
                     zip.SaveProgress += ProvisionStreams;
                     zip.AddFile("Readme.txt");
                     zip.Save(ZipToCreate);
                 }
             }
             </code>
        <code lang="VB">
             Public Shared Sub ProvisionStreams(ByVal sender As Object, ByVal e As SaveProgressEventArgs)
                 If (e.EventType = ZipProgressEventType.Saving_BeforeWriteEntry) Then
                     If (e.CurrentEntry.Source = ZipEntrySource.Stream) Then
                         If (e.CurrentEntry.InputStream = Stream.Null) Then
                             Dim s As Stream = MyStreamOpener(e.CurrentEntry.FileName)
                             e.CurrentEntry.InputStream = s
                         End If
                     End If
                 ElseIf (e.EventType = ZipProgressEventType.Saving_AfterWriteEntry) Then
                     If (e.CurrentEntry.InputStreamWasJitProvided) Then
                         e.CurrentEntry.InputStream.Close
                     End If
                 End If
             End Sub
            
             Public Sub CreateZip()
                 Using zip As ZipFile = new ZipFile()
                     ' add content into a "content" dir in the zip archive
                     Dim s As String
                     For Each s In namesOfStreamsToZip
                         zip.AddFileFromStream(s, "content", Nothing)
                     ' set up the event handler to provision streams "just-in-time"
                     AddHandler zip.SaveProgress, AddressOf ProvisionStreams
                     zip.AddFile("Readme.txt")
                     zip.Save(ZipToCreate)
                 End Using
             End Sub
             </code>
      </example>
      <seealso cref="P:Ionic.Zip.ZipEntry.InputStreamWasJitProvided" />
    </member>
    <member name="P:Ionic.Zip.ZipEntry.InputStreamWasJitProvided">
      <summary>
             A flag indicating whether the InputStream was provided Just-in-time.
             </summary>
      <remarks>
        <para>
             When creating a zip archive, an application can obtain content for one or more of the
             ZipEntry instances from streams, using the <see cref="M:Ionic.Zip.ZipFile.AddFileFromStream(System.String,System.String,System.IO.Stream)" /> method.  At the
             time of calling that method, the application can supply null as the value of the
             stream parameter.  By doing so, the application indicates to the library that it will
             provide a stream for the entry on a just-in-time basis, at the time one of the
             <c>ZipFile.Save()</c> methods is called and the data for the various entries are being
             compressed and written out.
             </para>
        <para>
             In this case, the application can set the <see cref="P:Ionic.Zip.ZipEntry.InputStream" /> property,
             typically within the SaveProgress event (event type: <see cref="F:Ionic.Zip.ZipProgressEventType.Saving_BeforeWriteEntry" />) for that entry.  
             </para>
        <para>
             The application will later want to call Close() and Dispose() on that stream.  In the
             SaveProgress event, when the event type is <see cref="F:Ionic.Zip.ZipProgressEventType.Saving_AfterWriteEntry" />, the application can do so.  This
             flag indicates that the stream has been provided by the application on a just-in-time
             basis and that it is the application's responsibility to call Close/Dispose on that
             stream.
             </para>
      </remarks>
      <seealso cref="P:Ionic.Zip.ZipEntry.InputStream" />
    </member>
    <member name="P:Ionic.Zip.ZipEntry.Source">
      <summary>
            An enum indicating the source of the ZipEntry.
            </summary>
    </member>
    <member name="P:Ionic.Zip.ZipEntry.VersionNeeded">
      <summary>
            The version of the zip engine needed to read the ZipEntry.  
            </summary>
      <remarks>
            This is a readonly property.  An application that reads and writes zip archives
            generally does not care about this value.  It is required as part of the Zip file
            format, and is exposed in this class, but is probably not useful to you.  The value is
            20 for vanilla zip files. If ZIP64 is in use, the version will be decimal 45.  There
            are other values possible, as well. This value is set upon reading an existing Zip
            file, or after saving a zip archive.
            </remarks>
    </member>
    <member name="P:Ionic.Zip.ZipEntry.Comment">
      <summary>
             The comment attached to the ZipEntry. 
             </summary>
      <remarks>
        <para>
             Each entry in a Zip file can optionally have a comment associated to it. The
             comment might be displayed by a zip tool during extraction, for example. 
             </para>
        <para>
             By default, the <c>Comment</c> is encoded in IBM437 code page. You can specify 
             an alternative with <see cref="P:Ionic.Zip.ZipEntry.ProvisionalAlternateEncoding" /></para>
      </remarks>
      <seealso cref="P:Ionic.Zip.ZipEntry.ProvisionalAlternateEncoding" />
    </member>
    <member name="P:Ionic.Zip.ZipEntry.RequiresZip64">
      <summary>
             Indicates whether the entry requires ZIP64 extensions.
             </summary>
      <remarks>
        <para> This property is null (Nothing in VB) until a <c>Save()</c> method on the
             containing <see cref="T:Ionic.Zip.ZipFile" /> instance has been called. The property is
             non-null (<c>HasValue</c> is true) only after a <c>Save()</c> method has been called.
             </para>
        <para> After the containing <c>ZipFile</c> has been saved, the Value of this
             property is true if any of the following three conditions holds: the
             uncompressed size of the entry is larger than 0xFFFFFFFF; the compressed size of
             the entry is larger than 0xFFFFFFFF; the relative offset of the entry within the
             zip archive is larger than 0xFFFFFFFF.  These quantities are not known until a
             <c>Save()</c> is attempted on the zip archive and the compression is applied.
             </para>
        <para>If none of the three conditions holds, then the <c>Value</c> is false.</para>
        <para> A <c>Value</c> of false does not indicate that the entry, as saved in the
             zip archive, does not use ZIP64.  It merely indicates that ZIP64 is <em>not
             required</em>.  An entry may use ZIP64 even when not required if the <see cref="P:Ionic.Zip.ZipFile.UseZip64WhenSaving" /> property on the containing ZipFile instance
             is set to <see cref="F:Ionic.Zip.Zip64Option.Always" />, or if the <see cref="P:Ionic.Zip.ZipFile.UseZip64WhenSaving" /> property on the containing <c>ZipFile</c>
             instance is set to <see cref="F:Ionic.Zip.Zip64Option.AsNecessary" /> and the output stream
             was not seekable.  </para>
      </remarks>
      <seealso cref="P:Ionic.Zip.ZipEntry.OutputUsedZip64" />
    </member>
    <member name="P:Ionic.Zip.ZipEntry.OutputUsedZip64">
      <summary>
             Indicates whether the entry actually used ZIP64 extensions, as it was most recently 
             written to the output file or stream.
             </summary>
      <remarks>
        <para> This Nullable property is null (Nothing in VB) until a <c>Save()</c>
             method on the containing <see cref="T:Ionic.Zip.ZipFile" /> instance has been
             called. <c>HasValue</c> is true only after a <c>Save()</c> method has been
             called.  </para>
        <para>
             The value of this property for a particular ZipEntry may change over successive calls to
             <c>Save()</c> methods on the containing ZipFile, even if the file that corresponds to the ZipEntry does
             not. This may happen if other entries contained in the ZipFile expand, causing the offset 
             for this particular entry to exceed 0xFFFFFFFF. 
             </para>
      </remarks>
      <seealso cref="P:Ionic.Zip.ZipEntry.RequiresZip64" />
    </member>
    <member name="P:Ionic.Zip.ZipEntry.BitField">
      <summary>
             The bitfield for the entry as defined in the zip spec. You probably never need to look at this.
             </summary>
      <remarks>
        <code>
             bit  0 - set if encryption is used.
             b. 1-2 - set to determine whether normal, max, fast deflation.  
                      This library always leaves these bits unset when writing (indicating 
                      "normal" deflation").
            
             bit  3 - indicates crc32, compressed and uncompressed sizes are zero in
                      local header.  We always leave this as zero on writing, but can read
                      a zip with it nonzero. 
            
             bit  4 - reserved for "enhanced deflating". This library doesn't do enhanced deflating.
             bit  5 - set to indicate the zip is compressed patched data.  This library doesn't do that.
             bit  6 - set if strong encryption is used (must also set bit 1 if bit 6 is set)
             bit  7 - unused
             bit  8 - unused
             bit  9 - unused
             bit 10 - unused
             Bit 11 - Language encoding flag (EFS).  If this bit is set,
                      the filename and comment fields for this file
                      must be encoded using UTF-8. This library currently does not support UTF-8.
             Bit 12 - Reserved by PKWARE for enhanced compression.
             Bit 13 - Used when encrypting the Central Directory to indicate 
                      selected data values in the Local Header are masked to
                      hide their actual values.  See the section describing 
                      the Strong Encryption Specification for details.
             Bit 14 - Reserved by PKWARE.
             Bit 15 - Reserved by PKWARE.
             </code>
      </remarks>
    </member>
    <member name="P:Ionic.Zip.ZipEntry.CompressionMethod">
      <summary>
             The compression method employed for this ZipEntry. 
             </summary>
      <remarks>
        <para>
          <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">The
             Zip specification</see> allows a variety of compression methods.  This library
             supports just two: 0x08 = Deflate.  0x00 = Store (no compression).  </para>
        <para>
             When reading an entry from an existing zipfile, the value you retrieve here
             indicates the compression method used on the entry by the original creator of the zip.  
             When writing a zipfile, you can specify either 0x08 (Deflate) or 0x00 (None).  If you 
             try setting something else, you will get an exception.  
             </para>
        <para> You may wish to set <c>CompressionMethod</c> to 0 (None) when zipping
             previously compressed data like a jpg, png, or mp3 file.  This can save time and
             cpu cycles.  Setting <c>CompressionMethod</c> to 0 is equivalent to setting
             <c>ForceNoCompression</c> to <c>true</c>.  </para>
        <para> When updating a <c>ZipFile</c>, you may not modify the
             <c>CompressionMethod</c> on an entry that has been encrypted.  In other words,
             if you read an existing <c>ZipFile</c> with one of the <c>ZipFile.Read()</c>
             methods, and then change the <c>CompressionMethod</c> on an entry that has
             <c>Encryption</c> not equal to <c>None</c>, you will receive an exception.
             There is no way to modify the compression on an encrypted entry, without
             extracting it and re-adding it into the <c>ZipFile</c>.  </para>
      </remarks>
      <example>
             In this example, the first entry added to the zip archive uses 
             the default behavior - compression is used where it makes sense.  
             The second entry, the MP3 file, is added to the archive without being compressed.
             <code>
             using (ZipFile zip = new ZipFile(ZipFileToCreate))
             {
               ZipEntry e1= zip.AddFile(@"notes\Readme.txt");
               ZipEntry e2= zip.AddFile(@"music\StopThisTrain.mp3");
               e2.CompressionMethod = 0;
               zip.Save();
             }
             </code><code lang="VB">
             Using zip As New ZipFile(ZipFileToCreate)
               zip.AddFile("notes\Readme.txt")
               Dim e2 as ZipEntry = zip.AddFile("music\StopThisTrain.mp3")
               e2.CompressionMethod = 0
               zip.Save
             End Using
             </code></example>
    </member>
    <member name="P:Ionic.Zip.ZipEntry.CompressedSize">
      <summary>
             The compressed size of the file, in bytes, within the zip archive. 
             </summary>
      <remarks> The compressed size is computed during compression. The value is valid
             AFTER reading in an existing zip file, or AFTER saving a zipfile you are
             creating.  </remarks>
      <seealso cref="P:Ionic.Zip.ZipEntry.UncompressedSize" />
    </member>
    <member name="P:Ionic.Zip.ZipEntry.UncompressedSize">
      <summary>
            The size of the file, in bytes, before compression, or after extraction. 
            </summary>
      <remarks>
            This property is valid AFTER reading in an existing zip file, or AFTER saving the 
            ZipFile that contains the ZipEntry.
            </remarks>
      <seealso cref="P:Ionic.Zip.ZipEntry.CompressedSize" />
    </member>
    <member name="P:Ionic.Zip.ZipEntry.CompressionRatio">
      <summary>
             The ratio of compressed size to uncompressed size of the ZipEntry.
             </summary>
      <remarks>
        <para>
             This is a ratio of the compressed size to the uncompressed size of the entry,
             expressed as a double in the range of 0 to 100+. A value of 100 indicates no
             compression at all.  It could be higher than 100 when the compression algorithm
             actually inflates the data, as may occur for small files, or uncompressible
             data that is encrypted.
             </para>
        <para>
             You could format it for presentation to a user via a format string of "{3,5:F0}%"
             to see it as a percentage. 
             </para>
        <para>
             If the size of the original uncompressed file is 0, (indicating a denominator of 0)
             the return value will be zero. 
             </para>
        <para>
             This property is valid AFTER reading in an existing zip file, or AFTER saving the 
             ZipFile that contains the ZipEntry. You cannot know the effect of a compression 
             transform until you try it. 
             </para>
      </remarks>
    </member>
    <member name="P:Ionic.Zip.ZipEntry.Crc32">
      <summary>
             The 32-bit CRC (Cyclic Redundancy Check) on the contents of the ZipEntry. 
             </summary>
      <remarks>
        <para> You probably don't need to concern yourself with this. It is used
             internally by DotNetZip to verify files or streams upon extraction.  </para>
        <para> The value is a <see href="http://en.wikipedia.org/wiki/CRC32">32-bit
             CRC</see> using 0xEDB88320 for the polynomial. This is the same CRC-32 used in
             PNG, MPEG-2, and other protocols and formats.  It is a read-only property; when
             creating a Zip archive, the CRC for each entry is set only after a call to
             Save() on the containing ZipFile. When reading an existing zip file, the value
             of this property reflects the stored CRC for the entry.  </para>
      </remarks>
    </member>
    <member name="P:Ionic.Zip.ZipEntry.IsDirectory">
      <summary>
            True if the entry is a directory (not a file). 
            This is a readonly property on the entry.
            </summary>
    </member>
    <member name="P:Ionic.Zip.ZipEntry.UsesEncryption">
      <summary>
             A derived property that is <c>true</c> if the entry uses encryption.  
             </summary>
      <remarks> This is a readonly property on the entry.  When reading a zip file,
             the value for the ZipEntry is determined by the data read from the zip file.
             After saving a ZipFile, the value of this property for each ZipEntry indicates
             whether encryption was actually used (which will have been true if the <see cref="P:Ionic.Zip.ZipEntry.Password" /> was set and the <see cref="P:Ionic.Zip.ZipEntry.Encryption" /> property was
             something other than <see cref="F:Ionic.Zip.EncryptionAlgorithm.None" />.  </remarks>
    </member>
    <member name="P:Ionic.Zip.ZipEntry.Encryption">
      <summary>
             Set this to specify which encryption algorithm to use for the entry.
             </summary>
      <remarks>
        <para> When setting this property, you must also set a <see cref="P:Ionic.Zip.ZipEntry.Password" /> on
             the entry in order to encrypt the entry when the <c>ZipFile</c> is saved.  If
             you set a value other than <see cref="F:Ionic.Zip.EncryptionAlgorithm.None" /> on this
             property and do not set a <c>Password</c> then the entry will not be
             encrypted. The <c>ZipEntry</c> data is encrypted as the <c>ZipFile</c> is saved, 
             when you call <see cref="M:Ionic.Zip.ZipFile.Save" /> or one of its cousins on the
             containing <c>ZipFile</c> instance.  </para>
        <para> There is no common, ubiquitous multi-vendor standard for strong
             encryption. There is broad support for so-called "traditional" Zip encryption,
             sometimes called Zip 2.0 encryption, as <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">specified by
             PKWare</see>, but this encryption is considered weak and breakable. This library
             currently supports the Zip 2.0 "weak" encryption, and also a stronger
             WinZip-compatible AES encryption, using either 128-bit or 256-bit key strength.
             </para>
        <para> The
             Zip specification from PKWare defines a set of encryption algorithms, and
             the data formats for the zip archive that support them. Other vendors of tools
             and libraries, such as WinZip or Xceed, also specify and support different
             encryption algorithms and data formats, as extensions to the basic ZIP
             specification.  This library supports a subset of the complete set of
             algorithms.  If you want one that is not currently supported, call me and maybe
             we can talk business.  </para>
        <para>
             The WinZip AES encryption algorithms are not supported on the .NET Compact Framework. 
             </para>
      </remarks>
    </member>
    <member name="P:Ionic.Zip.ZipEntry.Password">
      <summary>
             The Password to be used when encrypting a ZipEntry upon ZipFile.Save(), or 
             when decrypting an entry upon Extract().
             </summary>
      <remarks>
        <para>
             This is a write-only property on the entry. 
             Set this to request that the entry be encrypted when writing the zip
             archive, or set it to specify the password to be used when extracting an 
             existing entry that is encrypted.   
             </para>
        <para>
             The password set here is implicitly 
             used to encrypt the entry during the Save() operation, or to decrypt during
             the <see cref="M:Ionic.Zip.ZipEntry.Extract" /> or <see cref="M:Ionic.Zip.ZipEntry.OpenReader" /> operation. 
             </para>
        <para>
             Some comments on Updating archives: Suppose you read a zipfile, and there is an
             encrypted entry.  Setting the password on that entry and then saving the zipfile
             does not update the password on that entry in the archive.  Instead, what happens
             is the existing entry is copied through to the new zip archive, in its original
             encrypted form.  Upon re-reading that archive, the entry can be decrypted with its
             original password. 
             </para>
        <para>
             If you read a zipfile, you cannot modify the password on any encrypted entry,
             except by extracting the entry with the first password (if any), removing the original
             entry via <see cref="M:Ionic.Zip.ZipFile.RemoveEntry(Ionic.Zip.ZipEntry)" />,  and then adding
             a new entry with a new password. 
             </para>
        <para>
             If you read a zipfile, and there is an un-encrypted entry, you can set the password
             on the entry and then call Save() on the ZipFile, and get encryption on that entry. 
             </para>
      </remarks>
    </member>
    <member name="P:Ionic.Zip.ZipEntry.OverwriteOnExtract">
      <summary>
            Specifies that the extraction should overwrite any existing files. This property is Obsolete.
            </summary>
      <remarks>
            This property is Obsolete. Please don't use it!  Instead, use property <see cref="P:Ionic.Zip.ZipEntry.ExtractExistingFile" />.  IF you must use it, you should know this: this property
            applies only when calling an Extract method. By default this property is false.
            </remarks>
      <seealso cref="P:Ionic.Zip.ZipEntry.ExtractExistingFile" />
    </member>
    <member name="P:Ionic.Zip.ZipEntry.ExtractExistingFile">
      <summary>
             The action the library should take when extracting a file that already exists.
             </summary>
      <remarks>
        <para>
             This property affects the behavior of the Extract methods (one of the <c>Extract()</c>
             or <c>ExtractWithPassword()</c> overloads), when extraction would would overwrite an
             existing filesystem file. If you do not set this property, the library throws an
             exception when extracting an entry would overwrite an existing file.
             </para>
        <para>
             This property has no effect when extracting to a stream, or when the file to be
             extracted does not already exist. 
             </para>
      </remarks>
      <seealso cref="P:Ionic.Zip.ZipFile.ExtractExistingFile" />
    </member>
    <member name="P:Ionic.Zip.ZipEntry.WillReadTwiceOnInflation">
      <summary>
             A callback that allows the application to specify whether multiple reads of the
             stream should be performed, in the case that a compression operation actually
             inflates the size of the file data.  
             </summary>
      <remarks>
        <para>
             In some cases, applying the Deflate compression algorithm in DeflateStream can
             result an increase in the size of the data.  This "inflation" can happen with
             previously compressed files, such as a zip, jpg, png, mp3, and so on.  In a few
             tests, inflation on zip files can be as large as 60%!  Inflation can also happen
             with very small files.  In these cases, by default, the DotNetZip library
             discards the compressed bytes, and stores the uncompressed file data into the
             zip archive.  This is an optimization where smaller size is preferred over
             longer run times.
             </para>
        <para>
             The application can specify that compression is not even tried, by setting the
             ForceNoCompression flag.  In this case, the compress-and-check-sizes process as
             decribed above, is not done.
             </para>
        <para>
             In some cases, neither choice is optimal.  The application wants compression,
             but in some cases also wants to avoid reading the stream more than once.  This
             may happen when the stream is very large, or when the read is very expensive, or
             when the difference between the compressed and uncompressed sizes is not
             significant.
             </para>
        <para>
             To satisfy these applications, this delegate allows the DotNetZip library to ask
             the application to for approval for re-reading the stream.  As with other
             properties (like Password and ForceNoCompression), setting the corresponding
             delegate on the ZipFile class itself will set it on all ZipEntry items that are
             subsequently added to the ZipFile instance.
             </para>
      </remarks>
      <seealso cref="P:Ionic.Zip.ZipFile.WillReadTwiceOnInflation" />
      <seealso cref="T:Ionic.Zip.ReReadApprovalCallback" />
    </member>
    <member name="P:Ionic.Zip.ZipEntry.WantCompression">
      <summary>
             A callback that allows the application to specify whether compression should
             be used for a given entry that is about to be added to the zip archive.
             </summary>
      <remarks>
             See <see cref="P:Ionic.Zip.ZipFile.WantCompression" /></remarks>
    </member>
    <member name="P:Ionic.Zip.ZipEntry.UseUnicodeAsNecessary">
      <summary>
             Set to indicate whether to use UTF-8 encoding for filenames and 
             comments.  
             </summary>
      <remarks>
        <para> If this flag is set, the comment and filename for the entry will be
             encoded with UTF-8, as described in <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">the Zip
             specification</see>, if necessary. "Necessary" means, the filename or entry
             comment (if any) cannot be reflexively encoded and decoded using the default
             code page, IBM437.  </para>
        <para>
             Setting this flag to true is equivalent to setting
             <see cref="P:Ionic.Zip.ZipEntry.ProvisionalAlternateEncoding" /> to <c>System.Text.Encoding.UTF8</c>.
             </para>
        <para> This flag has no effect or relation to the text encoding used within the file
             itself. </para>
      </remarks>
    </member>
    <member name="P:Ionic.Zip.ZipEntry.ProvisionalAlternateEncoding">
      <summary>
             The text encoding to use for the FileName and Comment on this ZipEntry, when the 
             default encoding is insufficient.
             </summary>
      <remarks>
        <para> According to <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">the Zip
             specification from PKWare</see>, filenames and comments for a ZipEntry are
             encoded either with IBM437 or with UTF8.  But, some zip archiver tools or
             libraries do not follow the specification, and instead encode characters using
             the system default code page, or an arbitrary code page.  For example, WinRAR
             when run on a machine in Shanghai may encode filenames with the Chinese (Big-5)
             code page.  This behavior is contrary to the Zip specification, but it occurs
             anyway.  This property exists to support that non-compliant behavior when
             reading or writing zip files.  </para>
        <para>
             When writing zip archives that will be read by one of these other archivers, use
             this property to specify the code page to use when encoding filenames and comments
             into the zip file, when the IBM437 code page will not suffice.
             </para>
        <para> Be aware that a zip file created after you've explicitly specified the
             code page will not be compliant to the PKWare specification, and may not be
             readable by compliant archivers.  On the other hand, many archivers are
             non-compliant and can read zip files created in arbitrary code pages. For
             example, if you run WinRar on your PC desktop in Kyoto, Japan, you will probably be
             able to open Zip files that we encoded by DotNetZip in the Shift_JIS code page.
             </para>
        <para> When using an arbitrary, non-UTF8 code page for encoding, there is no
             standard way for the creator (DotNetZip) to specify in the zip file which code
             page has been used. DotNetZip is not able to inspect the zip file and determine
             the codepage used for the entries within it. Therefore, you, the application
             author, must determine that.  If you read a zip file using a codepage other than
             the one used to encode the zipfile, this may result in filenames that are not
             legal in the filesystem, and you will get exceptions during calls to
             <c>Extract()</c> methods for those entries.  Caveat Emptor.  </para>
      </remarks>
    </member>
    <member name="P:Ionic.Zip.ZipEntry.ActualEncoding">
      <summary>
             The text encoding actually used for this ZipEntry.
             </summary>
      <remarks>
        <para> This read-only property describes the encoding used by the
             <c>ZipEntry</c>.  If the entry has been read in from an existing ZipFile, then
             it may take the value UTF-8, if the entry is coded to specify UTF-8.  If the
             entry does not specify UTF-8, the typical case, then the encoding used is
             whatever the application specified in the call to <c>ZipFile.Read()</c>. If the
             application has used one of the overloads of <c>ZipFile.Read()</c> that does not
             accept an encoding parameter, then the encoding used is IBM437, which is the
             default encoding described in the ZIP specification.  </para>
        <para> If the entry is being created, then the value of ActualEncoding is taken
             according to the logic described in the documentation for <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" />.  </para>
        <para> An application might be interested in retrieving this property to see if
             an entry read in from a file has used Unicode (UTF-8).  </para>
      </remarks>
      <seealso cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" />
    </member>
    <member name="P:Ionic.Zip.ZipEntry.IsText">
      <summary>
             Indicates whether an entry is mark as a text file.
             </summary>
      <remarks>
        <para>
             The ZIP format includes a provision for specifying whether an entry in the
             zip archive is a text or binary file.  Such a distinction may seem irrelevant
             now, but some zip tools or libraries, in particular older PKUnzip on IBM
             mainframes, require this bit to be set in order to unzip text and binary
             files properly.  Set this property to true to set the Text bit for an entry
             that represents a text file, if you want your zip files to be readable by
             these older zip tools and libraries.
             </para>
        <para>
             When writing a zip file, you must set the property before calling
             <c>Save()</c> on the ZipFile.
             </para>
        <para>
             If you are not having compatibility problems with zip archives, you can
             safely ignore this property.
             </para>
      </remarks>
      <example>
        <code>
             using (var zip = new ZipFile())
             {
                 var e = zip.UpdateFile("Descriptions.txt", "");
                 e.IsText = true;
                 zip.Save(zipPath);
             }
             </code>
        <code lang="VB">
             Using zip As New ZipFile
                 Dim e2 as ZipEntry = zip.AddFile("Descriptions.txt", "")
                 e.IsText= True
                 zip.Save(zipPath)
             End Using
             </code>
      </example>
    </member>
    <member name="T:Ionic.Zip.EncryptionAlgorithm">
      <summary>
             An enum that provides the various encryption algorithms supported by this
             library.
             </summary>
      <remarks>
        <para>
             PkzipWeak implies the use of Zip 2.0 encryption, which is known to be weak and
             subvertible.
             </para>
        <para>
             A note on interoperability: Values of PkzipWeak and None are specified in the
             PKWare AppNote.txt document, are considered to be "standard".  Zip archives
             produced using these options will be interoperable with many other zip tools and
             libraries, including Windows Explorer.
             </para>
        <para>
             Values of WinZipAes128 and WinZipAes256 are not part of the Zip specification,
             but rather imply the use of a vendor-specific extension from WinZip. If you
             want to produce interoperable Zip archives, do not use these values.  For
             example, if you produce a zip archive using WinZipAes256, you will be able to
             open it in Windows Explorer on Windows XP and Vista, but you will not be able
             to extract entries; trying this will lead to an "unspecified error". For this
             reason, some people have said that a zip archive that uses WinZip's AES
             encryption is not actually a zip archive at all.  A zip archive produced this
             way will be readable with the WinZip tool (Version 11 and beyond).
             </para>
        <para>
             There are other third-party tools and libraries, both commercial and
             otherwise, that support WinZip's AES encryption. These will be able to read
             AES-encrypted zip archives produced by DotNetZip, and conversely applications
             that use DotNetZip to read zip archives will be able to read AES-encrypted
             archives produced by those tools or libraries.  Consult the documentation for
             those other tools and libraries to find out if WinZip's AES encryption is
             supported.
             </para>
        <para>
             In case you care: According to the WinZip specification, the actual AES key used
             is derived from the <see cref="P:Ionic.Zip.ZipEntry.Password" /> via an algorithm that
             complies with <see href="http://www.ietf.org/rfc/rfc2898.txt">RFC 2898</see>,
             using an iteration count of 1000.  The algorithm is sometimes referred to as
             PBKDF2, which stands for "Password Based Key Derivation Function #2".
             </para>
        <para>
             A word about password strength and length: The AES encryption technology is very
             good, but any system is only as secure as the weakest link.  If you want to
             secure your data, be sure to use a password that is hard to guess.  To make it
             harder to guess (increase its "entropy"), you should make it longer.  If you use
             normal characters from an ASCII keyboard, a password of length 20 will be strong
             enough that it will be impossible to guess.  For more information on that, I'd
             encourage you to read <see href="http://www.redkestrel.co.uk/Articles/RandomPasswordStrength.html">this
             article.</see></para>
        <para>
             The WinZip AES algorithms are not supported with the version of DotNetZip that
             runs on the .NET Compact Framework.  This is because .NET CF lacks the
             HMACSHA1 class that is required for producing the archive.
             </para>
      </remarks>
    </member>
    <member name="F:Ionic.Zip.EncryptionAlgorithm.None">
      <summary>
            No encryption at all.
            </summary>
    </member>
    <member name="F:Ionic.Zip.EncryptionAlgorithm.PkzipWeak">
      <summary>
            Traditional or Classic pkzip encryption.
            </summary>
    </member>
    <member name="F:Ionic.Zip.EncryptionAlgorithm.WinZipAes128">
      <summary>
            WinZip AES encryption (128 key bits).
            </summary>
    </member>
    <member name="F:Ionic.Zip.EncryptionAlgorithm.WinZipAes256">
      <summary>
            WinZip AES encryption (256 key bits).
            </summary>
    </member>
    <member name="T:Ionic.Zip.ExtractExistingFileAction">
      <summary>
            An enum for the options when extracting an entry would overwrite an existing file. 
            </summary>
      <remarks>
        <para>
            This enum describes the actions that the library can take when an
            <c>Extract()</c> or <c>ExtractWithPassword()</c> method is called to extract an
            entry to a filesystem, and the extraction would overwrite an existing filesystem
            file.
            </para>
      </remarks>
    </member>
    <member name="F:Ionic.Zip.ExtractExistingFileAction.Throw">
      <summary>
            Throw an exception when extraction would overwrite an existing file. (For
            COM clients, this is a 0 (zero).)
            </summary>
    </member>
    <member name="F:Ionic.Zip.ExtractExistingFileAction.OverwriteSilently">
      <summary>
            When extraction would overwrite an existing file, overwrite the file silently.
            The overwrite will happen even if the target file is marked as read-only.
            (For COM clients, this is a 1.)
            </summary>
    </member>
    <member name="F:Ionic.Zip.ExtractExistingFileAction.DontOverwrite">
      <summary>
            When extraction would overwrite an existing file, don't overwrite the file, silently. 
            (For COM clients, this is a 2.)
            </summary>
    </member>
    <member name="F:Ionic.Zip.ExtractExistingFileAction.InvokeExtractProgressEvent">
      <summary>
            When extraction would overwrite an existing file, invoke the ExtractProgress
            event, using an event type of <see cref="F:Ionic.Zip.ZipProgressEventType.Extracting_ExtractEntryWouldOverwrite" />.  In
            this way, the application can decide, just-in-time, whether to overwrite the
            file. For example, a GUI application may wish to pop up a dialog to allow
            the user to choose.  (For COM clients, this is a 3.)
            </summary>
    </member>
    <member name="T:Ionic.Zip.ZipEntrySource">
      <summary>
            An enum that specifies the source of the ZipEntry. 
            </summary>
    </member>
    <member name="F:Ionic.Zip.ZipEntrySource.None">
      <summary>
            Default value.  Invalid on a bonafide ZipEntry.
            </summary>
    </member>
    <member name="F:Ionic.Zip.ZipEntrySource.Filesystem">
      <summary>
            The entry was instantiated by calling AddFile() or another method that 
            added an entry from the filesystem.
            </summary>
    </member>
    <member name="F:Ionic.Zip.ZipEntrySource.Stream">
      <summary>
            The entry was instantiated via <see cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,System.String,System.String)" /> or
            <see cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,System.String,System.IO.Stream)" /> .
            </summary>
    </member>
    <member name="F:Ionic.Zip.ZipEntrySource.Zipfile">
      <summary>
            The ZipEntry was instantiated by reading a zipfile.
            </summary>
    </member>
    <member name="T:Ionic.Zip.ReReadApprovalCallback">
      <summary>
            Delegate for the callback by which the application gives approval for multiple
            reads of the file stream. This callback is called only when the initial 
            compression operation inflates the size of the file data. 
            </summary>
    </member>
    <member name="T:Ionic.Zip.WantCompressionCallback">
      <summary>
            Delegate for the callback by which the application tells the libraary whether
            to use compression on the file or not.  
            </summary>
      <remarks>
        <para>
            Using this callback, the application can 
            specify that previously-compressed files (.mp3, .png, .docx, etc) should 
            not be compressed, for example, or can turn on or off compression based on any 
            other factor.
            </para>
      </remarks>
      <seealso cref="P:Ionic.Zip.ZipFile.WantCompression" />
    </member>
    <member name="T:Ionic.Zip.ZipProgressEventType">
      <summary>
            In an EventArgs type, indicates which sort of progress event is being reported. 
            </summary>
      <remarks>
            There are events for reading, events for saving, and events for extracting. 
            </remarks>
    </member>
    <member name="F:Ionic.Zip.ZipProgressEventType.Adding_Started">
      <summary>
            Indicates that a Add() operation has started.
            </summary>
    </member>
    <member name="F:Ionic.Zip.ZipProgressEventType.Adding_AfterAddEntry">
      <summary>
            Indicates that an individual entry in the archive has been added.
            </summary>
    </member>
    <member name="F:Ionic.Zip.ZipProgressEventType.Adding_Completed">
      <summary>
            Indicates that a Add() operation has completed.
            </summary>
    </member>
    <member name="F:Ionic.Zip.ZipProgressEventType.Reading_Started">
      <summary>
            Indicates that a Read() operation has started.
            </summary>
    </member>
    <member name="F:Ionic.Zip.ZipProgressEventType.Reading_BeforeReadEntry">
      <summary>
            Indicates that an individual entry in the archive is about to be read.
            </summary>
    </member>
    <member name="F:Ionic.Zip.ZipProgressEventType.Reading_AfterReadEntry">
      <summary>
            Indicates that an individual entry in the archive has just been read.
            </summary>
    </member>
    <member name="F:Ionic.Zip.ZipProgressEventType.Reading_Completed">
      <summary>
            Indicates that a Read() operation has completed.
            </summary>
    </member>
    <member name="F:Ionic.Zip.ZipProgressEventType.Reading_ArchiveBytesRead">
      <summary>
            The given event reports the number of bytes read so far
            during a Read() operation.
            </summary>
    </member>
    <member name="F:Ionic.Zip.ZipProgressEventType.Saving_Started">
      <summary>
            Indicates that a Save() operation has started.
            </summary>
    </member>
    <member name="F:Ionic.Zip.ZipProgressEventType.Saving_BeforeWriteEntry">
      <summary>
            Indicates that an individual entry in the archive is about to be written.
            </summary>
    </member>
    <member name="F:Ionic.Zip.ZipProgressEventType.Saving_AfterWriteEntry">
      <summary>
            Indicates that an individual entry in the archive has just been saved.
            </summary>
    </member>
    <member name="F:Ionic.Zip.ZipProgressEventType.Saving_Completed">
      <summary>
            Indicates that a Save() operation has completed.
            </summary>
    </member>
    <member name="F:Ionic.Zip.ZipProgressEventType.Saving_AfterSaveTempArchive">
      <summary>
            Indicates that the zip archive has been created in a
            temporary location during a Save() operation.
            </summary>
    </member>
    <member name="F:Ionic.Zip.ZipProgressEventType.Saving_BeforeRenameTempArchive">
      <summary>
            Indicates that the temporary file is about to be renamed to the final archive 
            name during a Save() operation.
            </summary>
    </member>
    <member name="F:Ionic.Zip.ZipProgressEventType.Saving_AfterRenameTempArchive">
      <summary>
            Indicates that the temporary file is has just been renamed to the final archive 
            name during a Save() operation.
            </summary>
    </member>
    <member name="F:Ionic.Zip.ZipProgressEventType.Saving_AfterCompileSelfExtractor">
      <summary>
            Indicates that the self-extracting archive has been compiled
            during a Save() operation.
            </summary>
    </member>
    <member name="F:Ionic.Zip.ZipProgressEventType.Saving_EntryBytesRead">
      <summary>
            The given event is reporting the number of source bytes that have run through the compressor so far
            during a Save() operation.
            </summary>
    </member>
    <member name="F:Ionic.Zip.ZipProgressEventType.Extracting_BeforeExtractEntry">
      <summary>
            Indicates that an entry is about to be extracted. 
            </summary>
    </member>
    <member name="F:Ionic.Zip.ZipProgressEventType.Extracting_AfterExtractEntry">
      <summary>
            Indicates that an entry has just been extracted. 
            </summary>
    </member>
    <member name="F:Ionic.Zip.ZipProgressEventType.Extracting_ExtractEntryWouldOverwrite">
      <summary>
            Indicates that extraction of an entry would overwrite an existing filesystem file. 
            </summary>
    </member>
    <member name="F:Ionic.Zip.ZipProgressEventType.Extracting_EntryBytesWritten">
      <summary>
            The given event is reporting the number of bytes written so far for the current entry
            during an Extract() operation.
            </summary>
    </member>
    <member name="F:Ionic.Zip.ZipProgressEventType.Extracting_BeforeExtractAll">
      <summary>
            Indicates that an ExtractAll operation is about to begin.
            </summary>
    </member>
    <member name="F:Ionic.Zip.ZipProgressEventType.Extracting_AfterExtractAll">
      <summary>
            Indicates that an ExtractAll operation has completed.
            </summary>
    </member>
    <member name="T:Ionic.Zip.ZipProgressEventArgs">
      <summary>
            Provides information about the progress of a save, read, or extract operation. 
            This is a base class; you will probably use one of the classes derived from this one.
            </summary>
    </member>
    <member name="P:Ionic.Zip.ZipProgressEventArgs.EntriesTotal">
      <summary>
            The total number of entries to be saved or extracted.
            </summary>
    </member>
    <member name="P:Ionic.Zip.ZipProgressEventArgs.CurrentEntry">
      <summary>
            The name of the last entry saved or extracted.
            </summary>
    </member>
    <member name="P:Ionic.Zip.ZipProgressEventArgs.Cancel">
      <summary>
            In an event handler, set this to cancel the save or extract 
            operation that is in progress.
            </summary>
    </member>
    <member name="P:Ionic.Zip.ZipProgressEventArgs.EventType">
      <summary>
            The type of event being reported.
            </summary>
    </member>
    <member name="P:Ionic.Zip.ZipProgressEventArgs.ArchiveName">
      <summary>
            Returns the archive name associated to this event.
            </summary>
    </member>
    <member name="P:Ionic.Zip.ZipProgressEventArgs.BytesTransferred">
      <summary>
            The number of bytes read or written so far for this entry.  
            </summary>
    </member>
    <member name="P:Ionic.Zip.ZipProgressEventArgs.TotalBytesToTransfer">
      <summary>
            Total number of bytes that will be read or written for this entry.
            </summary>
    </member>
    <member name="T:Ionic.Zip.ReadProgressEventArgs">
      <summary>
            Provides information about the progress of a Read operation.
            </summary>
    </member>
    <member name="T:Ionic.Zip.AddProgressEventArgs">
      <summary>
            Provides information about the progress of a Add operation.
            </summary>
    </member>
    <member name="T:Ionic.Zip.SaveProgressEventArgs">
      <summary>
            Provides information about the progress of a save operation.
            </summary>
    </member>
    <member name="M:Ionic.Zip.SaveProgressEventArgs.#ctor(System.String,System.Boolean,System.Int32,System.Int32,Ionic.Zip.ZipEntry)">
      <summary>
            Constructor for the SaveProgressEventArgs.
            </summary>
      <param name="archiveName">the name of the zip archive.</param>
      <param name="before">whether this is before saving the entry, or after</param>
      <param name="entriesTotal">The total number of entries in the zip archive.</param>
      <param name="entriesSaved">Number of entries that have been saved.</param>
      <param name="entry">The entry involved in the event.</param>
    </member>
    <member name="P:Ionic.Zip.SaveProgressEventArgs.EntriesSaved">
      <summary>
            Number of entries saved so far.
            </summary>
    </member>
    <member name="T:Ionic.Zip.ExtractProgressEventArgs">
      <summary>
            Provides information about the progress of the extract operation.
            </summary>
    </member>
    <member name="M:Ionic.Zip.ExtractProgressEventArgs.#ctor(System.String,System.Boolean,System.Int32,System.Int32,Ionic.Zip.ZipEntry,System.String)">
      <summary>
            Constructor for the ExtractProgressEventArgs.
            </summary>
      <param name="archiveName">the name of the zip archive.</param>
      <param name="before">whether this is before saving the entry, or after</param>
      <param name="entriesTotal">The total number of entries in the zip archive.</param>
      <param name="entriesExtracted">Number of entries that have been extracted.</param>
      <param name="entry">The entry involved in the event.</param>
      <param name="extractLocation">The location to which entries are extracted.</param>
    </member>
    <member name="P:Ionic.Zip.ExtractProgressEventArgs.EntriesExtracted">
      <summary>
            Number of entries extracted so far.  This is set only if the 
            EventType is Extracting_BeforeExtractEntry or Extracting_AfterExtractEntry, and 
            the Extract() is occurring witin the scope of a call to ExtractAll().
            </summary>
    </member>
    <member name="P:Ionic.Zip.ExtractProgressEventArgs.ExtractLocation">
      <summary>
            Returns the extraction target location, a filesystem path. 
            </summary>
    </member>
    <member name="T:Ionic.Zip.ZipFile">
      <summary>
            The ZipFile type represents a zip archive file.  This is the main type in the DotNetZip
            class library.  This class reads and writes zip files, as defined in the format for zip
            described by PKWare.  The compression for this implementation was, at one time, based on
            the System.IO.Compression.DeflateStream base class in the .NET Framework base class
            library, available in v2.0 and later of the .NET Framework. As of v1.7 of DotNetZip, the
            compression is provided by a managed-code version of Zlib, included with DotNetZip.
            </summary>
    </member>
    <member name="F:Ionic.Zip.ZipFile.DefaultEncoding">
      <summary>
            The default text encoding used in zip archives.  It is numeric 437, also 
            known as IBM437.
            </summary>
      <seealso cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" />
    </member>
    <member name="M:Ionic.Zip.ZipFile.CheckZip(System.String)">
      <summary>
             Checks a zip file to see if its directory is consistent.
             </summary>
      <remarks>
        <para> In cases of data error, the directory within a zip file can get out of
                 synch with the entries in the zip file.  This method checks the given
                 zip file and returns true if this has occurred.  </para>
        <para> This method may take a long time to run for large zip files.  </para>
        <para>
             This method is not supported in the Reduced or Compact
             Framework versions of DotNetZip.
             </para>
      </remarks>
      <param name="zipFileName">The filename to of the zip file to check.</param>
      <returns>true if the named zip file checks OK. Otherwise, false. </returns>
      <seealso cref="M:Ionic.Zip.ZipFile.FixZipDirectory(System.String)" />
      <seealso cref="M:Ionic.Zip.ZipFile.CheckZip(System.String,System.Boolean,System.Collections.ObjectModel.ReadOnlyCollection{System.String}@)" />
    </member>
    <member name="M:Ionic.Zip.ZipFile.CheckZip(System.String,System.Boolean,System.Collections.ObjectModel.ReadOnlyCollection{System.String}@)">
      <summary>
             Checks a zip file to see if its directory is consistent, 
             and optionally fixes the directory if necessary. 
             </summary>
      <remarks>
        <para> In cases of data error, the directory within a zip file can get out of
                 synch with the entries in the zip file.  This method checks the given
                 zip file, and returns true if this has occurred. It also optionally
                 fixes the zipfile, saving the fixed copy in <em>Name</em>_Fixed.zip.</para>
        <para> This method may take a long time to run for large zip files.  It will
                 take even longer if the file actually needs to be fixed, and if
                 <c>fixIfNecessary</c> is true.  </para>
        <para>
             This method is not supported in the Reduced or Compact
             Framework versions of DotNetZip.
             </para>
      </remarks>
      <param name="zipFileName">The filename to of the zip file to check.</param>
      <param name="fixIfNecessary">If true, the method will fix the zip file if
                 necessary.</param>
      <param name="messages">
             a collection of messages generated while checking, indicating any problems that are found. 
             </param>
      <returns>true if the named zip is OK; false if the file needs to be fixed.</returns>
      <seealso cref="M:Ionic.Zip.ZipFile.CheckZip(System.String)" />
      <seealso cref="M:Ionic.Zip.ZipFile.FixZipDirectory(System.String)" />
    </member>
    <member name="M:Ionic.Zip.ZipFile.FixZipDirectory(System.String)">
      <summary>
             Rewrite the directory within a zipfile.
             </summary>
      <remarks>
        <para> In cases of data error, the directory in a zip file can get out of
                 synch with the entries in the zip file.  This method returns true if
                 this has occurred.  </para>
        <para> This can take a long time for large zip files. </para>
        <para>
             This method is not supported in the Reduced or Compact
             Framework versions of DotNetZip.
             </para>
      </remarks>
      <seealso cref="M:Ionic.Zip.ZipFile.CheckZip(System.String)" />
      <seealso cref="M:Ionic.Zip.ZipFile.CheckZip(System.String,System.Boolean,System.Collections.ObjectModel.ReadOnlyCollection{System.String}@)" />
    </member>
    <member name="M:Ionic.Zip.ZipFile.#ctor(System.String)">
      <summary>
             Creates a new ZipFile instance, using the specified filename. 
             </summary>
      <remarks>
        <para>
             Applications can use this constructor to create a new ZipFile for writing, 
             or to slurp in an existing zip archive for read and update purposes. 
             </para>
        <para>
             To create a new zip archive, an application can call this constructor, passing the
             name of a file that does not exist.  The name may be a fully qualified path. Then the
             application can add directories or files to the ZipFile via <c>AddDirectory()</c>,
             <c>AddFile()</c>, <c>AddItem()</c> and then write the zip archive to the disk by
             calling <c>Save()</c>. The zip file is not actually opened and written to the disk
             until the application calls <c>ZipFile.Save()</c>.  At that point the new zip file
             with the given name is created.
             </para>
        <para>
             If you won't know the name of the zipfile until the time you call
             <c>ZipFile.Save()</c>, or if you plan to save to a stream (which has no name), then
             you should use the no-argument constructor.
             </para>
        <para>
             The application can also call this constructor to read an existing zip archive.
             passing the name of a valid zip file that does exist. But, it's better form to use the
             static <see cref="M:Ionic.Zip.ZipFile.Read(System.String)" /> method, passing the name of the zip file,
             because using <c>ZipFile.Read()</c> in your code communicates very clearly what you
             are doing.  In either case, the file is then read into the <c>ZipFile</c> instance.
             The app can then enumerate the entries or can modify the zip file, for example adding
             entries, removing entries, changing comments, and so on.  
             </para>
        <para>
             One advantage to this parameterized constructor: it allows applications to use the
             same code to add items to a zip archive, regardless of whether the zip file exists.
             </para>
        <para>
             Instances of the ZipFile class are not multi-thread safe.  You may not party on a
             single instance with multiple threads.  You may have multiple threads that each use a
             distinct ZipFile instance, or you can synchronize multi-thread access to a single
             instance.
             </para>
        <para>
             By the way, since DotNetZip is so easy to use, don't you think <see href="http://cheeso.members.winisp.net/DotNetZipDonate.aspx">you should donate
             $5 or $10</see>?
             </para>
      </remarks>
      <exception cref="T:Ionic.Zip.ZipException">
             Thrown if zipFileName refers to an existing file that is not a valid zip file. 
             </exception>
      <example>
             This example shows how to create a zipfile, and add a few files into it. 
             <code>
             String ZipFileToCreate = "archive1.zip";
             String DirectoryToZip  = "c:\\reports";
             using (ZipFile zip = new ZipFile())
             { 
               // Store all files found in the top level directory, into the zip archive.
               String[] filenames = System.IO.Directory.GetFiles(DirectoryToZip);
               zip.AddFiles(filenames, "files");
               zip.Save(ZipFileToCreate);
             }
             </code><code lang="VB">
             Dim ZipFileToCreate As String = "archive1.zip"
             Dim DirectoryToZip As String = "c:\reports"
             Using zip As ZipFile = New ZipFile()
                 Dim filenames As String() = System.IO.Directory.GetFiles(DirectoryToZip)
                 zip.AddFiles(filenames, "files")
                 zip.Save(ZipFileToCreate)
             End Using
             </code></example>
      <param name="zipFileName">The filename to use for the new zip archive.</param>
    </member>
    <member name="M:Ionic.Zip.ZipFile.#ctor(System.String,System.Text.Encoding)">
      <summary>
             Creates a new ZipFile instance, using the specified ZipFileName for the filename, and 
             the specified Encoding.
             </summary>
      <remarks>
        <para>
             See the documentation on the <see cref="M:Ionic.Zip.ZipFile.#ctor(System.String)">ZipFile constructor that
             accepts a single string argument</see> for basic information on all the ZipFile
             constructors.
             </para>
        <para>
             The Encoding is used as the default alternate encoding for entries with filenames or
             comments that cannot be encoded with the IBM437 code page.  This is equivalent to
             setting the <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" /> property on the ZipFile
             instance after construction.
             </para>
        <para>
             Instances of the ZipFile class are not multi-thread safe.  You may not party on a
             single instance with multiple threads.  You may have multiple threads that each use a
             distinct ZipFile instance, or you can synchronize multi-thread access to a single
             instance.
             </para>
      </remarks>
      <exception cref="T:Ionic.Zip.ZipException">
             Thrown if zipFileName refers to an existing file that is not a valid zip file. 
             </exception>
      <param name="zipFileName">The filename to use for the new zip archive.</param>
      <param name="encoding">The Encoding is used as the default alternate 
             encoding for entries with filenames or comments that cannot be encoded 
             with the IBM437 code page. </param>
    </member>
    <member name="M:Ionic.Zip.ZipFile.#ctor">
      <summary>
             Create a zip file, without specifying a target filename or stream to save to. 
             </summary>
      <remarks>
        <para>
             See the documentation on the <see cref="M:Ionic.Zip.ZipFile.#ctor(System.String)">ZipFile constructor that
             accepts a single string argument</see> for basic information on all the ZipFile
             constructors.
             </para>
        <para> After instantiating with this constructor and adding entries to the
             archive, the application should call <see cref="M:Ionic.Zip.ZipFile.Save(System.String)" /> or <see cref="M:Ionic.Zip.ZipFile.Save(System.IO.Stream)" /> to save to a file or a stream,
             respectively.  The application can also set the <see cref="P:Ionic.Zip.ZipFile.Name" /> property and
             then call the no-argument <see cref="M:Ionic.Zip.ZipFile.Save" /> method.  (This is the preferred
             approach for applications that use the library through COM interop.)  If you
             call the no-argument <see cref="M:Ionic.Zip.ZipFile.Save" /> method without having set the
             <c>Name</c> of the ZipFile, either through the parameterized constructor or
             through the explicit property , the Save() will throw, because there is no
             place to save the file.  </para>
        <para> Instances of the ZipFile class are not multi-thread safe.  You may have
             multiple threads that each use a distinct ZipFile instance, or you can
             synchronize multi-thread access to a single instance.  </para>
      </remarks>
      <example>
             This example creates a Zip archive called Backup.zip, containing all the files
             in the directory DirectoryToZip. Files within subdirectories are not zipped up.
             <code>
             using (ZipFile zip = new ZipFile())
             { 
               // Store all files found in the top level directory, into the zip archive.
               // note: this code does not recurse subdirectories!
               String[] filenames = System.IO.Directory.GetFiles(DirectoryToZip);
               zip.AddFiles(filenames, "files");
               zip.Save("Backup.zip");
             }
             </code><code lang="VB">
             Using zip As New ZipFile
                 ' Store all files found in the top level directory, into the zip archive.
                 ' note: this code does not recurse subdirectories!
                 Dim filenames As String() = System.IO.Directory.GetFiles(DirectoryToZip)
                 zip.AddFiles(filenames, "files")
                 zip.Save("Backup.zip")
             End Using
             </code></example>
    </member>
    <member name="M:Ionic.Zip.ZipFile.#ctor(System.Text.Encoding)">
      <summary>
             Create a zip file, specifying a text Encoding, but without specifying a target
             filename or stream to save to.
             </summary>
      <remarks>
        <para>
             See the documentation on the <see cref="M:Ionic.Zip.ZipFile.#ctor(System.String)">ZipFile constructor that
             accepts a single string argument</see> for basic information on all the ZipFile
             constructors.
             </para>
      </remarks>
      <param name="encoding">
             The Encoding is used as the default alternate encoding for entries with filenames or
             comments that cannot be encoded with the IBM437 code page.
             </param>
    </member>
    <member name="M:Ionic.Zip.ZipFile.#ctor(System.String,System.IO.TextWriter)">
      <summary>
             Creates a new ZipFile instance, using the specified ZipFileName for the filename, 
             and the specified status message writer. 
             </summary>
      <remarks>
        <para>
             See the documentation on the <see cref="M:Ionic.Zip.ZipFile.#ctor(System.String)">ZipFile constructor that
             accepts a single string argument</see> for basic information on all the ZipFile
             constructors.
             </para>
        <para>
             This version of the constructor allows the caller to pass in a TextWriter, to which
             verbose messages will be written during extraction or creation of the zip archive.
             A console application may wish to pass System.Console.Out to get messages on the
             Console. A graphical or headless application may wish to capture the messages in a
             different <c>TextWriter</c>, for example, a <c>StringWriter</c>, and then display
             the messages in a TextBox, or generate an audit log of ZipFile operations.
             </para>
        <para>
             To encrypt the data for the  files added to the ZipFile instance, set the Password
             property after creating the ZipFile instance.
             </para>
        <para>
             Instances of the ZipFile class are not multi-thread safe.  You may not party on a
             single instance with multiple threads.  You may have multiple threads that each use a
             distinct ZipFile instance, or you can synchronize multi-thread access to a single
             instance.
             </para>
      </remarks>
      <exception cref="T:Ionic.Zip.ZipException">
             Thrown if zipFileName refers to an existing file that is not a valid zip file. 
             </exception>
      <example>
        <code>
             using (ZipFile zip = new ZipFile("Backup.zip", Console.Out))
             { 
               // Store all files found in the top level directory, into the zip archive.
               // note: this code does not recurse subdirectories!
               // Status messages will be written to Console.Out
               String[] filenames = System.IO.Directory.GetFiles(DirectoryToZip);
               zip.AddFiles(filenames);
               zip.Save();
             }
             </code>
        <code lang="VB">
             Using zip As New ZipFile("Backup.zip", Console.Out)
                 ' Store all files found in the top level directory, into the zip archive.
                 ' note: this code does not recurse subdirectories!
                 ' Status messages will be written to Console.Out
                 Dim filenames As String() = System.IO.Directory.GetFiles(DirectoryToZip)
                 zip.AddFiles(filenames)
                 zip.Save()
             End Using
             </code>
      </example>
      <param name="zipFileName">The filename to use for the new zip archive.</param>
      <param name="statusMessageWriter">A TextWriter to use for writing 
             verbose status messages.</param>
    </member>
    <member name="M:Ionic.Zip.ZipFile.#ctor(System.String,System.IO.TextWriter,System.Text.Encoding)">
      <summary>
             Creates a new ZipFile instance, using the specified ZipFileName for the filename, 
             the specified status message writer, and the specified Encoding.
             </summary>
      <remarks>
        <para>
             This constructor works like the <see cref="M:Ionic.Zip.ZipFile.#ctor(System.String)">ZipFile constructor
             that accepts a single string argument.</see> See that reference for detail on what
             this constructor does.
             </para>
        <para>
             This version of the constructor allows the caller to pass in a TextWriter, and an
             Encoding.  The TextWriter will collect verbose messages that are generated by the
             library during extraction or creation of the zip archive.  A console application
             may wish to pass System.Console.Out to get messages on the Console. A graphical or
             headless application may wish to capture the messages in a different
             <c>TextWriter</c>, for example, a <c>StringWriter</c>, and then display the
             messages in a TextBox, or generate an audit log of ZipFile operations.
             </para>
        <para>
             The Encoding is used as the default alternate encoding for entries with filenames or
             comments that cannot be encoded with the IBM437 code page.  This is a equivalent to
             setting the <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" /> property on the ZipFile
             instance after construction.
             </para>
        <para>
             To encrypt the data for the  files added to the ZipFile instance, set the Password
             property after creating the ZipFile instance.
             </para>
        <para>
             Instances of the ZipFile class are not multi-thread safe.  You may not party on a single
             instance with multiple threads.  You may have multiple threads that each use a distinct ZipFile 
             instance, or you can synchronize multi-thread access to a single instance.
             </para>
      </remarks>
      <exception cref="T:Ionic.Zip.ZipException">
             Thrown if zipFileName refers to an existing file that is not a valid zip file. 
             </exception>
      <param name="zipFileName">The filename to use for the new zip archive.</param>
      <param name="statusMessageWriter">A TextWriter to use for writing verbose 
             status messages.</param>
      <param name="encoding">The Encoding is used as the default alternate encoding 
             for entries with filenames or comments that cannot be encoded with the IBM437 code page.
             </param>
    </member>
    <member name="M:Ionic.Zip.ZipFile.Initialize(System.String)">
      <summary>
             Initialize a ZipFile instance by reading in a zip file.
             </summary>
      <remarks>
        <para> This method is primarily useful from COM Automation environments, when
                 reading or extracting zip files. In COM, it is not possible to invoke
                 parameterized constructors for a class. A COM Automation application can
                 update a zip file by using the default (no argument) constructor, then
                 calling Initialize() to read the contents of an on-disk zip archive into the
                 ZipFile instance.  </para>
        <para>
               .NET applications should use the ZipFile.Read() methods for clarity.
             </para>
      </remarks>
      <param name="zipFileName">the name of the existing zip file to read in.</param>
    </member>
    <member name="M:Ionic.Zip.ZipFile.AddItem(System.String)">
      <summary>
             Adds an item, either a file or a directory, to a zip file archive.  
             </summary>
      <remarks>
        <para>
             This method is handy if you are adding things to zip archive and don't want to bother
             distinguishing between directories or files.  Any files are added as single entries.
             A directory added through this method is added recursively: all files and
             subdirectories contained within the directory are added to the ZipFile.  
             </para>
        <para>
             The name of the item may be a relative path or a fully-qualified path. Remember, the
             items contained in ZipFile instance get written to the disk only when you call
             ZipFile.Save() or a similar save method.
             </para>
        <para>
             The directory name used for the file within the archive is the same as
             the directory name (potentially a relative path) specified in the fileOrDirectoryName.
             </para>
        <para>
             For ZipFile properties including <see cref="P:Ionic.Zip.ZipFile.Encryption" />, <see cref="P:Ionic.Zip.ZipFile.Password" />,
             <see cref="P:Ionic.Zip.ZipFile.WantCompression" />, <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" />, 
             <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile" />, and <see cref="P:Ionic.Zip.ZipFile.ForceNoCompression" />, their respective values at the time of this call will be
             applied to the ZipEntry added.
             </para>
      </remarks>
      <seealso cref="M:Ionic.Zip.ZipFile.AddFile(System.String)" />
      <seealso cref="M:Ionic.Zip.ZipFile.AddDirectory(System.String)" />
      <seealso cref="M:Ionic.Zip.ZipFile.UpdateItem(System.String)" />
      <overloads>This method has two overloads.</overloads>
      <param name="fileOrDirectoryName">the name of the file or directory to add.</param>
      <returns>The ZipEntry added.</returns>
    </member>
    <member name="M:Ionic.Zip.ZipFile.AddItem(System.String,System.String)">
      <summary>
             Adds an item, either a file or a directory, to a zip file archive, 
             explicitly specifying the directory path to be used in the archive. 
             </summary>
      <remarks>
        <para>
             If adding a directory, the add is recursive on all files and subdirectories 
             contained within it. 
             </para>
        <para>
             The name of the item may be a relative path or a fully-qualified path.
             The item added by this call to the ZipFile is not written to the zip file
             archive until the application calls Save() on the ZipFile. 
             </para>
        <para>
             This version of the method allows the caller to explicitly specify the 
             directory path to be used in the archive, which would override the 
             "natural" path of the filesystem file.
             </para>
        <para>
             Encryption will be used on the file data if the Password
             has been set on the ZipFile object, prior to calling this method.
             </para>
        <para>
             For ZipFile properties including <see cref="P:Ionic.Zip.ZipFile.Encryption" />, <see cref="P:Ionic.Zip.ZipFile.Password" />,
             <see cref="P:Ionic.Zip.ZipFile.WantCompression" />, <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" />, 
             <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile" />, and <see cref="P:Ionic.Zip.ZipFile.ForceNoCompression" />, their respective values at the time of this call will be
             applied to the ZipEntry added.
             </para>
      </remarks>
      <exception cref="T:System.IO.FileNotFoundException">
             Thrown if the file or directory passed in does not exist. 
             </exception>
      <param name="fileOrDirectoryName">the name of the file or directory to add.</param>
      <param name="directoryPathInArchive">
             The name of the directory path to use within the zip archive.  This path need not
             refer to an extant directory in the current filesystem.  If the files within the zip
             are later extracted, this is the path used for the extracted file.  Passing null
             (nothing in VB) will use the path on the FileOrDirectoryName.  Passing the empty
             string ("") will insert the item at the root path within the archive.
             </param>
      <seealso cref="M:Ionic.Zip.ZipFile.AddFile(System.String,System.String)" />
      <seealso cref="M:Ionic.Zip.ZipFile.AddDirectory(System.String,System.String)" />
      <seealso cref="M:Ionic.Zip.ZipFile.UpdateItem(System.String,System.String)" />
      <example>
             This example shows how to zip up a set of files into a flat hierarchy, regardless of
             where in the filesystem the files originated. The resulting zip archive will contain a
             toplevel directory named "flat", which itself will contain files Readme.txt,
             MyProposal.docx, and Image1.jpg.  A subdirectory under "flat" called SupportFiles will
             contain all the files in the "c:\SupportFiles" directory on disk.
             <code>
             String[] itemnames= { 
               "c:\\fixedContent\\Readme.txt",
               "MyProposal.docx",
               "c:\\SupportFiles",  // a directory
               "images\\Image1.jpg"
             };
            
             try
             {
               using (ZipFile zip = new ZipFile())
               {
                 for (int i = 1; i &lt; itemnames.Length; i++)
                 {
                   // will add Files or Dirs, recurses and flattens subdirectories
                   zip.AddItem(itemnames[i],"flat"); 
                 }
                 zip.Save(ZipToCreate);
               }
             }
             catch (System.Exception ex1)
             {
               System.Console.Error.WriteLine("exception: {0}", ex1);
             }
             </code><code lang="VB">
               Dim itemnames As String() = _
                 New String() { "c:\fixedContent\Readme.txt", _
                                "MyProposal.docx", _
                                "SupportFiles", _
                                "images\Image1.jpg" }
               Try 
                   Using zip As New ZipFile
                       Dim i As Integer
                       For i = 1 To itemnames.Length - 1
                           ' will add Files or Dirs, recursing and flattening subdirectories.
                           zip.AddItem(itemnames(i), "flat")
                       Next i
                       zip.Save(ZipToCreate)
                   End Using
               Catch ex1 As Exception
                   Console.Error.WriteLine("exception: {0}", ex1.ToString())
               End Try
             </code></example>
      <returns>The ZipEntry added.</returns>
    </member>
    <member name="M:Ionic.Zip.ZipFile.AddFile(System.String)">
      <summary>
             Adds a File to a Zip file archive. 
             </summary>
      <remarks>
        <para>
             The file added by this call to the ZipFile is not written to the zip file
             archive until the application calls Save() on the ZipFile. 
             </para>
        <para>
             This method will throw an Exception if an entry with the same name already exists
             in the ZipFile.
             </para>
        <para>
             For ZipFile properties including <see cref="P:Ionic.Zip.ZipFile.Encryption" />, <see cref="P:Ionic.Zip.ZipFile.Password" />,
             <see cref="P:Ionic.Zip.ZipFile.WantCompression" />, <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" />, 
             <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile" />, and <see cref="P:Ionic.Zip.ZipFile.ForceNoCompression" />, their respective values at the time of this call will be
             applied to the ZipEntry added.
             </para>
      </remarks>
      <example>
        <para>
             In this example, three files are added to a Zip archive. The ReadMe.txt file
             will be placed in the root of the archive. The .png file will be placed in a folder 
             within the zip called photos\personal.  The pdf file will be included into a
             folder within the zip called Desktop.
             </para>
        <code>
                try
                {
                  using (ZipFile zip = new ZipFile())
                  {
                    zip.AddFile("c:\\photos\\personal\\7440-N49th.png");
                    zip.AddFile("c:\\Desktop\\2008-Regional-Sales-Report.pdf");
                    zip.AddFile("ReadMe.txt");
            
                    zip.Save("Package.zip");
                  }
                }
                catch (System.Exception ex1)
                {
                  System.Console.Error.WriteLine("exception: " + ex1);
                }
             </code>
        <code lang="VB">
              Try 
                   Using zip As ZipFile = New ZipFile
                       zip.AddFile("c:\photos\personal\7440-N49th.png")
                       zip.AddFile("c:\Desktop\2008-Regional-Sales-Report.pdf")
                       zip.AddFile("ReadMe.txt")
                       zip.Save("Package.zip")
                   End Using
               Catch ex1 As Exception
                   Console.Error.WriteLine("exception: {0}", ex1.ToString)
               End Try
             </code>
      </example>
      <overloads>This method has two overloads.</overloads>
      <seealso cref="M:Ionic.Zip.ZipFile.AddItem(System.String)" />
      <seealso cref="M:Ionic.Zip.ZipFile.AddDirectory(System.String)" />
      <seealso cref="M:Ionic.Zip.ZipFile.UpdateFile(System.String)" />
      <param name="fileName">
             The name of the file to add. It should refer to a file in the filesystem.  
             The name of the file may be a relative path or a fully-qualified path. 
             </param>
      <returns>The ZipEntry corresponding to the File added.</returns>
    </member>
    <member name="M:Ionic.Zip.ZipFile.AddFile(System.String,System.String)">
      <summary>
             Adds a File to a Zip file archive, potentially overriding the path to be used
             within the zip archive.
             </summary>
      <remarks>
        <para>
             The file added by this call to the ZipFile is not written to the zip file
             archive until the application calls Save() on the ZipFile. 
             </para>
        <para>
             This method will throw an Exception if an entry with the same name already exists
             in the ZipFile.
             </para>
        <para>
             This version of the method allows the caller to explicitly specify the 
             directory path to be used in the archive. 
             </para>
        <para>
             For ZipFile properties including <see cref="P:Ionic.Zip.ZipFile.Encryption" />, <see cref="P:Ionic.Zip.ZipFile.Password" />,
             <see cref="P:Ionic.Zip.ZipFile.WantCompression" />, <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" />, 
             <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile" />, and <see cref="P:Ionic.Zip.ZipFile.ForceNoCompression" />, their respective values at the time of this call will be
             applied to the ZipEntry added.
             </para>
      </remarks>
      <example>
        <para>
             In this example, three files are added to a Zip archive. The ReadMe.txt file
             will be placed in the root of the archive. The .png file will be placed in a folder 
             within the zip called images.  The pdf file will be included into a
             folder within the zip called files\docs, and will be encrypted with the 
             given password.
             </para>
        <code>
             try
             {
               using (ZipFile zip = new ZipFile())
               {
                 // the following entry will be inserted at the root in the archive.
                 zip.AddFile("c:\\datafiles\\ReadMe.txt", "");
                 // this image file will be inserted into the "images" directory in the archive.
                 zip.AddFile("c:\\photos\\personal\\7440-N49th.png", "images");
                 // the following will result in a password-protected file called 
                 // files\\docs\\2008-Regional-Sales-Report.pdf  in the archive.
                 zip.Password = "EncryptMe!";
                 zip.AddFile("c:\\Desktop\\2008-Regional-Sales-Report.pdf", "files\\docs");
                 zip.Save("Archive.zip");
               }
             }
             catch (System.Exception ex1)
             {
               System.Console.Error.WriteLine("exception: {0}", ex1);
             }
             </code>
        <code lang="VB">
               Try 
                   Using zip As ZipFile = New ZipFile
                       ' the following entry will be inserted at the root in the archive.
                       zip.AddFile("c:\datafiles\ReadMe.txt", "")
                       ' this image file will be inserted into the "images" directory in the archive.
                       zip.AddFile("c:\photos\personal\7440-N49th.png", "images")
                       ' the following will result in a password-protected file called 
                       ' files\\docs\\2008-Regional-Sales-Report.pdf  in the archive.
                       zip.Password = "EncryptMe!"
                       zip.AddFile("c:\Desktop\2008-Regional-Sales-Report.pdf", "files\documents")
                       zip.Save("Archive.zip")
                   End Using
               Catch ex1 As Exception
                   Console.Error.WriteLine("exception: {0}", ex1)
               End Try
             </code>
      </example>
      <seealso cref="M:Ionic.Zip.ZipFile.AddItem(System.String,System.String)" />
      <seealso cref="M:Ionic.Zip.ZipFile.AddDirectory(System.String,System.String)" />
      <seealso cref="M:Ionic.Zip.ZipFile.UpdateFile(System.String,System.String)" />
      <param name="fileName">
             The name of the file to add.  The name of the file may be a relative path or 
             a fully-qualified path.
             </param>
      <param name="directoryPathInArchive">
             Specifies a directory path to use to override any path in the FileName.  This path
             may, or may not, correspond to a real directory in the current filesystem.  If the
             files within the zip are later extracted, this is the path used for the extracted
             file.  Passing null (nothing in VB) will use the path on the FileName, if any.
             Passing the empty string ("") will insert the item at the root path within the
             archive.
             </param>
      <returns>The ZipEntry corresponding to the file added.</returns>
    </member>
    <member name="M:Ionic.Zip.ZipFile.RemoveEntries(System.Collections.Generic.ICollection{Ionic.Zip.ZipEntry})">
      <summary>
             This method removes a collection of entries from the ZipFile.
             </summary>
      <param name="entriesToRemove">
             A collection of ZipEntry instances from this zip file to be removed. For example, 
             you can pass in an array of ZipEntry instances; or you can call SelectEntries(), and 
             then add or remove entries from that ICollection&lt;ZipEntry&gt;
             (ICollection(Of ZipEntry) in VB), and pass that ICollection to this method.
             </param>
      <seealso cref="M:Ionic.Zip.ZipFile.SelectEntries(System.String)" />
      <seealso cref="M:Ionic.Zip.ZipFile.RemoveSelectedEntries(System.String)" />
    </member>
    <member name="M:Ionic.Zip.ZipFile.RemoveEntries(System.Collections.Generic.ICollection{System.String})">
      <summary>
             This method removes a collection of entries from the ZipFile, by name.
             </summary>
      <param name="entriesToRemove">
             A collection of strings that refer to names of entries to be removed from the ZipFile. 
             For example, 
             you can pass in an array of ZipEntry instances; or you can call SelectEntries(), and 
             then add or remove entries from that ICollection&lt;ZipEntry&gt;
             (ICollection(Of ZipEntry) in VB), and pass that ICollection to this method.
             </param>
      <seealso cref="M:Ionic.Zip.ZipFile.SelectEntries(System.String)" />
      <seealso cref="M:Ionic.Zip.ZipFile.RemoveSelectedEntries(System.String)" />
    </member>
    <member name="M:Ionic.Zip.ZipFile.AddFiles(System.Collections.Generic.IEnumerable{System.String})">
      <summary>
             This method adds a set of files to the ZipFile.
             </summary>
      <remarks>
        <para>
             Use this method to add a set of files to the zip archive, in one call.  
             </para>
        <para>
             For ZipFile properties including <see cref="P:Ionic.Zip.ZipFile.Encryption" />, <see cref="P:Ionic.Zip.ZipFile.Password" />,
             <see cref="P:Ionic.Zip.ZipFile.WantCompression" />, <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" />, 
             <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile" />, and <see cref="P:Ionic.Zip.ZipFile.ForceNoCompression" />, their respective values at the time of this call will be
             applied to each ZipEntry added.
             </para>
      </remarks>
      <param name="fileNames">
             The collection of names of the files to add. Each string should refer to a file in 
             the filesystem. The name of the file may be a relative path or a fully-qualified path. 
             </param>
      <example>
             This example shows how to create a zipfile, and add a few files into it. 
             <code>
             String ZipFileToCreate = "archive1.zip";
             String DirectoryToZip = "c:\\reports";
             using (ZipFile zip = new ZipFile())
             { 
               // Store all files found in the top level directory, into the zip archive.
               String[] filenames = System.IO.Directory.GetFiles(DirectoryToZip);
               zip.AddFiles(filenames);
               zip.Save(ZipFileToCreate);
             }
             </code><code lang="VB">
             Dim ZipFileToCreate As String = "archive1.zip"
             Dim DirectoryToZip As String = "c:\reports"
             Using zip As ZipFile = New ZipFile
                 ' Store all files found in the top level directory, into the zip archive.
                 Dim filenames As String() = System.IO.Directory.GetFiles(DirectoryToZip)
                 zip.AddFiles(filenames)
                 zip.Save(ZipFileToCreate)
             End Using
             </code></example>
      <seealso cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String,System.String)" />
    </member>
    <member name="M:Ionic.Zip.ZipFile.UpdateFiles(System.Collections.Generic.IEnumerable{System.String})">
      <summary>
             Adds or updates a set of files in the ZipFile.
             </summary>
      <remarks>
        <para>
             Any files that already exist in the archive are updated. Any files that don't yet
             exist in the archive are added.
             </para>
        <para>
             For ZipFile properties including <see cref="P:Ionic.Zip.ZipFile.Encryption" />, <see cref="P:Ionic.Zip.ZipFile.Password" />,
             <see cref="P:Ionic.Zip.ZipFile.WantCompression" />, <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" />, 
             <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile" />, and <see cref="P:Ionic.Zip.ZipFile.ForceNoCompression" />, their respective values at the time of this call will be
             applied to each ZipEntry added.
             </para>
      </remarks>
      <param name="fileNames">
             The collection of names of the files to update. Each string should refer to a file in 
             the filesystem. The name of the file may be a relative path or a fully-qualified path. 
             </param>
    </member>
    <member name="M:Ionic.Zip.ZipFile.AddFiles(System.Collections.Generic.IEnumerable{System.String},System.String)">
      <summary>
             Adds a set of files to the ZipFile, using the specified directory path 
             in the archive.
             </summary>
      <remarks>
        <para>
             Any directory structure that may be present in the filenames contained in the list is
             "flattened" in the archive.  Each file in the list is added to the archive in the
             specified top-level directory. 
             </para>
        <para>
             For ZipFile properties including <see cref="P:Ionic.Zip.ZipFile.Encryption" />, <see cref="P:Ionic.Zip.ZipFile.Password" />,
             <see cref="P:Ionic.Zip.ZipFile.WantCompression" />, <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" />, 
             <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile" />, and <see cref="P:Ionic.Zip.ZipFile.ForceNoCompression" />, their respective values at the time of this call will be
             applied to each ZipEntry added.
             </para>
      </remarks>
      <param name="fileNames">
             The names of the files to add. Each string should refer to a file in the filesystem.  
             The name of the file may be a relative path or a fully-qualified path. 
             </param>
      <param name="directoryPathInArchive">
             Specifies a directory path to use to override any path in the file name.  This path
             may, or may not, correspond to a real directory in the current filesystem.  If the
             files within the zip are later extracted, this is the path used for the extracted
             file.  Passing null (nothing in VB) will use the path on the FileName, if any.
             Passing the empty string ("") will insert the item at the root path within the
             archive.
             </param>
      <seealso cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String,System.String)" />
    </member>
    <member name="M:Ionic.Zip.ZipFile.AddFiles(System.Collections.Generic.IEnumerable{System.String},System.Boolean,System.String)">
      <summary>
             Adds a set of files to the ZipFile, using the specified directory path 
             in the archive, and preserving the full directory structure in the filenames.
             </summary>
      <remarks>
        <para>
             If preserveDirHierarchy is true, any directory structure present in the filenames
             contained in the list is preserved in the archive.  On the other hand, if
             preserveDirHierarchy is false, any directory structure that may be present in the
             filenames contained in the list is "flattened" in the archive; Each file in the list
             is added to the archive in the specified top-level directory.
             </para>
        <para>
             For ZipFile properties including <see cref="P:Ionic.Zip.ZipFile.Encryption" />, <see cref="P:Ionic.Zip.ZipFile.Password" />,
             <see cref="P:Ionic.Zip.ZipFile.WantCompression" />, <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" />, 
             <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile" />, and <see cref="P:Ionic.Zip.ZipFile.ForceNoCompression" />, their respective values at the time of this call will be
             applied to each ZipEntry added.
             </para>
      </remarks>
      <param name="fileNames">
             The names of the files to add. Each string should refer to a file in the filesystem.  
             The name of the file may be a relative path or a fully-qualified path. 
             </param>
      <param name="directoryPathInArchive">
             Specifies a directory path to use to override any path in the file name.  This path
             may, or may not, correspond to a real directory in the current filesystem.  If the
             files within the zip are later extracted, this is the path used for the extracted
             file.  Passing null (nothing in VB) will use the path on the FileName, if any.
             Passing the empty string ("") will insert the item at the root path within the
             archive.
             </param>
      <param name="preserveDirHierarchy">
             whether the entries in the zip archive will reflect the dir hierarchy that is present in each filename. 
             </param>
      <seealso cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String,System.String)" />
    </member>
    <member name="M:Ionic.Zip.ZipFile.UpdateFiles(System.Collections.Generic.IEnumerable{System.String},System.String)">
      <summary>
             Adds or updates a set of files to the ZipFile, using the specified directory path 
             in the archive.
             </summary>
      <remarks>
        <para>
             Any files that already exist in the archive are updated. Any files that don't yet
             exist in the archive are added.
             </para>
        <para>
             For ZipFile properties including <see cref="P:Ionic.Zip.ZipFile.Encryption" />, <see cref="P:Ionic.Zip.ZipFile.Password" />,
             <see cref="P:Ionic.Zip.ZipFile.WantCompression" />, <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" />, 
             <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile" />, and <see cref="P:Ionic.Zip.ZipFile.ForceNoCompression" />, their respective values at the time of this call will be
             applied to each ZipEntry added.
             </para>
      </remarks>
      <param name="fileNames">
             The names of the files to add or update. Each string should refer to a file in the filesystem.  
             The name of the file may be a relative path or a fully-qualified path. 
             </param>
      <param name="directoryPathInArchive">
             Specifies a directory path to use to override any path in the file name.  This path
             may, or may not, correspond to a real directory in the current filesystem.  If the
             files within the zip are later extracted, this is the path used for the extracted
             file.  Passing null (nothing in VB) will use the path on the FileName, if any.
             Passing the empty string ("") will insert the item at the root path within the
             archive.
             </param>
      <seealso cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String,System.String)" />
    </member>
    <member name="M:Ionic.Zip.ZipFile.UpdateFile(System.String)">
      <summary>
             Adds or Updates a File in a Zip file archive.
             </summary>
      <remarks>
        <para>
             This method adds a file to a zip archive, or, if the file already exists in the zip archive, 
             this method Updates the content of that given filename in the zip archive.  
             The <c>UpdateFile</c> method might more accurately be called "AddOrUpdateFile".
             </para>
        <para>
             Upon success, there is no way for the application to learn whether the file was added
             versus updated.
             </para>
        <para>
             For ZipFile properties including <see cref="P:Ionic.Zip.ZipFile.Encryption" />, <see cref="P:Ionic.Zip.ZipFile.Password" />,
             <see cref="P:Ionic.Zip.ZipFile.WantCompression" />, <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" />, 
             <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile" />, and <see cref="P:Ionic.Zip.ZipFile.ForceNoCompression" />, their respective values at the time of this call will be
             applied to the ZipEntry added.
             </para>
      </remarks>
      <example>
             This example shows how to Update an existing entry in a zipfile. The first call to 
             UpdateFile adds the file to the newly-created zip archive.  The second 
             call to UpdateFile updates the content for that file in the zip archive.
             <code>
             using (ZipFile zip1 = new ZipFile())
             {
               // UpdateFile might more accurately be called "AddOrUpdateFile"
               zip1.UpdateFile("MyDocuments\\Readme.txt", "");
               zip1.UpdateFile("CustomerList.csv", "");
               zip1.Comment = "This zip archive has been created.";
               zip1.Save("Content.zip");
             }
             
             using (ZipFile zip2 = ZipFile.Read("Content.zip"))
             {
               zip2.UpdateFile("Updates\\Readme.txt", "");
               zip2.Comment = "This zip archive has been updated: The Readme.txt file has been changed.";
               zip2.Save();
             }
            
             </code><code lang="VB">
               Using zip1 As New ZipFile
                   ' UpdateFile might more accurately be called "AddOrUpdateFile"
                   zip1.UpdateFile("MyDocuments\Readme.txt", "")
                   zip1.UpdateFile("CustomerList.csv", "")
                   zip1.Comment = "This zip archive has been created."
                   zip1.Save("Content.zip")
               End Using
            
               Using zip2 As ZipFile = ZipFile.Read("Content.zip")
                   zip2.UpdateFile("Updates\Readme.txt", "")
                   zip2.Comment = "This zip archive has been updated: The Readme.txt file has been changed."
                   zip2.Save
               End Using
             </code></example>
      <seealso cref="M:Ionic.Zip.ZipFile.AddFile(System.String)" />
      <seealso cref="M:Ionic.Zip.ZipFile.UpdateDirectory(System.String)" />
      <seealso cref="M:Ionic.Zip.ZipFile.UpdateItem(System.String)" />
      <param name="fileName">
             The name of the file to add or update. It should refer to a file in the filesystem.  
             The name of the file may be a relative path or a fully-qualified path. 
             </param>
      <returns>The ZipEntry corresponding to the File that was added or updated.</returns>
    </member>
    <member name="M:Ionic.Zip.ZipFile.UpdateFile(System.String,System.String)">
      <summary>
             Adds or Updates a File in a Zip file archive.
             </summary>
      <remarks>
        <para>
             This method adds a file to a zip archive, or, if the file already exists in the zip
             archive, this method Updates the content of that given filename in the zip archive.
             </para>
        <para>
             This version of the method allows the caller to explicitly specify the 
             directory path to be used in the archive.  The entry to be added or updated is found by 
             using the specified directory path, combined with the basename of the specified 
             filename. 
             </para>
        <para>
             Upon success, there is no way for the application to learn if the file was 
             added versus updated. 
             </para>
        <para>
             For ZipFile properties including <see cref="P:Ionic.Zip.ZipFile.Encryption" />, <see cref="P:Ionic.Zip.ZipFile.Password" />,
             <see cref="P:Ionic.Zip.ZipFile.WantCompression" />, <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" />, 
             <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile" />, and <see cref="P:Ionic.Zip.ZipFile.ForceNoCompression" />, their respective values at the time of this call will be
             applied to the ZipEntry added.
             </para>
      </remarks>
      <seealso cref="M:Ionic.Zip.ZipFile.AddFile(System.String,System.String)" />
      <seealso cref="M:Ionic.Zip.ZipFile.UpdateDirectory(System.String,System.String)" />
      <seealso cref="M:Ionic.Zip.ZipFile.UpdateItem(System.String,System.String)" />
      <param name="fileName">
             The name of the file to add or update. It should refer to a file in the filesystem.  
             The name of the file may be a relative path or a fully-qualified path. 
             </param>
      <param name="directoryPathInArchive">
             Specifies a directory path to use to override any path in the FileName.  This path
             may, or may not, correspond to a real directory in the current filesystem.  If the
             files within the zip are later extracted, this is the path used for the extracted
             file.  Passing null (nothing in VB) will use the path on the FileName, if any.
             Passing the empty string ("") will insert the item at the root path within the
             archive.
             </param>
      <returns>The ZipEntry corresponding to the File that was added or updated.</returns>
    </member>
    <member name="M:Ionic.Zip.ZipFile.UpdateDirectory(System.String)">
      <summary>
             Add or Update a Directory in a zip archive.  
             </summary>
      <remarks>
             If the specified directory does not exist in the archive, then this method is
             equivalent to calling AddDirectory().  If the specified directory already exists in
             the archive, then this method updates any existing entries, and adds any new
             entries. Any entries that are in the zip archive but not in the specified directory,
             are left alone.  In other words, the contents of the zip file will be a union of the
             previous contents and the new files.
             </remarks>
      <seealso cref="M:Ionic.Zip.ZipFile.UpdateFile(System.String)" />
      <seealso cref="M:Ionic.Zip.ZipFile.AddDirectory(System.String)" />
      <seealso cref="M:Ionic.Zip.ZipFile.UpdateItem(System.String)" />
      <param name="directoryName">The path to the directory to be added to the zip archive, 
             or updated in the zip archive.</param>
      <returns>The ZipEntry corresponding to the Directory that was added or updated.</returns>
    </member>
    <member name="M:Ionic.Zip.ZipFile.UpdateDirectory(System.String,System.String)">
      <summary>
             Add or Update a directory in the zip archive at the specified root directory in the
             archive.  
             </summary>
      <remarks>
             If the specified directory does not exist in the archive, then this method is
             equivalent to calling AddDirectory().  If the specified directory already exists in
             the archive, then this method updates any existing entries, and adds any new
             entries. Any entries that are in the zip archive but not in the specified directory,
             are left alone.  In other words, the contents of the zip file will be a union of the
             previous contents and the new files.
             </remarks>
      <seealso cref="M:Ionic.Zip.ZipFile.UpdateFile(System.String,System.String)" />
      <seealso cref="M:Ionic.Zip.ZipFile.AddDirectory(System.String,System.String)" />
      <seealso cref="M:Ionic.Zip.ZipFile.UpdateItem(System.String,System.String)" />
      <param name="directoryName">The path to the directory to be added to the zip archive, 
             or updated in the zip archive.</param>
      <param name="directoryPathInArchive">
             Specifies a directory path to use to override any path in the ItemName.  This path
             may, or may not, correspond to a real directory in the current filesystem.  If the
             files within the zip are later extracted, this is the path used for the extracted
             file.  Passing null (nothing in VB) will use the path on the FileName, if any.
             Passing the empty string ("") will insert the item at the root path within the
             archive.
             </param>
      <returns>The ZipEntry corresponding to the Directory that was added or updated.</returns>
    </member>
    <member name="M:Ionic.Zip.ZipFile.UpdateItem(System.String)">
      <summary>
             Add or Update a File or Directory in the zip archive. 
             </summary>
      <remarks>
        <para>
             This is useful when the application is not sure or does not care if the item to be
             added is a file or directory, and does not know or does not care if the item already
             exists in the ZipFile. Calling this method is equivalent to calling RemoveEntry() if
             an entry by the same name already exists, followed calling by AddItem().
             </para>
        <para>
             For ZipFile properties including <see cref="P:Ionic.Zip.ZipFile.Encryption" />, <see cref="P:Ionic.Zip.ZipFile.Password" />,
             <see cref="P:Ionic.Zip.ZipFile.WantCompression" />, <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" />, 
             <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile" />, and <see cref="P:Ionic.Zip.ZipFile.ForceNoCompression" />, their respective values at the time of this call will be
             applied to the ZipEntry added.
             </para>
      </remarks>
      <seealso cref="M:Ionic.Zip.ZipFile.AddItem(System.String)" />
      <seealso cref="M:Ionic.Zip.ZipFile.UpdateFile(System.String)" />
      <seealso cref="M:Ionic.Zip.ZipFile.UpdateDirectory(System.String)" />
      <param name="itemName">the path to the file or directory to be added or updated.</param>
    </member>
    <member name="M:Ionic.Zip.ZipFile.UpdateItem(System.String,System.String)">
      <summary>
             Add or Update a File or Directory.  
             </summary>
      <remarks>
        <para>
             This method is useful when the application is not sure or does not care if the item to be
             added is a file or directory, and does not know or does not care if the item already
             exists in the ZipFile. Calling this method is equivalent to  calling
             RemoveEntry(), if an entry by that name exists, and then calling  AddItem().
             </para>
        <para>
             This version of the method allows the caller to explicitly specify the directory path
             to be used for the item being added to the archive.  The entry or entries that are
             added or updated will use the specified <c>DirectoryPathInArchive</c>. Extracting the
             entry from the archive will result in a file stored in that directory path.
             </para>
        <para>
             For ZipFile properties including <see cref="P:Ionic.Zip.ZipFile.Encryption" />, <see cref="P:Ionic.Zip.ZipFile.Password" />,
             <see cref="P:Ionic.Zip.ZipFile.WantCompression" />, <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" />, 
             <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile" />, and <see cref="P:Ionic.Zip.ZipFile.ForceNoCompression" />, their respective values at the time of this call will be
             applied to the ZipEntry added.
             </para>
      </remarks>
      <seealso cref="M:Ionic.Zip.ZipFile.AddItem(System.String,System.String)" />
      <seealso cref="M:Ionic.Zip.ZipFile.UpdateFile(System.String,System.String)" />
      <seealso cref="M:Ionic.Zip.ZipFile.UpdateDirectory(System.String,System.String)" />
      <param name="itemName">The path for the File or Directory to be added or updated.</param>
      <param name="directoryPathInArchive">
             Specifies a directory path to use to override any path in the ItemName.  This path
             may, or may not, correspond to a real directory in the current filesystem.  If the
             files within the zip are later extracted, this is the path used for the extracted
             file.  Passing null (nothing in VB) will use the path on the FileName, if any.
             Passing the empty string ("") will insert the item at the root path within the
             archive.
             </param>
    </member>
    <member name="M:Ionic.Zip.ZipFile.AddEntry(System.String,System.String,System.IO.Stream)">
      <summary>
             Create an entry in the ZipFile using the given Stream as input.  The entry 
             will have the given filename and given directory path.  
             </summary>
      <remarks>
        <para>The application can provide an open, readable stream; in this case it
             will be read during the call to <see cref="M:Ionic.Zip.ZipFile.Save" /> or one of its overloads.  </para>
        <para>In cases where a large number of streams will be added to the ZipFile,
             the application may wish to avoid maintaining all of the streams open
             simultaneously.  To handle this situation, the application can provide a null
             value (Nothing in VB) for the stream, and provide a handler for the <see cref="E:Ionic.Zip.ZipFile.SaveProgress" /> event.  Later, during the call to
             <c>ZipFile.Save</c>, DotNetZip will invoke the SaveProgress event handler,
             and within that handler, when the <see cref="P:Ionic.Zip.ZipProgressEventArgs.EventType">e.EventType</see> is
             <c>ZipProgressEventType.Saving_BeforeWriteEntry</c>, the application can
             dispense the stream for each entry on a just-in-time basis by setting the <see cref="P:Ionic.Zip.ZipEntry.InputStream" /> property.  The application can close or
             dispose the stream for each entry in a similar manner, when the <c>e.EventType</c> is
             <c>ZipProgressEventType.Saving_AfterWriteEntry</c>. Check the documentation
             of <see cref="P:Ionic.Zip.ZipEntry.InputStream" /> for more information and a code
             sample.  </para>
        <para> For ZipFile properties including <see cref="P:Ionic.Zip.ZipFile.Encryption" />, <see cref="P:Ionic.Zip.ZipFile.Password" />, <see cref="P:Ionic.Zip.ZipFile.WantCompression" />, <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" />, <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile" />,
             and <see cref="P:Ionic.Zip.ZipFile.ForceNoCompression" />, their respective values at the time of
             this call will be applied to the ZipEntry added.  </para>
      </remarks>
      <example>
        <para>
             This example adds a single entry to a ZipFile via a stream. 
             </para>
        <code lang="C#">
             String ZipToCreate = "Content.zip";
             String FileNameInArchive = "Content-From-Stream.bin";
             using (System.IO.Stream StreamToRead = MyStreamOpener())
             {
               using (ZipFile zip = new ZipFile())
               {
                 ZipEntry entry= zip.AddEntry(FileNameInArchive, "basedirectory", StreamToRead);
                 entry.Comment = "The content for this entry in the zip file was obtained from a stream";
                 zip.AddFile("Readme.txt");
                 zip.Save(ZipToCreate);
               }
             }
             
             </code>
        <code lang="VB">
             Dim ZipToCreate As String = "Content.zip"
             Dim FileNameInArchive As String = "Content-From-Stream.bin"
             Using StreamToRead as System.IO.Stream = MyStreamOpener()
               Using zip As ZipFile = New ZipFile()
                 Dim entry as ZipEntry = zip.AddEntry(FileNameInArchive, "basedirectory", StreamToRead)
                 entry.Comment = "The content for this entry in the zip file was obtained from a stream"
                 zip.AddFile("Readme.txt")
                 zip.Save(ZipToCreate)
               End Using
             End Using
             </code>
      </example>
      <seealso cref="M:Ionic.Zip.ZipFile.UpdateEntry(System.String,System.String,System.IO.Stream)" />
      <param name="fileName">FileName which is shown in the ZIP File</param>
      <param name="directoryPathInArchive">
             Specifies a directory path to use to override any path in the ItemName.
             This path may, or may not, correspond to a real directory in the current filesystem.
             If the files within the zip are later extracted, this is the path used for the extracted file. 
             Passing null (nothing in VB) will use the path on the FileName, if any.  Passing the empty string ("")
             will insert the item at the root path within the archive. 
             </param>
      <param name="stream">the input stream from which to grab content for the file</param>
      <returns>The ZipEntry added.</returns>
    </member>
    <member name="M:Ionic.Zip.ZipFile.AddFileFromStream(System.String,System.String,System.IO.Stream)">
      <summary>
             Create an entry in the ZipFile using the given Stream as input.  The entry will have the
             given filename and given directory path.  
             </summary>
      <remarks>
             This method has been deprecated. Please use <see cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,System.String,System.IO.Stream)" />.  This method will be removed in a future version of this library.
             </remarks>
    </member>
    <member name="M:Ionic.Zip.ZipFile.AddFileStream(System.String,System.String,System.IO.Stream)">
      <summary>
             Uses the given stream as input to create an entry in the ZipFile, with the 
             given FileName and given Directory Path.  
             </summary>
      <remarks>
             This method has been deprecated. Please use <see cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,System.String,System.IO.Stream)" />.  This method will be removed in a future version of this library.
             </remarks>
    </member>
    <member name="M:Ionic.Zip.ZipFile.AddEntry(System.String,System.String,System.String)">
      <summary>
             Adds a named entry into the zip archive, taking content for the entry
             from a string.
             </summary>
      <remarks>Calling this method creates an entry using the given fileName and
             directory path within the archive.  There is no need for a file by the given
             name to exist in the filesystem; the name is used within the zip archive
             only. The content for the entry is encoded using the default text encoding
             (<see cref="P:System.Text.Encoding.Default" />).  </remarks>
      <param name="stringContent">The content of the file, should it be extracted from
             the zip.</param>
      <param name="fileName">The filename to use within the archive.</param>
      <param name="directoryPathInArchive"> Specifies a directory path to use to
             override any path in the fileName.  This path need not correspond to a real
             directory in the current filesystem when creating the zip file.  If the
             files within the zip are later extracted, this is the path used for the
             extracted file.  Passing null (nothing in VB) will use the path on the
             fileName, if any.  Passing the empty string ("") will insert the item at the
             root path within the archive.  </param>
      <returns>The ZipEntry added.</returns>
      <example>
            
             This example shows how to add an entry to the zipfile, using a string as
             content for that entry.
            
             <code lang="C#">
             string Content = "This string will be the content of the Readme.txt file in the zip archive.";
             using (ZipFile zip1 = new ZipFile())
             {
               zip1.AddFile("MyDocuments\\Resume.doc", "files");
               zip1.AddEntry("Readme.txt", "", Content); 
               zip1.Comment = "This zip file was created at " + System.DateTime.Now.ToString("G");
               zip1.Save("Content.zip");
             }
             
             </code><code lang="VB">
             Public Sub Run()
               Dim Content As String = "This string will be the content of the Readme.txt file in the zip archive."
               Using zip1 As ZipFile = New ZipFile
                 zip1.AddEntry("Readme.txt", "", Content)
                 zip1.AddFile("MyDocuments\Resume.doc", "files")
                 zip1.Comment = ("This zip file was created at " &amp; DateTime.Now.ToString("G"))
                 zip1.Save("Content.zip")
               End Using
             End Sub
             </code></example>
    </member>
    <member name="M:Ionic.Zip.ZipFile.AddFileFromString(System.String,System.String,System.String)">
      <summary>
             Adds a named entry into the zip archive, taking content for the entry
             from a string.
             </summary>
      <remarks>
             This method has been deprecated. Please use <see cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,System.String,System.String)" />.  This method will be removed in a future version of this library.
             </remarks>
    </member>
    <member name="M:Ionic.Zip.ZipFile.AddEntry(System.String,System.String,System.String,System.Text.Encoding)">
      <summary>
             Adds a named entry into the zip archive, taking content for the entry
             from a string.
             </summary>
      <remarks>
        <para>Calling this method creates an entry using the given fileName and
             directory path within the archive.  There is no need for a file by the given
             name to exist in the filesystem; the name is used within the zip archive
             only. </para>
        <para> The content for the entry is encoded using the given text
             encoding. No Byte-order-mark (BOM) is emitted into the file. </para>
        <para>If you wish to create within a zip file a file entry with
             Unicode-encoded content that includes a byte-order-mark, you can convert
             your string to a byte array using the appropriate <see cref="M:System.Text.Encoding.GetBytes(System.String)" /> method, then prepend to that byte
             array the output of <see cref="M:System.Text.Encoding.GetPreamble" />, and use the
             <c>AddEntry(string,string,byte[])</c> method, to add the entry.
             </para>
      </remarks>
      <param name="fileName">The filename to use within the archive.</param>
      <param name="directoryPathInArchive"> Specifies a directory path to use to
             override any path in the fileName.  This path need not correspond to a real
             directory in the current filesystem when creating the zip file.  If the
             files within the zip are later extracted, this is the path used for the
             extracted file.  Passing null (nothing in VB) will use the path on the
             fileName, if any.  Passing the empty string ("") will insert the item at the
             root path within the archive.  </param>
      <param name="stringContent">The content of the file, should it be extracted from
             the zip.</param>
      <param name="encoding">The text encoding to use when encoding the
             string. Be aware: This is distinct from the text encoding used to encode the
             filename. See <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" />.  </param>
      <returns>The ZipEntry added.</returns>
    </member>
    <member name="M:Ionic.Zip.ZipFile.UpdateEntry(System.String,System.String,System.String)">
      <summary>
             Updates the given entry in the ZipFile, using the given string as input.
             </summary>
      <remarks>
        <para>
             Calling this method is equivalent to removing the ZipEntry for the
             given fileName and directory path, if it exists, and then calling <see cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,System.String,System.String)" />.  See the documentation
             for that method for further explanation. </para>
      </remarks>
      <param name="fileName">The filename to use within the archive.</param>
      <param name="directoryPathInArchive"> Specifies a directory path to use to
             override any path in the fileName.  This path need not correspond to a real
             directory in the current filesystem when creating the zip file.  If the
             files within the zip are later extracted, this is the path used for the
             extracted file.  Passing null (nothing in VB) will use the path on the
             fileName, if any.  Passing the empty string ("") will insert the item at the
             root path within the archive.  </param>
      <param name="content">The content of the file, should it be extracted from
             the zip.</param>
      <returns>The ZipEntry added.</returns>
    </member>
    <member name="M:Ionic.Zip.ZipFile.UpdateEntry(System.String,System.String,System.String,System.Text.Encoding)">
      <summary>
             Updates the given entry in the ZipFile, using the given string as content
             for the ZipEntry. 
             </summary>
      <remarks>Calling this method is equivalent to removing the ZipEntry for the
             given fileName and directory path, if it exists, and then calling <see cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,System.String,System.String,System.Text.Encoding)" />.
             See the documentation for that method for further explanation. </remarks>
      <param name="fileName">The filename to use within the archive.</param>
      <param name="directoryPathInArchive"> Specifies a directory path to use to
             override any path in the fileName.  This path need not correspond to a real
             directory in the current filesystem when creating the zip file.  If the
             files within the zip are later extracted, this is the path used for the
             extracted file.  Passing null (nothing in VB) will use the path on the
             fileName, if any.  Passing the empty string ("") will insert the item at the
             root path within the archive.  </param>
      <param name="stringContent">The content of the file, should it be extracted from
             the zip.</param>
      <param name="encoding">The text encoding to use when encoding the
             string. Be aware: This is distinct from the text encoding used to encode the
             filename. See <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" />.  </param>
      <returns>The ZipEntry added.</returns>
    </member>
    <member name="M:Ionic.Zip.ZipFile.UpdateEntry(System.String,System.String,System.IO.Stream)">
      <summary>
             Updates the given entry in the ZipFile, using the given stream as input, and the
             given filename and given directory Path.  
             </summary>
      <remarks>
        <para>
             Calling the method is equivalent to calling RemoveEntry() if an entry by the same name
             already exists, and then calling AddEntry() with the given fileName and stream.
             </para>
        <para>
             The stream must be open and readable during the call to 
             <c>ZipFile.Save</c>.  You can dispense the stream on a just-in-time basis using
             the <see cref="P:Ionic.Zip.ZipEntry.InputStream" /> property. Check the documentation of that
             property for more information. 
             </para>
        <para>
             For ZipFile properties including <see cref="P:Ionic.Zip.ZipFile.Encryption" />, <see cref="P:Ionic.Zip.ZipFile.Password" />,
             <see cref="P:Ionic.Zip.ZipFile.WantCompression" />, <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" />, 
             <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile" />, and <see cref="P:Ionic.Zip.ZipFile.ForceNoCompression" />, their respective values at the time of this call will be
             applied to the ZipEntry added.
             </para>
      </remarks>
      <seealso cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,System.String,System.IO.Stream)" />
      <seealso cref="P:Ionic.Zip.ZipEntry.InputStream" />
      <param name="fileName">the name associated to the entry in the zip archive.</param>
      <param name="directoryPathInArchive">The root path to be used in the zip archive, 
             for the entry added from the stream.</param>
      <param name="stream">The input stream from which to read file data.</param>
      <returns>The ZipEntry added.</returns>
    </member>
    <member name="M:Ionic.Zip.ZipFile.UpdateFileStream(System.String,System.String,System.IO.Stream)">
      <summary>
             Updates the given entry in the ZipFile, using the given stream as input, and the
             given FileName and given Directory Path.  
             </summary>
      <remarks>
             This method has been deprecated. Please use <see cref="M:Ionic.Zip.ZipFile.UpdateEntry(System.String,System.String,System.IO.Stream)" />.  This method will be removed in a future version of this library.
             </remarks>
    </member>
    <member name="M:Ionic.Zip.ZipFile.AddEntry(System.String,System.String,System.Byte[])">
      <summary>
             Add an entry into the zip archive using the given filename and directory
             path within the archive, and the given content for the file. No file is
             created in the filesystem.
             </summary>
      <param name="byteContent">The data to use for the entry.</param>
      <param name="fileName">The filename to use within the archive.</param>
      <param name="directoryPathInArchive">
             Specifies a directory path to use for the entry. 
             This path may, or may not, correspond to a real directory in the current
             filesystem.  If the files within the zip are later extracted, this is the
             path used for the extracted file.  Passing null (nothing in VB) will use the
             path on the fileName, if any. Passing the empty string ("") will insert the
             item at the root path within the archive.
             </param>
      <returns>The ZipEntry added.</returns>
    </member>
    <member name="M:Ionic.Zip.ZipFile.UpdateEntry(System.String,System.String,System.Byte[])">
      <summary>
             Updates the given entry in the ZipFile, using the given byte array as
             content for the entry.
             </summary>
      <remarks>Calling this method is equivalent to removing the ZipEntry for the
             given fileName and directory path, if it exists, and then calling <see cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,System.String,System.String,System.Text.Encoding)" />.
             See the documentation for that method for further explanation. </remarks>
      <param name="fileName">The filename to use within the archive.</param>
      <param name="directoryPathInArchive"> Specifies a directory path to use to
             override any path in the fileName.  This path need not correspond to a real
             directory in the current filesystem when creating the zip file.  If the
             files within the zip are later extracted, this is the path used for the
             extracted file.  Passing null (nothing in VB) will use the path on the
             fileName, if any.  Passing the empty string ("") will insert the item at the
             root path within the archive.  </param>
      <param name="byteContent">The content to use for the ZipEntry.</param>
      <returns>The ZipEntry added.</returns>
    </member>
    <member name="M:Ionic.Zip.ZipFile.AddDirectory(System.String)">
      <summary>
             Adds the contents of a filesystem directory to a Zip file archive. 
             </summary>
      <remarks>
        <para>
             The name of the directory may be a relative path or a fully-qualified path. Any files
             within the named directory are added to the archive.  Any subdirectories within the
             named directory are also added to the archive, recursively.
             </para>
        <para>
             Top-level entries in the named directory will appear as top-level 
             entries in the zip archive.  Entries in subdirectories in the named 
             directory will result in entries in subdirectories in the zip archive.
             </para>
        <para>
             If you want the entries to appear in a containing directory in the zip
             archive itself, then you should call the AddDirectory() overload that allows
             you to explicitly specify a directory path for use in the archive.
             </para>
        <para>
             For ZipFile properties including <see cref="P:Ionic.Zip.ZipFile.Encryption" />, <see cref="P:Ionic.Zip.ZipFile.Password" />,
             <see cref="P:Ionic.Zip.ZipFile.WantCompression" />, <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" />, 
             <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile" />, and <see cref="P:Ionic.Zip.ZipFile.ForceNoCompression" />, their respective values at the time of this call will be
             applied to each ZipEntry added.
             </para>
      </remarks>
      <seealso cref="M:Ionic.Zip.ZipFile.AddItem(System.String)" />
      <seealso cref="M:Ionic.Zip.ZipFile.AddFile(System.String)" />
      <seealso cref="M:Ionic.Zip.ZipFile.UpdateDirectory(System.String)" />
      <seealso cref="M:Ionic.Zip.ZipFile.AddDirectory(System.String,System.String)" />
      <overloads>This method has 2 overloads.</overloads>
      <param name="directoryName">The name of the directory to add.</param>
      <returns>The ZipEntry added.</returns>
    </member>
    <member name="M:Ionic.Zip.ZipFile.AddDirectory(System.String,System.String)">
      <summary>
             Adds the contents of a filesystem directory to a Zip file archive, 
             overriding the path to be used for entries in the archive. 
             </summary>
      <remarks>
        <para>
             The name of the directory may be a relative path or a fully-qualified
             path. The add operation is recursive, so that any files or subdirectories
             within the name directory are also added to the archive.
             </para>
        <para>
             Top-level entries in the named directory will appear as top-level 
             entries in the zip archive.  Entries in subdirectories in the named 
             directory will result in entries in subdirectories in the zip archive.
             </para>
        <para>
             For ZipFile properties including <see cref="P:Ionic.Zip.ZipFile.Encryption" />, <see cref="P:Ionic.Zip.ZipFile.Password" />,
             <see cref="P:Ionic.Zip.ZipFile.WantCompression" />, <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" />, 
             <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile" />, and <see cref="P:Ionic.Zip.ZipFile.ForceNoCompression" />, their respective values at the time of this call will be
             applied to each ZipEntry added.
             </para>
      </remarks>
      <example>
        <para>
             In this code, calling the ZipUp() method with a value of "c:\reports" for the
             directory parameter will result in a zip file structure in which all entries
             are contained in a toplevel "reports" directory.
             </para>
        <code lang="C#">
             public void ZipUp(string targetZip, string directory)
             {
               using (var zip = new ZipFile())
               {
                 zip.AddDirectory(directory, System.IO.Path.GetFileName(directory));
                 zip.Save(targetZip);
               }
             }
             </code>
      </example>
      <seealso cref="M:Ionic.Zip.ZipFile.AddItem(System.String,System.String)" />
      <seealso cref="M:Ionic.Zip.ZipFile.AddFile(System.String,System.String)" />
      <seealso cref="M:Ionic.Zip.ZipFile.UpdateDirectory(System.String,System.String)" />
      <param name="directoryName">The name of the directory to add.</param>
      <param name="directoryPathInArchive">
             Specifies a directory path to use to override any path in the DirectoryName.
             This path may, or may not, correspond to a real directory in the current filesystem.
             If the zip is later extracted, this is the path used for the extracted file or directory. 
             Passing null (nothing in VB) or the empty string ("")
             will insert the items at the root path within the archive. 
             </param>
      <returns>The ZipEntry added.</returns>
    </member>
    <member name="M:Ionic.Zip.ZipFile.AddDirectoryByName(System.String)">
      <summary>
             Creates a directory in the zip archive.  
             </summary>
      <remarks>
        <para>
             Use this when you want to create a directory in the archive but there is no
             corresponding filesystem representation for that directory.
             </para>
        <para>
             You will probably not need to do this in your code. One of the only times
             you will want to do this is if you want an empty directory in the zip
             archive.  The reason: if you add a file to a zip archive that is stored within a
             multi-level directory, all of the directory tree is implicitly created in
             the zip archive.  
             </para>
      </remarks>
      <param name="directoryNameInArchive">
             The name of the directory to create in the archive.
             </param>
      <returns>The ZipEntry added.</returns>
    </member>
    <member name="M:Ionic.Zip.ZipFile.Save">
      <summary>
             Saves the Zip archive to a file, specified by the Name property of the ZipFile. 
             </summary>
      <remarks>
        <para>
             The ZipFile instance is written to storage, typically a zip file in a
             filesystem, only when the caller calls <c>Save</c>.  The Save operation writes
             the zip content to a temporary file, and then renames the temporary file
             to the desired name. If necessary, this method will delete a pre-existing file
             before the rename.
             </para>
        <para> The <see cref="P:Ionic.Zip.ZipFile.Name" /> property is specified either
             explicitly, or implicitly using one of the parameterized ZipFile
             constructors.  For COM Automation clients, the <c>Name</c> property must be
             set explicitly, because COM Automation clients cannot call parameterized
             constructors.  </para>
        <para>
             When using a filesystem file for the Zip output, it is possible to call
             <c>Save</c> multiple times on the ZipFile instance. With each call the zip
             content is re-written to the same output file.
             </para>
        <para>
             Data for entries that have been added to the <c>ZipFile</c> instance is written
             to the output when the <c>Save</c> method is called. This means that the input
             streams for those entries must be available at the time the application calls
             <c>Save</c>.  If, for example, the application adds entries with <c>AddEntry</c>
             using a dynamically-allocated <c>MemoryStream</c>, the memory stream must not
             have been disposed before the call to <c>Save</c>. See the <see cref="P:Ionic.Zip.ZipEntry.InputStream" /> property for more discussion of the availability
             requirements of the input stream for an entry, and an approach for providing
             just-in-time stream lifecycle management.
             </para>
      </remarks>
      <seealso cref="M:Ionic.Zip.ZipFile.AddEntry(System.String,System.String,System.IO.Stream)" />
      <exception cref="T:Ionic.Zip.BadStateException">
             Thrown if you haven't specified a location or stream for saving the zip,
             either in the constructor or by setting the Name property, or if you try to
             save a regular zip archive to a filename with a .exe extension.
             </exception>
    </member>
    <member name="M:Ionic.Zip.ZipFile.Save(System.String)">
      <summary>
             Save the file to a new zipfile, with the given name. 
             </summary>
      <remarks>
        <para>
             This method allows the application to explicitly specify the name of the zip
             file when saving. Use this when creating a new zip file, or when 
             updating a zip archive.  
             </para>
        <para>
             An application can also save a zip archive in several places by calling this method
             multiple times in succession, with different filenames. 
             </para>
        <para>
             The ZipFile instance is written to storage, typically a zip file in a
             filesystem, only when the caller calls <c>Save</c>.  The Save operation writes
             the zip content to a temporary file, and then renames the temporary file
             to the desired name. If necessary, this method will delete a pre-existing file
             before the rename.
             </para>
      </remarks>
      <exception cref="T:System.ArgumentException">
             Thrown if you specify a directory for the filename.
             </exception>
      <param name="zipFileName">
             The name of the zip archive to save to. Existing files will 
             be overwritten with great prejudice.
             </param>
      <example>
             This example shows how to create and Save a zip file.
             <code>
             using (ZipFile zip = new ZipFile())
             {
               zip.AddDirectory(@"c:\reports\January");
               zip.Save("January.zip");
             }
             </code><code lang="VB">
             Using zip As New ZipFile()
               zip.AddDirectory("c:\reports\January")
               zip.Save("January.zip")
             End Using
             </code></example>
      <example>
             This example shows how to update a zip file.
             <code>
             using (ZipFile zip = ZipFile.Read("ExistingArchive.zip"))
             {
               zip.AddFile("NewData.csv");
               zip.Save("UpdatedArchive.zip");
             }
             </code><code lang="VB">
             Using zip As ZipFile = ZipFile.Read("ExistingArchive.zip")
               zip.AddFile("NewData.csv")
               zip.Save("UpdatedArchive.zip")
             End Using
             </code></example>
    </member>
    <member name="M:Ionic.Zip.ZipFile.Save(System.IO.Stream)">
      <summary>
             Save the zip archive to the specified stream.
             </summary>
      <remarks>
        <para>
             The ZipFile instance is written to storage - typically a zip file in a
             filesystem, but using this overload, the storage can eb anything accessible via
             a writable stream - only when the caller calls <c>Save</c>.
             </para>
        <para>
             Use this method to save the zip content to a stream directly.  A common scenario
             is an ASP.NET application that dynamically generates a zip file and allows the
             browser to download it. The application can call <c>Save(Response.OutputStream)</c>
             to write a zipfile directly to the output stream, without creating a zip file on the
             disk on the ASP.NET server. 
             </para>
      </remarks>
      <param name="outputStream">The <c>System.IO.Stream</c> to write to. It must be writable.</param>
    </member>
    <member name="M:Ionic.Zip.ZipFile.IsZipFile(System.String)">
      <summary>
            Checks the given file to see if it appears to be a valid zip file.
            </summary>
      <remarks>
        <para>
            Calling this method is equivalent to calling 
            <see cref="M:Ionic.Zip.ZipFile.IsZipFile(System.String,System.Boolean)" /> with the testExtract parameter set to false.
            </para>
      </remarks>
      <param name="fileName">The file to check.</param>
      <returns>true if the file appears to be a zip file.</returns>
    </member>
    <member name="M:Ionic.Zip.ZipFile.IsZipFile(System.String,System.Boolean)">
      <summary>
             Checks a to see if a file is a valid zip file.
             </summary>
      <remarks>
        <para>
             This method opens the specified zip file, reads in the zip archive, verifying
             the ZIP metadata as it reads.  Then, if testExtract is true, this method extracts 
             each entry in the archive, dumping all the bits. 
             </para>
        <para>
             If everything succeeds, then the method
             returns true.  If anything fails - for example if an incorrect signature or CRC
             is found, indicating a corrupt file, the the method returns false.  This method also returns false
             for a file that does not exist. 
             </para>
        <para>
             If <c>testExtract</c> is true, this method reads in the content for each
             entry, expands it, and checks CRCs.  This provides an additional check
             beyond verifying the zip header data.
             </para>
        <para>
             If <c>testExtract</c> is true, and if any of the zip entries are protected
             with a password, this method will return false.  If you want to verify a
             ZipFile that has entries which are protected with a password, you will need
             to do that manually.
             </para>
      </remarks>
      <param name="fileName">The zip file to check.</param>
      <param name="testExtract">true if the caller wants to extract each entry.</param>
      <returns>true if the file appears to be a valid zip file.</returns>
    </member>
    <member name="M:Ionic.Zip.ZipFile.Read(System.String)">
      <summary>
             Reads a zip file archive and returns the instance.  
             </summary>
      <remarks>
        <para>
             The stream is read using the default <c>System.Text.Encoding</c>, which is the <c>IBM437</c> codepage.  
             </para>
      </remarks>
      <exception cref="T:System.Exception">
             Thrown if the ZipFile cannot be read. The implementation of this 
             method relies on <c>System.IO.File.OpenRead</c>, which can throw
             a variety of exceptions, including specific exceptions if a file
             is not found, an unauthorized access exception, exceptions for
             poorly formatted filenames, and so on. 
             </exception>
      <param name="zipFileName">
             The name of the zip archive to open.  
             This can be a fully-qualified or relative pathname.
             </param>
      <overloads>This method has a bunch of interesting overloads. They are all static
             (Shared in VB).  One of them is bound to be right for you.  The reason there are so
             many is that there are a few properties on the ZipFile class that must be set 
             before you read the zipfile in, for them to be useful.  The set of overloads covers
             the most interesting cases.  Probably there are still too many, though.</overloads>
      <returns>The instance read from the zip archive.</returns>
    </member>
    <member name="M:Ionic.Zip.ZipFile.Read(System.String,System.EventHandler{Ionic.Zip.ReadProgressEventArgs})">
      <summary>
            Reads a zip file archive and returns the instance, using the specified
            ReadProgress event handler.  
            </summary>
      <param name="zipFileName">
            The name of the zip archive to open.  
            This can be a fully-qualified or relative pathname.
            </param>
      <param name="readProgress">
            An event handler for Read operations.
            </param>
      <returns>The instance read from the zip archive.</returns>
    </member>
    <member name="M:Ionic.Zip.ZipFile.Read(System.String,System.IO.TextWriter)">
      <summary>
             Reads a zip file archive using the specified text encoding, and returns the instance.  
             </summary>
      <remarks>
        <para>
             This version of the method allows the caller to pass in a <c>TextWriter</c>.  
             The ZipFile is read in using the default IBM437 encoding for entries where UTF-8 
             encoding is not explicitly specified.
             </para>
      </remarks>
      <example>
        <code lang="C#">
             var sw = new System.IO.StringWriter();
             using (ZipFile zip =  ZipFile.Read("PackedDocuments.zip", sw))
             {
               var Threshold = new DateTime(2007,7,4);
               // We cannot remove the entry from the list, within the context of 
               // an enumeration of said list.
               // So we add the doomed entry to a list to be removed later.
               // pass 1: mark the entries for removal
               var MarkedEntries = new System.Collections.Generic.List&lt;ZipEntry&gt;();
               foreach (ZipEntry e in zip)
               {
                 if (e.LastModified &lt; Threshold)
                   MarkedEntries.Add(e);
               }
               // pass 2: actually remove the entry. 
               foreach (ZipEntry zombie in MarkedEntries)
                  zip.RemoveEntry(zombie);
               zip.Comment = "This archive has been updated.";
               zip.Save();
             }
             // can now use contents of sw, eg store in an audit log
             </code>
        <code lang="VB">
               Dim sw As New System.IO.StringWriter
               Using zip As ZipFile = ZipFile.Read("PackedDocuments.zip", sw)
                   Dim Threshold As New DateTime(2007, 7, 4)
                   ' We cannot remove the entry from the list, within the context of 
                   ' an enumeration of said list.
                   ' So we add the doomed entry to a list to be removed later.
                   ' pass 1: mark the entries for removal
                   Dim MarkedEntries As New System.Collections.Generic.List(Of ZipEntry)
                   Dim e As ZipEntry
                   For Each e In zip
                       If (e.LastModified &lt; Threshold) Then
                           MarkedEntries.Add(e)
                       End If
                   Next
                   ' pass 2: actually remove the entry. 
                   Dim zombie As ZipEntry
                   For Each zombie In MarkedEntries
                       zip.RemoveEntry(zombie)
                   Next
                   zip.Comment = "This archive has been updated."
                   zip.Save
               End Using
               ' can now use contents of sw, eg store in an audit log
             </code>
      </example>
      <exception cref="T:System.Exception">
             Thrown if the zipfile cannot be read. The implementation of this 
             method relies on <c>System.IO.File.OpenRead</c>, which can throw
             a variety of exceptions, including specific exceptions if a file
             is not found, an unauthorized access exception, exceptions for
             poorly formatted filenames, and so on. 
             </exception>
      <param name="zipFileName">
             The name of the zip archive to open.  
             This can be a fully-qualified or relative pathname.
             </param>
      <param name="statusMessageWriter">
             The <c>System.IO.TextWriter</c> to use for writing verbose status messages during operations
             on the zip archive.  A console application may wish to pass <c>System.Console.Out</c> to get 
             messages on the Console. A graphical or headless application may wish to capture the messages 
             in a different <c>TextWriter</c>, such as a <c>System.IO.StringWriter</c>. 
             </param>
      <returns>The instance read from the zip archive.</returns>
    </member>
    <member name="M:Ionic.Zip.ZipFile.Read(System.String,System.IO.TextWriter,System.EventHandler{Ionic.Zip.ReadProgressEventArgs})">
      <summary>
            Reads a zip file archive using the specified text encoding, and the
            specified ReadProgress event handler, and returns the instance.  
            </summary>
      <param name="zipFileName">
            The name of the zip archive to open.  
            This can be a fully-qualified or relative pathname.
            </param>
      <param name="readProgress">
            An event handler for Read operations.
            </param>
      <param name="statusMessageWriter">
            The <c>System.IO.TextWriter</c> to use for writing verbose status messages during operations
            on the zip archive.  A console application may wish to pass <c>System.Console.Out</c> to get 
            messages on the Console. A graphical or headless application may wish to capture the messages 
            in a different <c>TextWriter</c>, such as a <c>System.IO.StringWriter</c>. 
            </param>
      <returns>The instance read from the zip archive.</returns>
    </member>
    <member name="M:Ionic.Zip.ZipFile.Read(System.String,System.Text.Encoding)">
      <summary>
             Reads a zip file archive using the specified text encoding, and returns the instance.  
             </summary>
      <remarks>
        <para>
             This version of the method allows the caller to pass in an <c>Encoding</c>.  
             The ZipFile is read in using the specified encoding for entries where UTF-8
             encoding is not explicitly specified.
             </para>
      </remarks>
      <example>
             This example shows how to read a zip file using the Big-5 Chinese code page (950), 
             and extract each entry in the zip file.
             For this code to work as desired, the zipfile must have been created using the big5
             code page (CP950). This is typical, for example, when using WinRar on a machine with
             CP950 set as the default code page.  In that case, the names of entries within the Zip
             archive will be stored in that code page, and reading the zip archive must be done
             using that code page.  If the application did not use the correct code page in
             ZipFile.Read(), then names of entries within the zip archive would not be correctly
             retrieved.
             <code lang="C#">
             using (ZipFile zip = ZipFile.Read(ZipToExtract,
                                               System.Text.Encoding.GetEncoding(950)))
             {
               foreach (ZipEntry e in zip)
               {
                  e.Extract(extractDirectory);
               }
             }
             </code><code lang="VB">
             Using zip As ZipFile = ZipFile.Read(ZipToExtract, System.Text.Encoding.GetEncoding(950))
                 Dim e As ZipEntry
                 For Each e In zip
                  e.Extract(extractDirectory)
                 Next
             End Using
             </code></example>
      <exception cref="T:System.Exception">
             Thrown if the zipfile cannot be read. The implementation of this 
             method relies on <c>System.IO.File.OpenRead</c>, which can throw
             a variety of exceptions, including specific exceptions if a file
             is not found, an unauthorized access exception, exceptions for
             poorly formatted filenames, and so on. 
             </exception>
      <param name="zipFileName">
             The name of the zip archive to open.  
             This can be a fully-qualified or relative pathname.
             </param>
      <param name="encoding">
             The <c>System.Text.Encoding</c> to use when reading in the zip archive. Be careful specifying the
             encoding.  If the value you use here is not the same as the Encoding used when the zip archive was 
             created (possibly by a different archiver) you will get unexpected results and possibly exceptions. 
             </param>
      <seealso cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding">ProvisionalAlternateEncoding</seealso>.
            
             <returns>The instance read from the zip archive.</returns></member>
    <member name="M:Ionic.Zip.ZipFile.Read(System.String,System.Text.Encoding,System.EventHandler{Ionic.Zip.ReadProgressEventArgs})">
      <summary>
             Reads a zip file archive using the specified text encoding and ReadProgress
             event handler, and returns the instance.  
             </summary>
      <param name="zipFileName">
             The name of the zip archive to open.  
             This can be a fully-qualified or relative pathname.
             </param>
      <param name="readProgress">
             An event handler for Read operations.
             </param>
      <param name="encoding">
             The <c>System.Text.Encoding</c> to use when reading in the zip archive. Be careful specifying the
             encoding.  If the value you use here is not the same as the Encoding used when the zip archive was 
             created (possibly by a different archiver) you will get unexpected results and possibly exceptions. 
             </param>
      <returns>The instance read from the zip archive.</returns>
    </member>
    <member name="M:Ionic.Zip.ZipFile.Read(System.String,System.IO.TextWriter,System.Text.Encoding)">
      <summary>
             Reads a zip file archive using the specified text encoding and the specified
             TextWriter for status messages, and returns the instance.  
             </summary>
      <remarks>
        <para>
             This version of the method allows the caller to pass in a <c>TextWriter</c> and an <c>Encoding</c>.  
             The ZipFile is read in using the specified encoding for entries where UTF-8
             encoding is not explicitly specified.
             </para>
      </remarks>
      <example>
             This example shows how to read a zip file using the Big-5 Chinese code page (950), 
             and extract each entry in the zip file, while sending status messages out to the Console. 
             <code lang="C#">
             using (ZipFile zip = ZipFile.Read(ZipToExtract,
                                               System.Console.Out,
                                               System.Text.Encoding.GetEncoding(950)))
             {
               foreach (ZipEntry e in zip)
               {
                  e.Extract(extractDirectory);
               }
             }
             </code></example>
      <exception cref="T:System.Exception">
             Thrown if the zipfile cannot be read. The implementation of this 
             method relies on <c>System.IO.File.OpenRead</c>, which can throw
             a variety of exceptions, including specific exceptions if a file
             is not found, an unauthorized access exception, exceptions for
             poorly formatted filenames, and so on. 
             </exception>
      <param name="zipFileName">
             The name of the zip archive to open.  
             This can be a fully-qualified or relative pathname.
             </param>
      <param name="statusMessageWriter">
             The <c>System.IO.TextWriter</c> to use for writing verbose status messages during operations
             on the zip archive.  A console application may wish to pass <c>System.Console.Out</c> to get 
             messages on the Console. A graphical or headless application may wish to capture the messages 
             in a different <c>TextWriter</c>, such as a <c>System.IO.StringWriter</c>. 
             </param>
      <param name="encoding">
             The <c>System.Text.Encoding</c> to use when reading in the zip archive. Be careful specifying the
             encoding.  If the value you use here is not the same as the Encoding used when the zip archive was 
             created (possibly by a different archiver) you will get unexpected results and possibly exceptions.  
             </param>
      <seealso cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" />
      <returns>The instance read from the zip archive.</returns>
    </member>
    <member name="M:Ionic.Zip.ZipFile.Read(System.String,System.IO.TextWriter,System.Text.Encoding,System.EventHandler{Ionic.Zip.ReadProgressEventArgs})">
      <summary>
             Reads a zip file archive using the specified text encoding,  the specified
             TextWriter for status messages, and the specified ReadProgress event handler, 
             and returns the instance.  
             </summary>
      <param name="zipFileName">
             The name of the zip archive to open.  
             This can be a fully-qualified or relative pathname.
             </param>
      <param name="readProgress">
             An event handler for Read operations.
             </param>
      <param name="statusMessageWriter">
             The <c>System.IO.TextWriter</c> to use for writing verbose status messages during operations
             on the zip archive.  A console application may wish to pass <c>System.Console.Out</c> to get 
             messages on the Console. A graphical or headless application may wish to capture the messages 
             in a different <c>TextWriter</c>, such as a <c>System.IO.StringWriter</c>. 
             </param>
      <param name="encoding">
             The <c>System.Text.Encoding</c> to use when reading in the zip archive. Be careful specifying the
             encoding.  If the value you use here is not the same as the Encoding used when the zip archive was 
             created (possibly by a different archiver) you will get unexpected results and possibly exceptions. 
             </param>
      <returns>The instance read from the zip archive.</returns>
    </member>
    <member name="M:Ionic.Zip.ZipFile.Read(System.IO.Stream)">
      <summary>
             Reads a zip archive from a stream.
             </summary>
      <remarks>
        <para>
             This is useful when when the zip archive content is available from 
             an already-open stream. The stream must be open and readable when calling this
             method.  The stream is left open when the reading is completed. 
             </para>
        <para>
             The stream is read using the default <c>System.Text.Encoding</c>, which is the <c>IBM437</c> codepage.  
             </para>
      </remarks>
      <example>
             This example shows how to Read zip content from a stream, and extract
             one entry into a different stream. In this example, the filename
             "NameOfEntryInArchive.doc", refers only to the name of the entry
             within the zip archive.  A file by that name is not created in the
             filesystem.  The I/O is done strictly with the given streams.
             <code>
             using (ZipFile zip = ZipFile.Read(InputStream))
             {
               zip.Extract("NameOfEntryInArchive.doc", OutputStream);
             }
             </code><code lang="VB">
             Using zip as ZipFile = ZipFile.Read(InputStream)
               zip.Extract("NameOfEntryInArchive.doc", OutputStream)
             End Using
             </code></example>
      <param name="zipStream">the stream containing the zip data.</param>
      <returns>an instance of ZipFile</returns>
    </member>
    <member name="M:Ionic.Zip.ZipFile.Read(System.IO.Stream,System.EventHandler{Ionic.Zip.ReadProgressEventArgs})">
      <summary>
             Reads a zip archive from a stream, with a given ReadProgress event handler.
             </summary>
      <remarks>
             When opening large zip archives, you may want to display a progress bar or other
             indicator of status progress while reading.  This Read() method allows you to specify
             a ReadProgress Event Handler directly,
             </remarks>
      <param name="zipStream">the stream containing the zip data.</param>
      <param name="readProgress">
             An event handler for Read operations.
             </param>
      <returns>an instance of ZipFile corresponding to the stream being read.</returns>
    </member>
    <member name="M:Ionic.Zip.ZipFile.Read(System.IO.Stream,System.IO.TextWriter)">
      <summary>
             Reads a zip archive from a stream, using the specified TextWriter for status messages.
             </summary>
      <remarks>
        <para>
             This method is useful when when the zip archive content is available from 
             an already-open stream. The stream must be open and readable when calling this
             method.  The stream is left open when the reading is completed. 
             </para>
        <para>
             The stream is read using the default <c>System.Text.Encoding</c>, which is the <c>IBM437</c> codepage.  
             For more information on the encoding, see the <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding">ProvisionalAlternateEncoding</see> property.
             </para>
      </remarks>
      <exception cref="T:Ionic.Zip.ZipException">
             Thrown if zipStream is null.
             In this case, the inner exception is an ArgumentException.
             </exception>
      <param name="zipStream">the stream containing the zip data.</param>
      <param name="statusMessageWriter">
             The <c>System.IO.TextWriter</c> to which verbose status messages are written during
             operations on the ZipFile.  For example, in a console application,
             System.Console.Out works, and will get a message for each entry added to the
             ZipFile.  If the TextWriter is null, no verbose messages are written.
             </param>
      <returns>an instance of ZipFile</returns>
    </member>
    <member name="M:Ionic.Zip.ZipFile.Read(System.IO.Stream,System.IO.TextWriter,System.EventHandler{Ionic.Zip.ReadProgressEventArgs})">
      <summary>
             Reads a zip archive from a stream, using the specified TextWriter for status messages, 
             and the specified ReadProgress event handler.
             </summary>
      <param name="zipStream">the stream containing the zip data.</param>
      <param name="statusMessageWriter">
             The <c>System.IO.TextWriter</c> to which verbose status messages are written during
             operations on the ZipFile.  For example, in a console application,
             System.Console.Out works, and will get a message for each entry added to the
             ZipFile.  If the TextWriter is null, no verbose messages are written.
             </param>
      <param name="readProgress">
             An event handler for Read operations.
             </param>
      <returns>an instance of ZipFile</returns>
    </member>
    <member name="M:Ionic.Zip.ZipFile.Read(System.IO.Stream,System.Text.Encoding)">
      <summary>
             Reads a zip archive from a stream, using the specified encoding.
             </summary>
      <remarks>
        <para>
             This method is useful when when the zip archive content is available from 
             an already-open stream. The stream must be open and readable when calling this
             method.  The stream is left open when the reading is completed. 
             </para>
      </remarks>
      <exception cref="T:Ionic.Zip.ZipException">
             Thrown if zipStream is null.
             In this case, the inner exception is an ArgumentException.
             </exception>
      <param name="zipStream">the stream containing the zip data.</param>
      <param name="encoding">
             The text encoding to use when reading entries that do not have the UTF-8 encoding
             bit set.  Be careful specifying the encoding.  If the value you use here is not the
             same as the Encoding used when the zip archive was created (possibly by a different
             archiver) you will get unexpected results and possibly exceptions.  See the <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding">ProvisionalAlternateEncoding</see>
             property for more information.
             </param>
      <returns>an instance of ZipFile</returns>
    </member>
    <member name="M:Ionic.Zip.ZipFile.Read(System.IO.Stream,System.Text.Encoding,System.EventHandler{Ionic.Zip.ReadProgressEventArgs})">
      <summary>
            Reads a zip archive from a stream, using the specified encoding, and
            and the specified ReadProgress event handler.
            </summary>
      <param name="zipStream">the stream containing the zip data.</param>
      <param name="encoding">
            The text encoding to use when reading entries that do not have the UTF-8 encoding
            bit set.  Be careful specifying the encoding.  If the value you use here is not the
            same as the Encoding used when the zip archive was created (possibly by a different
            archiver) you will get unexpected results and possibly exceptions.  See the <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding">ProvisionalAlternateEncoding</see>
            property for more information.
            </param>
      <param name="readProgress">
            An event handler for Read operations.
            </param>
      <returns>an instance of ZipFile</returns>
    </member>
    <member name="M:Ionic.Zip.ZipFile.Read(System.IO.Stream,System.IO.TextWriter,System.Text.Encoding)">
      <summary>
             Reads a zip archive from a stream, using the specified text Encoding and the 
             specified TextWriter for status messages.
             </summary>
      <remarks>
        <para>
             This method is useful when when the zip archive content is available from 
             an already-open stream. The stream must be open and readable when calling this
             method.  The stream is left open when the reading is completed. 
             </para>
      </remarks>
      <exception cref="T:Ionic.Zip.ZipException">
             Thrown if zipStream is null.
             In this case, the inner exception is an ArgumentException.
             </exception>
      <param name="zipStream">the stream containing the zip data.</param>
      <param name="statusMessageWriter">
             The <c>System.IO.TextWriter</c> to which verbose status messages are written during
             operations on the ZipFile.  For example, in a console application,
             System.Console.Out works, and will get a message for each entry added to the
             ZipFile.  If the TextWriter is null, no verbose messages are written.
             </param>
      <param name="encoding">
             The text encoding to use when reading entries that do not have the UTF-8 encoding
             bit set.  Be careful specifying the encoding.  If the value you use here is not the
             same as the Encoding used when the zip archive was created (possibly by a different
             archiver) you will get unexpected results and possibly exceptions.  See the <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding">ProvisionalAlternateEncoding</see>
             property for more information.
             </param>
      <returns>an instance of ZipFile</returns>
    </member>
    <member name="M:Ionic.Zip.ZipFile.Read(System.IO.Stream,System.IO.TextWriter,System.Text.Encoding,System.EventHandler{Ionic.Zip.ReadProgressEventArgs})">
      <summary>
             Reads a zip archive from a stream, using the specified text Encoding, the 
             specified TextWriter for status messages, 
             and the specified ReadProgress event handler.
             </summary>
      <param name="zipStream">the stream containing the zip data.</param>
      <param name="statusMessageWriter">
             The <c>System.IO.TextWriter</c> to which verbose status messages are written during
             operations on the ZipFile.  For example, in a console application,
             System.Console.Out works, and will get a message for each entry added to the
             ZipFile.  If the TextWriter is null, no verbose messages are written.
             </param>
      <param name="encoding">
             The text encoding to use when reading entries that do not have the UTF-8 encoding
             bit set.  Be careful specifying the encoding.  If the value you use here is not the
             same as the Encoding used when the zip archive was created (possibly by a different
             archiver) you will get unexpected results and possibly exceptions.  See the <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding">ProvisionalAlternateEncoding</see>
             property for more information.
             </param>
      <param name="readProgress">
             An event handler for Read operations.
             </param>
      <returns>an instance of ZipFile</returns>
    </member>
    <member name="M:Ionic.Zip.ZipFile.Read(System.Byte[])">
      <summary>
             Reads a zip archive from a byte array.
             </summary>
      <remarks>
             This is useful when the data for the zipfile is contained in a byte array, 
             for example, downloaded from an FTP server without being saved to a
             filesystem. 
             </remarks>
      <param name="buffer">
             The byte array containing the zip data.  
             (I don't know why, but sometimes the compiled helpfile (.chm) indicates a 2d 
             array when it is just one-dimensional.  This is a one-dimensional array.)
             </param>
      <returns>an instance of ZipFile. The name on the ZipFile will be null (nothing in VB). </returns>
      <seealso cref="M:Ionic.Zip.ZipFile.Read(System.IO.Stream)" />
    </member>
    <member name="M:Ionic.Zip.ZipFile.Read(System.Byte[],System.IO.TextWriter)">
      <summary>
             Reads a zip archive from a byte array, using the given StatusMessageWriter.
             </summary>
      <remarks>
        <para>
             This method is useful when the data for the zipfile is contained in a byte array, for
             example when retrieving the data from a database or other non-filesystem store.  
             The default Text Encoding (IBM437) is used to read the zipfile data.
             </para>
      </remarks>
      <param name="buffer">the byte array containing the zip data.</param>
      <param name="statusMessageWriter">
             The <c>System.IO.TextWriter</c> to which verbose status messages are written during
             operations on the ZipFile.  For example, in a console application,
             System.Console.Out works, and will get a message for each entry added to the
             ZipFile.  If the TextWriter is null, no verbose messages are written.
             </param>
      <returns>an instance of ZipFile. The name is set to null.</returns>
    </member>
    <member name="M:Ionic.Zip.ZipFile.Read(System.Byte[],System.IO.TextWriter,System.Text.Encoding)">
      <summary>
             Reads a zip archive from a byte array, using the given StatusMessageWriter and text Encoding.
             </summary>
      <remarks>
        <para>
             This method is useful when the data for the zipfile is contained in a byte array, for
             example when retrieving the data from a database or other non-filesystem store.  
             </para>
      </remarks>
      <param name="buffer">the byte array containing the zip data.</param>
      <param name="statusMessageWriter">
             The <c>System.IO.TextWriter</c> to which verbose status messages are written during
             operations on the ZipFile.  For example, in a console application,
             System.Console.Out works, and will get a message for each entry added to the
             ZipFile.  If the TextWriter is null, no verbose messages are written.
             </param>
      <param name="encoding">
             The text encoding to use when reading entries that do not have the UTF-8 encoding
             bit set.  Be careful specifying the encoding.  If the value you use here is not the
             same as the Encoding used when the zip archive was created (possibly by a different
             archiver) you will get unexpected results and possibly exceptions.  See the <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" />
             property for more information.
             </param>
      <returns>an instance of ZipFile. The name is set to null.</returns>
    </member>
    <member name="M:Ionic.Zip.ZipFile.ExtractAll(System.String)">
      <summary>
             Extracts all of the items in the zip archive, to the specified path in the filesystem.
             The path can be relative or fully-qualified. 
             </summary>
      <remarks>
        <para>
             This method will extract all entries in the ZipFile to the specified path. 
             </para>
        <para>
             If an extraction of a file from the zip archive would overwrite an existing file in
             the filesystem, the action taken is dictated by the ExtractExistingFile property,
             which overrides any setting you may have made on individual ZipEntry instances.  By
             default, if you have not set that property on the ZipFile instance, the entry will not
             be extracted, the existing file will not be overwritten and an exception will be
             thrown. To change this, set the property, or use the <see cref="M:Ionic.Zip.ZipFile.ExtractAll(System.String,Ionic.Zip.ExtractExistingFileAction)" /> overload
             that allows you to specify an ExtractExistingFileAction parameter.
             </para>
        <para>
             The action to take when an extract would overwrite an existing file applies to all
             entries.  If you want to set this on a per-entry basis, then you must use one of the
             <see cef="ZipEntry.Extract" /> methods.
             </para>
        <para>
             This method will send verbose output messages to the StatusMessageTextWriter, if it 
             is set on the ZipFile instance. 
             </para>
        <para>
             You may wish to take advantage of the <c>ExtractProgress</c> event.
             </para>
      </remarks>
      <example>
             This example extracts all the entries in a zip archive file, to the specified target
             directory.  The extraction will overwrite any existing files silently.
             <code>
             String TargetDirectory= "unpack";
             using(ZipFile zip= ZipFile.Read(ZipFileToExtract))
             {
                 zip.ExtractExistingFile= ExtractExistingFileAction.OverwriteSilently;
                 zip.ExtractAll(TargetDirectory);
             }
             </code><code lang="VB">
             Dim TargetDirectory As String = "unpack"
             Using zip As ZipFile = ZipFile.Read(ZipFileToExtract)
                 zip.ExtractExistingFile= ExtractExistingFileAction.OverwriteSilently
                 zip.ExtractAll(TargetDirectory)
             End Using
             </code></example>
      <seealso cref="E:Ionic.Zip.ZipFile.ExtractProgress" />
      <seealso cref="P:Ionic.Zip.ZipFile.ExtractExistingFile" />
      <param name="path">
             The path to which the contents of the zipfile will be extracted.
             The path can be relative or fully-qualified. 
             </param>
    </member>
    <member name="M:Ionic.Zip.ZipFile.ExtractAll(System.String,System.Boolean)">
      <summary>
             Extracts all of the items in the zip archive, to the specified path in the filesystem,  
             optionally overwriting any existing files. The path can be relative or fully-qualified. 
             </summary>
      <remarks>
             This method will send verbose output messages to the StatusMessageTextWriter, if it 
             is set on the ZipFile instance. 
             </remarks>
      <example>
             This example extracts all the entries in a zip archive file, 
             to the specified target directory.  It overwrites any existing files.
             <code>
             String TargetDirectory= "unpack";
             using(ZipFile zip= ZipFile.Read(ZipFileToExtract))
             {
                 zip.ExtractAll(TargetDirectory, true);
             }
             </code><code lang="VB">
             Dim TargetDirectory As String = "unpack"
             Using zip As ZipFile = ZipFile.Read(ZipFileToExtract)
                 zip.ExtractAll(TargetDirectory, True)
             End Using
             </code></example>
      <param name="path">the path to which the contents of the zipfile are extracted.</param>
      <param name="wantOverwrite">true to overwrite any existing files on extraction</param>
      <seealso cref="M:Ionic.Zip.ZipFile.ExtractAll(System.String,Ionic.Zip.ExtractExistingFileAction)" />
    </member>
    <member name="M:Ionic.Zip.ZipFile.ExtractAll(System.String,Ionic.Zip.ExtractExistingFileAction)">
      <summary>
             Extracts all of the items in the zip archive, to the specified path in the filesystem,  
             using the specified behavior when extraction would overwrite an existing file.
             </summary>
      <remarks>
        <para>
             This method will extract all entries in the ZipFile to the specified path. 
             For an extraction that would overwrite an existing file, the behavior 
             is dictated by the extractExistingFile parameter, which overrides 
             any setting you may have made on individual ZipEntry instances. 
             </para>
        <para>
             The action to take when an extract would overwrite an existing file applies to all
             entries.  If you want to set this on a per-entry basis, then you must use one of the
             <see cef="ZipEntry.Extract" /> methods.
             </para>
        <para>
             Calling this method is equivalent to setting the <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile" />
             property and then calling <see cref="M:Ionic.Zip.ZipFile.ExtractAll(System.String)" />.
             </para>
        <para>
             This method will send verbose output messages to the StatusMessageTextWriter, if it 
             is set on the ZipFile instance. 
             </para>
      </remarks>
      <example>
             This example extracts all the entries in a zip archive file, 
             to the specified target directory.  It does not overwrite any existing files.
             <code>
             String TargetDirectory= "c:\\unpack";
             using(ZipFile zip= ZipFile.Read(ZipFileToExtract))
             {
               zip.ExtractAll(TargetDirectory, ExtractExistingFileAction.DontOverwrite);
             }
             </code><code lang="VB">
             Dim TargetDirectory As String = "c:\unpack"
             Using zip As ZipFile = ZipFile.Read(ZipFileToExtract)
                 zip.ExtractAll(TargetDirectory, ExtractExistingFileAction.DontOverwrite)
             End Using
             </code></example>
      <param name="path">
             The path to which the contents of the zipfile will be extracted.
             The path can be relative or fully-qualified. 
             </param>
      <param name="extractExistingFile">
             The action to take if extraction would overwrite an existing file.
             </param>
      <seealso cref="M:Ionic.Zip.ZipFile.ExtractSelectedEntries(System.String,Ionic.Zip.ExtractExistingFileAction)" />
    </member>
    <member name="M:Ionic.Zip.ZipFile.Extract(System.String)">
      <summary>
             Extract a single item from the archive to the current working directory.  
             </summary>
      <remarks>
        <para>
             A file corresponding to the entry named by the fileName parameter, including any
             relative qualifying path for the entry, is created at the specified directory.
             </para>
        <para>
             An entry that requires a password for extraction is extracted using the <see cref="P:Ionic.Zip.ZipFile.Password" /> that is specified on the ZipFile instance, which overrides
             any Password you may have set directly on the ZipEntry instance. If you have not set
             the <see cref="P:Ionic.Zip.ZipFile.Password" /> property, or if you have set it to null, and the
             entry requires a password for extraction, an Exception will be thrown.  An exception
             will also be thrown if the entry requires a password for extraction, and the password
             specified on the ZipFile instance does not match that required for the ZipEntry.
             </para>
        <para>
             For an extraction that would overwrite an existing file, the action taken is dictated
             by the <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile" /> property, which overrides any
             setting you may have made on the individual ZipEntry instance, unless it is not the
             default "Throw" action.  If it is the default "Throw", then the action taken is that
             specified in the <see cref="P:Ionic.Zip.ZipEntry.ExtractExistingFile" /> property on the ZipEntry
             instance.
             </para>
        <para>
             The file, including any relative qualifying path, is extracted to the current working
             directory.
             </para>
        <para>
             The ExtractProgress event is invoked before and after extraction, if it has been set. 
             </para>
      </remarks>
      <param name="fileName">
             The file to extract. It must be the exact filename, including the path
             contained in the archive, if any. The filename match is not case-sensitive by
             default; you can use the <c>CaseSensitiveRetrieval</c> property to change
             this behavior.
             </param>
    </member>
    <member name="M:Ionic.Zip.ZipFile.Extract(System.String,System.String)">
      <summary>
             Extract a single item from the archive to the specified directory.
             </summary>
      <remarks>
        <para>
             A file corresponding to the entry named by the fileName parameter, including any
             relative qualifying path for the entry, is created at the specified directory.
             </para>
        <para>
             An entry that requires a password for extraction is extracted using the <see cref="P:Ionic.Zip.ZipFile.Password" /> that is specified on the ZipFile instance, which overrides
             any Password you may have set directly on the ZipEntry instance. If you have not set
             the <see cref="P:Ionic.Zip.ZipFile.Password" /> property, or if you have set it to null, and the
             entry requires a password for extraction, an Exception will be thrown.  An exception
             will also be thrown if the entry requires a password for extraction, and the password
             specified on the ZipFile instance does not match that required for the ZipEntry.
             </para>
        <para>
             For an extraction that would overwrite an existing file, the action taken is dictated
             by the <see cref="P:Ionic.Zip.ZipFile.ExtractExistingFile" /> property, which overrides any
             setting you may have made on the individual ZipEntry instance, unless it is not the
             default "Throw" action.  If it is the default "Throw", then the action taken is that
             specified in the <see cref="P:Ionic.Zip.ZipEntry.ExtractExistingFile" /> property on the ZipEntry
             instance.
             </para>
        <para>
             The ExtractProgress event is invoked before and after extraction, if it has been set. 
             </para>
      </remarks>
      <param name="entryName">
             the name of the entry to extract. It must be the exact filename, including the path
             specified on the entry in the archive, if any. The match is not case-sensitive by
             default; you can use the <c>CaseSensitiveRetrieval</c> property to change
             this behavior.
             </param>
      <param name="directoryName">the directory into which to extract. It will be created 
             if it does not exist.</param>
    </member>
    <member name="M:Ionic.Zip.ZipFile.Extract(System.String,System.Boolean)">
      <summary>
             Extract a single item from the archive to the current working directory, potentially
             overwriting any existing file in the filesystem by the same name.
             </summary>
      <remarks>
        <para>
             A file corresponding to the entry named by the fileName parameter, including any
             relative qualifying path for the entry, is created at the current working directory.
             </para>
        <para>
             An entry that requires a password for extraction is extracted using the <see cref="P:Ionic.Zip.ZipFile.Password" /> that is specified on the ZipFile instance, which overrides
             any Password you may have set directly on the ZipEntry instance. If you have not set
             the <see cref="P:Ionic.Zip.ZipFile.Password" /> property, or if you have set it to null, and the
             entry requires a password for extraction, an Exception will be thrown.  An exception
             will also be thrown if the entry requires a password for extraction, and the password
             specified on the ZipFile instance does not match that required for the ZipEntry.
             </para>
        <para>
             The ExtractProgress event is invoked before and after extraction, if it has been set. 
             </para>
      </remarks>
      <seealso cref="P:Ionic.Zip.ZipFile.CaseSensitiveRetrieval" />
      <seealso cref="M:Ionic.Zip.ZipFile.Extract(System.String,Ionic.Zip.ExtractExistingFileAction)" />
      <param name="entryName">
             The name of the entry to extract. It must be the exact name, including the path
             specified on the entry in the archive, if any. The match is not case-sensitive by
             default; you can use the <c>CaseSensitiveRetrieval</c> property to change this
             behavior.  The path, if any, can use forward-slashes or backward slashes.
             </param>
      <param name="wantOverwrite">
             True if the caller wants to overwrite any existing files by the given name.
             </param>
    </member>
    <member name="M:Ionic.Zip.ZipFile.Extract(System.String,Ionic.Zip.ExtractExistingFileAction)">
      <summary>
             Extract a single item from the archive to the current working directory, potentially
             overwriting any existing file in the filesystem by the same name.
             </summary>
      <remarks>
        <para>
             Using this method, the entry is extracted using the Password that is specified on
             the ZipFile instance. If you have not set the Password property, then the password
             is null, and the entry is extracted with no password.  The file, including any
             relative qualifying path, is created at the current working directory.
             </para>
        <para>
             For an extraction that would overwrite an existing file, the action taken is dictated
             by the extractExistingFile parameter, which overrides any setting you may have made on
             the individual ZipEntry instance.  To avoid this, use one of the
             <c>ZipEntry.Extract</c> methods.
             </para>
        <para>
             The ExtractProgress event is invoked before and after extraction, if it has been set. 
             </para>
      </remarks>
      <seealso cref="P:Ionic.Zip.ZipFile.CaseSensitiveRetrieval" />
      <param name="entryName">
             The name of the entry to extract. It must be the exact name, including the path
             specified on the entry in the archive, if any. The match is not case-sensitive by
             default; you can use the <c>CaseSensitiveRetrieval</c> property to change this
             behavior.  The path, if any, can use forward-slashes or backward slashes.
             </param>
      <param name="extractExistingFile">
             The action to take if extraction would overwrite an existing file.
             </param>
    </member>
    <member name="M:Ionic.Zip.ZipFile.Extract(System.String,System.String,System.Boolean)">
      <summary>
             Extract a single item from the archive, into the specified directory, potentially overwriting  
             any existing file in the filesystem by the same name.   
             </summary>
      <remarks>
        <para>
             A file corresponding to the entry named by the fileName parameter, including any
             relative qualifying path for the entry, is created at the specified directory.
             </para>
        <para>
             An entry that requires a password for extraction is extracted using the <see cref="P:Ionic.Zip.ZipFile.Password" /> that is specified on the ZipFile instance, which overrides
             any Password you may have set directly on the ZipEntry instance. If you have not set
             the <see cref="P:Ionic.Zip.ZipFile.Password" /> property, or if you have set it to null, and the
             entry requires a password for extraction, an Exception will be thrown.  An exception
             will also be thrown if the entry requires a password for extraction, and the password
             specified on the ZipFile instance does not match that required for the ZipEntry.
             </para>
        <para>
             The ExtractProgress event is invoked before and after extraction, if it has been set. 
             </para>
      </remarks>
      <seealso cref="M:Ionic.Zip.ZipFile.Extract(System.String,System.String,Ionic.Zip.ExtractExistingFileAction)" />
      <param name="entryName">
             The name of the entry to extract. It must be the exact name, including the path
             specified on the entry in the archive, if any. The match is not case-sensitive by
             default; you can use the <c>CaseSensitiveRetrieval</c> property to change this
             behavior. The path, if any, can use forward-slashes or backward slashes.
             </param>
      <param name="directoryName">
             The directory into which to extract. It will be created 
             if it does not exist.
             </param>
      <param name="wantOverwrite">
             True if the caller wants to overwrite any existing files 
             by the given name. 
             </param>
    </member>
    <member name="M:Ionic.Zip.ZipFile.Extract(System.String,System.String,Ionic.Zip.ExtractExistingFileAction)">
      <summary>
             Extract a single item from the archive, into the specified directory, 
             using the specified behavior when extraction would overwrite an existing file.
             </summary>
      <remarks>
        <para>
             A file corresponding to the entry named by the fileName parameter, including any
             relative qualifying path for the entry, is created at the specified directory.
             </para>
        <para>
             An entry that requires a password for extraction is extracted using the <see cref="P:Ionic.Zip.ZipFile.Password" /> that is specified on the ZipFile instance, which overrides
             any Password you may have set directly on the ZipEntry instance. If you have not set
             the <see cref="P:Ionic.Zip.ZipFile.Password" /> property, or if you have set it to null, and the
             entry requires a password for extraction, an Exception will be thrown.  An exception
             will also be thrown if the entry requires a password for extraction, and the password
             specified on the ZipFile instance does not match that required for the ZipEntry.
             </para>
        <para>
             For an extraction that would overwrite an existing file, the action taken is dictated
             by the extractExistingFile parameter, which overrides any setting you may have made on
             the individual ZipEntry instance.  To avoid this, use one of the
             <c>ZipEntry.Extract</c> methods.
             </para>
        <para>
             The ExtractProgress event is invoked before and after extraction, if it has been set. 
             </para>
      </remarks>
      <param name="entryName">
             The name of the entry to extract. It must be the exact name, including the path
             specified on the entry in the archive, if any. The match is not case-sensitive by
             default; you can use the <c>CaseSensitiveRetrieval</c> property to change this
             behavior. The path, if any, can use forward-slashes or backward slashes.
             </param>
      <param name="directoryName">
             The directory into which to extract. It will be created if it does not exist.
             </param>
      <param name="extractExistingFile">
             The action to take if extraction would overwrite an existing file.
             </param>
    </member>
    <member name="M:Ionic.Zip.ZipFile.Extract(System.String,System.IO.Stream)">
      <summary>
             Extract a single specified file from the archive, to the given stream.   
             </summary>
      <remarks>
        <para>
             The entry identified by the entryName parameter is extracted to the given stream.
             </para>
        <para>
             An entry that requires a password for extraction is extracted using the <see cref="P:Ionic.Zip.ZipFile.Password" /> that is specified on the ZipFile instance, which overrides
             any Password you may have set directly on the ZipEntry instance. If you have not set
             the <see cref="P:Ionic.Zip.ZipFile.Password" /> property, or if you have set it to null, and the
             entry requires a password for extraction, an Exception will be thrown.  An exception
             will also be thrown if the entry requires a password for extraction, and the password
             specified on the ZipFile instance does not match that required for the ZipEntry.
             </para>
        <para>
             The ExtractProgress event is invoked before and after extraction, if it has been set. 
             </para>
      </remarks>
      <exception cref="T:Ionic.Zip.ZipException">
             Thrown if the outputStream is not writable, or if the filename is 
             null or empty. The inner exception is an ArgumentException in each case.
             </exception>
      <param name="entryName">
             the name of the entry to extract, including the path used in the archive, if
             any.  The match is not case-sensitive by default; you can use the
             <c>CaseSensitiveRetrieval</c> property to change this behavior. The application can
             specify pathnames using forward-slashes or backward slashes.
             </param>
      <param name="outputStream">
             the stream to which the extacted, decompressed file data is written. 
             The stream must be writable.
             </param>
    </member>
    <member name="M:Ionic.Zip.ZipFile.RemoveEntry(Ionic.Zip.ZipEntry)">
      <summary>
             Removes the given ZipEntry from the zip archive.  
             </summary>
      <remarks>
        <para>
             After calling <c>RemoveEntry</c>, the application must call <c>Save</c> to make the 
             changes permanent.  
             </para>
      </remarks>
      <exception cref="T:System.ArgumentException">
             Thrown if the specified ZipEntry does not exist in the ZipFile.
             </exception>
      <example>
             In this example, all entries in the zip archive dating from before December 31st, 2007, are
             removed from the archive.  This is actually much easier if you use the RemoveSelectedEntries method.
             But I needed an example for RemoveEntry, so here it is. 
             <code>
             String ZipFileToRead = "ArchiveToModify.zip";
             System.DateTime Threshold = new System.DateTime(2007,12,31);
             using (ZipFile zip = ZipFile.Read(ZipFileToRead))
             {
               var EntriesToRemove = new System.Collections.Generic.List&lt;ZipEntry&gt;();
               foreach (ZipEntry e in zip)
               {
                 if (e.LastModified &lt; Threshold)
                 {
                   // We cannot remove the entry from the list, within the context of 
                   // an enumeration of said list.
                   // So we add the doomed entry to a list to be removed later.
                   EntriesToRemove.Add(e);
                 }
               }
               
               // actually remove the doomed entries. 
               foreach (ZipEntry zombie in EntriesToRemove)
                 zip.RemoveEntry(zombie);
               
               zip.Comment= String.Format("This zip archive was updated at {0}.", 
                                          System.DateTime.Now.ToString("G"));
            
               // save with a different name
               zip.Save("Archive-Updated.zip");
             }
             </code><code lang="VB">
               Dim ZipFileToRead As String = "ArchiveToModify.zip"
               Dim Threshold As New DateTime(2007, 12, 31)
               Using zip As ZipFile = ZipFile.Read(ZipFileToRead)
                   Dim EntriesToRemove As New System.Collections.Generic.List(Of ZipEntry)
                   Dim e As ZipEntry
                   For Each e In zip
                       If (e.LastModified &lt; Threshold) Then
                           ' We cannot remove the entry from the list, within the context of 
                           ' an enumeration of said list.
                           ' So we add the doomed entry to a list to be removed later.
                           EntriesToRemove.Add(e)
                       End If
                   Next
               
                   ' actually remove the doomed entries. 
                   Dim zombie As ZipEntry
                   For Each zombie In EntriesToRemove
                       zip.RemoveEntry(zombie)
                   Next
                   zip.Comment = String.Format("This zip archive was updated at {0}.", DateTime.Now.ToString("G"))
                   'save as a different name
                   zip.Save("Archive-Updated.zip")
               End Using
             </code></example>
      <param name="entry">
             The ZipEntry to remove from the zip. 
             </param>
      <seealso cref="M:Ionic.Zip.ZipFile.RemoveSelectedEntries(System.String)" />
    </member>
    <member name="M:Ionic.Zip.ZipFile.RemoveEntry(System.String)">
      <summary>
             Removes the ZipEntry with the given filename from the zip archive.  
             </summary>
      <remarks>
        <para>
             After calling <c>RemoveEntry</c>, the application must call <c>Save</c> to make the changes permanent.  
             </para>
      </remarks>
      <exception cref="T:System.InvalidOperationException">
             Thrown if the ZipFile is not updatable. 
             </exception>
      <exception cref="T:System.ArgumentException">
             Thrown if a ZipEntry with the specified filename does not exist in the ZipFile.
             </exception>
      <example>
             This example shows one way to remove an entry with a given filename from an 
             existing zip archive.
             <code>
             String ZipFileToRead= "PackedDocuments.zip";
             string Candidate = "DatedMaterial.xps";
             using (ZipFile zip = new ZipFile(ZipFileToRead))
             {
               if (zip.EntryFilenames.Contains(Candidate))
               {
                 zip.RemoveEntry(Candidate);
                 zip.Comment= String.Format("The file '{0}' has been removed from this archive.", 
                                            Candidate);
                 zip.Save();
               }
             }
             </code><code lang="VB">
               Dim ZipFileToRead As String = "PackedDocuments.zip"
               Dim Candidate As String = "DatedMaterial.xps"
               Using zip As ZipFile = New ZipFile(ZipFileToRead)
                   If zip.EntryFilenames.Contains(Candidate) Then
                       zip.RemoveEntry(Candidate)
                       zip.Comment = String.Format("The file '{0}' has been removed from this archive.", Candidate)
                       zip.Save
                   End If
               End Using
             </code></example>
      <param name="fileName">
             The name of the file, including any directory path, to remove from the zip. 
             The filename match is not case-sensitive by default; you can use the
             <c>CaseSensitiveRetrieval</c> property to change this behavior. The
             pathname can use forward-slashes or backward slashes.
             </param>
    </member>
    <member name="M:Ionic.Zip.ZipFile.Finalize">
      <summary>
            This is the class Destructor, which gets called implicitly when the instance is destroyed.  
            Because the ZipFile type implements IDisposable, this method calls Dispose(false).  
            </summary>
    </member>
    <member name="M:Ionic.Zip.ZipFile.Dispose">
      <summary>
             Handles closing of the read and write streams associated
             to the ZipFile, if necessary.  
             </summary>
      <remarks>
             The Dispose() method is generally 
             employed implicitly, via a using() {} statement. (Using...End Using in VB)
             Always use a using statement, or always insure that you are calling Dispose() 
             explicitly.
             </remarks>
      <example>
             This example extracts an entry selected by name, from the  Zip file to the Console.
             <code>
             using (ZipFile zip = ZipFile.Read(zipfile))
             {
               foreach (ZipEntry e in zip)
               {
                 if (WantThisEntry(e.FileName)) 
                   zip.Extract(e.FileName, Console.OpenStandardOutput());
               }
             } // Dispose() is called implicitly here.
             </code><code lang="VB">
             Using zip As ZipFile = ZipFile.Read(zipfile)
                 Dim e As ZipEntry
                 For Each e In zip
                   If WantThisEntry(e.FileName) Then
                       zip.Extract(e.FileName, Console.OpenStandardOutput())
                   End If
                 Next
             End Using ' Dispose is implicity called here
             </code></example>
    </member>
    <member name="M:Ionic.Zip.ZipFile.Dispose(System.Boolean)">
      <summary>
            The Dispose() method.  It disposes any managed resources, 
            if the flag is set, then marks the instance disposed.
            This method is typically not called from application code.
            </summary>
      <param name="disposeManagedResources">indicates whether the method should dispose streams or not.</param>
    </member>
    <member name="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String)">
      <summary>
             Adds to the ZipFile a set of files from the disk that conform to the specified criteria.
             </summary>
      <remarks>
        <para>
             This method selects files from the the current working directory matching the specified
             criteria, and adds them to the ZipFile.  The selection does not recurse into
             subdirectories.
             </para>
        <para>
             Specify the criteria in statements of 3 elements: a noun, an operator, and a value.
             Consider the string "name != *.doc" .  The noun is "name".  The operator is "!=",
             implying "Not Equal".  The value is "*.doc".  That criterion, in English, says "all
             files with a name that does not end in the .doc extension."
             </para>
        <para>
             Supported nouns include "name" for the filename; "atime", "mtime", and "ctime" for
             last access time, last modfied time, and created time of the file, respectively;
             "attributes" for the file attributes; and "size" for the file length (uncompressed).
             The "attributes" and "name" nouns both support = and != as operators.  The "size",
             "atime", "mtime", and "ctime" nouns support = and !=, and &gt;, &gt;=, &lt;, &lt;=
             as well.
             </para>
        <para>
             Specify values for the file attributes as a string with one or more of the
             characters H,R,S,A in any order, implying Hidden, ReadOnly, System, and Archive,
             respectively.  To specify a time, use YYYY-MM-DD-HH:mm:ss as the format.  If you
             omit the HH:mm:ss portion, it is assumed to be 00:00:00 (midnight). The value for a
             size criterion is expressed in integer quantities of bytes, kilobytes (use k or kb
             after the number), megabytes (m or mb), or gigabytes (g or gb).  The value for a
             name is a pattern to match against the filename, potentially including wildcards.
             The pattern follows CMD.exe glob rules: * implies one or more of any character,
             while ? implies one character.  If the name pattern contains any slashes, it is
             matched to the entire filename, including the path; otherwise, it is matched
             against only the filename without the path.  This means a pattern of "*\*.*" matches 
             all files one directory level deep, while a pattern of "*.*" matches all files in 
             all directories.  
             </para>
        <para>
             To specify a name pattern that includes spaces, use single quotes around the pattern.
             A pattern of "'* *.*'" will match all files that have spaces in the filename.  The full 
             criteria string for that would be "name = '* *.*'" . 
             </para>
        <para>
             Some examples: a string like "attributes != H" retrieves all entries whose
             attributes do not include the Hidden bit.  A string like "mtime &gt; 2009-01-01"
             retrieves all entries with a last modified time after January 1st, 2009.  For
             example "size &gt; 2gb" retrieves all entries whose uncompressed size is greater
             than 2gb.
             </para>
        <para>
             You can combine criteria with the conjunctions AND or OR. Using a string like "name
             = *.txt AND size &gt;= 100k" for the selectionCriteria retrieves entries whose names
             end in  .txt, and whose uncompressed size is greater than or equal to
             100 kilobytes.
             </para>
        <para>
             For more complex combinations of criteria, you can use parenthesis to group clauses
             in the boolean logic.  Without parenthesis, the precedence of the criterion atoms is
             determined by order of appearance.  Unlike the C# language, the AND conjunction does
             not take precendence over the logical OR.  This is important only in strings that
             contain 3 or more criterion atoms.  In other words, "name = *.txt and size &gt; 1000
             or attributes = H" implies "((name = *.txt AND size &gt; 1000) OR attributes = H)"
             while "attributes = H OR name = *.txt and size &gt; 1000" evaluates to "((attributes
             = H OR name = *.txt) AND size &gt; 1000)".  When in doubt, use parenthesis.
             </para>
        <para>
             Using time properties requires some extra care. If you want to retrieve all entries
             that were last updated on 2009 February 14, specify a time range like so:"mtime
             &gt;= 2009-02-14 AND mtime &lt; 2009-02-15".  Read this to say: all files updated
             after 12:00am on February 14th, until 12:00am on February 15th.  You can use the
             same bracketing approach to specify any time period - a year, a month, a week, and
             so on.
             </para>
        <para>
             The syntax allows one special case: if you provide a string with no spaces, it is
             treated as a pattern to match for the filename.  Therefore a string like "*.xls"
             will be equivalent to specifying "name = *.xls".
             </para>
        <para>
             There is no logic in this method that insures that the file inclusion criteria are
             internally consistent.  For example, it's possible to specify criteria that says
             the file must have a size of less than 100 bytes, as well as a size that is
             greater than 1000 bytes. Obviously no file will ever satisfy such criteria, but
             this method does not detect such logical inconsistencies. The caller is
             responsible for insuring the criteria are sensible.
             </para>
      </remarks>
      <example>
             This example zips up all *.csv files in the current working directory. 
             <code>
             using (ZipFile zip = new ZipFile())
             {
                 // To just match on filename wildcards,
                 // use the shorthand form of the selectionCriteria string.
                 zip.AddSelectedFiles("*.csv");
                 zip.Save(PathToZipArchive);
             }
             </code><code lang="VB">
             Using zip As ZipFile = New ZipFile()
                 zip.AddSelectedFiles("*.csv")
                 zip.Save(PathToZipArchive)
             End Using
             </code></example>
      <param name="selectionCriteria">The criteria for file selection</param>
    </member>
    <member name="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String,System.Boolean)">
      <summary>
             Adds to the ZipFile a set of files from the disk that conform to the specified criteria.
             </summary>
      <remarks>
        <para>
             This method selects files from the the current working directory matching the specified
             criteria, and adds them to the ZipFile.  If <c>recurseDirectories</c> is true, files are also 
             selected from subdirectories, and the directory structure in the filesystem is reproduced 
             in the zip archive, rooted at the directory specified by <c>directoryOnDisk</c>.
             </para>
        <para>
             For details on the syntax for the selectionCriteria parameter, see <see cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String)" />.
             </para>
      </remarks>
      <example>
             This example zips up all *.xml files in the current working directory, or any 
             subdirectory, that are larger than 1mb.
             <code>
             using (ZipFile zip = new ZipFile())
             {
                 // Use a compound expression in the selectionCriteria string.
                 zip.AddSelectedFiles("name = *.xml  and  size &gt; 1024kb", true);
                 zip.Save(PathToZipArchive);
             }
             </code><code lang="VB">
             Using zip As ZipFile = New ZipFile()
                 ' Use a compound expression in the selectionCriteria string.
                 zip.AddSelectedFiles("name = *.xml  and  size &gt; 1024kb", true)
                 zip.Save(PathToZipArchive)
             End Using
             </code></example>
      <param name="selectionCriteria">The criteria for file selection</param>
      <param name="recurseDirectories">
             If true, the file selection will recurse into subdirectories.
             </param>
    </member>
    <member name="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String,System.String)">
      <summary>
            Adds to the ZipFile a set of files from the disk that conform to the specified criteria.
            </summary>
      <remarks>
            This method selects files from the the specified disk directory matching the specified
            criteria, and adds them to the ZipFile.  The search does not recurse into
            subdirectores.  For details on the syntax for the selectionCriteria parameter, see <see cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String)" />.
            </remarks>
      <example>
            This example zips up all *.xml files larger than 1mb in the directory given by "d:\rawdata".
            <code>
            using (ZipFile zip = new ZipFile())
            {
                // Use a compound expression in the selectionCriteria string.
                zip.AddSelectedFiles("name = *.xml  and  size &gt; 1024kb", "d:\\rawdata");
                zip.Save(PathToZipArchive);
            }
            </code><code lang="VB">
            Using zip As ZipFile = New ZipFile()
                ' Use a compound expression in the selectionCriteria string.
                zip.AddSelectedFiles("name = *.xml  and  size &gt; 1024kb", "d:\rawdata)
                zip.Save(PathToZipArchive)
            End Using
            </code></example>
      <param name="selectionCriteria">The criteria for file selection</param>
      <param name="directoryOnDisk">
            The name of the directory on the disk from which to select files.
            </param>
    </member>
    <member name="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String,System.String,System.Boolean)">
      <summary>
             Adds to the ZipFile a set of files from the disk that conform to the specified criteria.
             </summary>
      <remarks>
             This method selects files from the the specified disk directory matching the specified
             selection criteria, and adds them to the ZipFile.  If <c>recurseDirectories</c> is true,
             files are also selected from subdirectories, and the directory structure in the
             filesystem is reproduced in the zip archive, rooted at the directory specified by
             <c>directoryOnDisk</c>. For details on the syntax for the selectionCriteria parameter,
             see <see cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String)" />.
             </remarks>
      <example>
             This example zips up all *.csv files in the "files" directory, or any subdirectory, that
             have been saved since 2009 February 14th.
             <code>
             using (ZipFile zip = new ZipFile())
             {
                 // Use a compound expression in the selectionCriteria string.
                 zip.AddSelectedFiles("name = *.csv  and  mtime &gt; 2009-02-14", "files", true);
                 zip.Save(PathToZipArchive);
             }
             </code><code lang="VB">
             Using zip As ZipFile = New ZipFile()
                 ' Use a compound expression in the selectionCriteria string.
                 zip.AddSelectedFiles("name = *.csv  and  mtime &gt; 2009-02-14", "files", true)
                 zip.Save(PathToZipArchive)
             End Using
             </code></example>
      <param name="selectionCriteria">The criteria for file selection</param>
      <param name="directoryOnDisk">
             The name of the directory on the disk from which to select files.
             </param>
      <param name="recurseDirectories">
             If true, the file selection will recurse into subdirectories.
             </param>
    </member>
    <member name="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String,System.String,System.String)">
      <summary>
             Adds to the ZipFile a selection of files from the disk that conform to the
             specified criteria.
             </summary>
      <remarks>
             This method selects files from the specified disk directory matching the specified
             selection criteria, and adds those files to the ZipFile, using the specified directory
             path in the archive.  The search does not recurse into subdirectories.  For details on
             the syntax for the selectionCriteria parameter, see <see cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String)" />.
             </remarks>
      <example>
             This example zips up all *.psd files in the "photos" directory that have been saved
             since 2009 February 14th, and puts them all in a zip file, using the directory name of
             "content" in the zip archive itself. When the zip archive is unzipped, the folder
             containing the .psd files will be named "content".
             <code>
             using (ZipFile zip = new ZipFile())
             {
                 // Use a compound expression in the selectionCriteria string.
                 zip.AddSelectedFiles("name = *.psd  and  mtime &gt; 2009-02-14", "photos", "content");
                 zip.Save(PathToZipArchive);
             }
             </code><code lang="VB">
             Using zip As ZipFile = New ZipFile
                 zip.AddSelectedFiles("name = *.psd  and  mtime &gt; 2009-02-14", "photos", "content")
                 zip.Save(PathToZipArchive)
             End Using
             </code></example>
      <param name="selectionCriteria">The criteria for selection of files to Add</param>
      <param name="directoryOnDisk">
             The name of the directory on the disk from which to select files.
             </param>
      <param name="directoryPathInArchive">
             Specifies a directory path to use to override any path in the FileName.  This path may,
             or may not, correspond to a real directory in the current filesystem.  If the files
             within the zip are later extracted, this is the path used for the extracted file.
             Passing null (nothing in VB) will use the path on the FileName, if any.  Passing the
             empty string ("") will insert the item at the root path within the archive.
             </param>
    </member>
    <member name="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String,System.String,System.String,System.Boolean)">
      <summary>
             Adds to the ZipFile a selection of files from the disk that conform to the specified criteria.
             </summary>
      <remarks>
             This method selects files from the specified disk directory that match the specified
             selection criteria, and adds those files to the ZipFile, using the specified directory
             path in the archive. If <c>recurseDirectories</c> is true, files are also selected from
             subdirectories, and the directory structure in the filesystem is reproduced in the zip
             archive, rooted at the directory specified by <c>directoryOnDisk</c>.  For details on the
             syntax for the selectionCriteria parameter, see <see cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String)" />.
             </remarks>
      <example>
             This example zips up all files that are NOT *.pst files, in the current working 
             directory and any subdirectories.
             <code>
             using (ZipFile zip = new ZipFile())
             {
                 zip.AddSelectedFiles("name != *.pst", SourceDirectory, "backup", true);
                 zip.Save(PathToZipArchive);
             }
             </code><code lang="VB">
             Using zip As ZipFile = New ZipFile
                 zip.AddSelectedFiles("name != *.pst", SourceDirectory, "backup", true)
                 zip.Save(PathToZipArchive)
             End Using
             </code></example>
      <param name="selectionCriteria">The criteria for selection of files to Add</param>
      <param name="directoryOnDisk">
             The name of the directory on the disk from which to select files.
             </param>
      <param name="directoryPathInArchive">
             Specifies a directory path to use to override any path in the FileName.  This path may,
             or may not, correspond to a real directory in the current filesystem.  If the files
             within the zip are later extracted, this is the path used for the extracted file.
             Passing null (nothing in VB) will use the path on the FileName, if any.  Passing the
             empty string ("") will insert the item at the root path within the archive.
             </param>
      <param name="recurseDirectories">
             If true, the method also scans subdirectories for files matching the criteria.
             </param>
    </member>
    <member name="M:Ionic.Zip.ZipFile.SelectEntries(System.String)">
      <summary>
             Retrieve entries from the zipfile by specified criteria.
             </summary>
      <remarks>
        <para>
             This method allows callers to retrieve the collection of entries from the zipfile
             that fit the specified criteria.  The criteria are described in a string format, and
             can include patterns for the filename; constraints on the size of the entry;
             constraints on the last modified, created, or last accessed time for the file
             described by the entry; or the attributes of the entry.
             </para>
        <para>
             For details on the syntax for the selectionCriteria parameter, see <see cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String)" />.
             </para>
        <para>
             This method is intended for use with a ZipFile that has been read from storage.
             When creating a new ZipFile, this method will work only after the ZipArchive has
             been Saved to the disk (the ZipFile class subsequently and implicitly reads the Zip
             archive from storage.)  Calling SelectEntries on a ZipFile that has not yet been
             saved will deliver undefined results.
             </para>
      </remarks>
      <exception cref="T:System.Exception">
             Thrown if selectionCriteria has an invalid syntax.
             </exception>
      <example>
             This example selects all the PhotoShop files from within an archive, and extracts them
             to the current working directory.
             <code>
             using (ZipFile zip1 = ZipFile.Read(ZipFileName))
             {
                 var PhotoShopFiles = zip1.SelectEntries("*.psd");
                 foreach (ZipEntry psd in PhotoShopFiles)
                 {
                     psd.Extract();
                 }
             }
             </code><code lang="VB">
             Using zip1 As ZipFile = ZipFile.Read(ZipFileName)
                 Dim PhotoShopFiles as ICollection(Of ZipEntry)
                 PhotoShopFiles = zip1.SelectEntries("*.psd")
                 Dim psd As ZipEntry
                 For Each psd In PhotoShopFiles
                     psd.Extract
                 Next
             End Using
             </code></example>
      <param name="selectionCriteria">the string that specifies which entries to select</param>
      <returns>a collection of ZipEntry objects that conform to the inclusion spec</returns>
    </member>
    <member name="M:Ionic.Zip.ZipFile.SelectEntries(System.String,System.String)">
      <summary>
             Retrieve entries from the zipfile by specified criteria.
             </summary>
      <remarks>
        <para>
             This method allows callers to retrieve the collection of entries from the zipfile
             that fit the specified criteria.  The criteria are described in a string format, and
             can include patterns for the filename; constraints on the size of the entry;
             constraints on the last modified, created, or last accessed time for the file
             described by the entry; or the attributes of the entry.
             </para>
        <para>
             For details on the syntax for the selectionCriteria parameter, see <see cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String)" />.
             </para>
        <para>
             This method is intended for use with a ZipFile that has been read from storage.
             When creating a new ZipFile, this method will work only after the ZipArchive has
             been Saved to the disk (the ZipFile class subsequently and implicitly reads the Zip
             archive from storage.)  Calling SelectEntries on a ZipFile that has not yet been
             saved will deliver undefined results.
             </para>
      </remarks>
      <exception cref="T:System.Exception">
             Thrown if selectionCriteria has an invalid syntax.
             </exception>
      <example>
        <code>
             using (ZipFile zip1 = ZipFile.Read(ZipFileName))
             {
                 var UpdatedPhotoShopFiles = zip1.SelectEntries("*.psd", "UpdatedFiles");
                 foreach (ZipEntry e in UpdatedPhotoShopFiles)
                 {
                     // prompt for extract here
                     if (WantExtract(e.FileName))
                         e.Extract();
                 }
             }
             </code>
        <code lang="VB">
             Using zip1 As ZipFile = ZipFile.Read(ZipFileName)
                 Dim UpdatedPhotoShopFiles As ICollection(Of ZipEntry) = zip1.SelectEntries("*.psd", "UpdatedFiles")
                 Dim e As ZipEntry
                 For Each e In UpdatedPhotoShopFiles
                     ' prompt for extract here
                     If Me.WantExtract(e.FileName) Then
                         e.Extract
                     End If
                 Next
             End Using
             </code>
      </example>
      <param name="selectionCriteria">the string that specifies which entries to select</param>
      <param name="directoryPathInArchive">
             the directory in the archive from which to select entries. If null, then 
             all directories in the archive are used. 
             </param>
      <returns>a collection of ZipEntry objects that conform to the inclusion spec</returns>
    </member>
    <member name="M:Ionic.Zip.ZipFile.RemoveSelectedEntries(System.String)">
      <summary>
             Remove entries from the zipfile by specified criteria.
             </summary>
      <remarks>
        <para>
             This method allows callers to remove the collection of entries from the zipfile
             that fit the specified criteria.  The criteria are described in a string format, and
             can include patterns for the filename; constraints on the size of the entry;
             constraints on the last modified, created, or last accessed time for the file
             described by the entry; or the attributes of the entry.
             </para>
        <para>
             For details on the syntax for the selectionCriteria parameter, see <see cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String)" />.
             </para>
        <para>
             This method is intended for use with a ZipFile that has been read from storage.
             When creating a new ZipFile, this method will work only after the ZipArchive has
             been Saved to the disk (the ZipFile class subsequently and implicitly reads the Zip
             archive from storage.)  Calling SelectEntries on a ZipFile that has not yet been
             saved will deliver undefined results.
             </para>
      </remarks>
      <exception cref="T:System.Exception">
             Thrown if selectionCriteria has an invalid syntax.
             </exception>
      <example>
             This example removes all entries in a zip file that were modified prior to January 1st, 2008.
             <code>
             using (ZipFile zip1 = ZipFile.Read(ZipFileName))
             {
                 // remove all entries from prior to Jan 1, 2008
                 zip1.RemoveEntries("mtime &lt; 2008-01-01");
                 // don't forget to save the archive!
                 zip1.Save();
             }
             </code><code lang="VB">
             Using zip As ZipFile = ZipFile.Read(ZipFileName)
                 ' remove all entries from prior to Jan 1, 2008
                 zip1.RemoveEntries("mtime &lt; 2008-01-01")
                 ' do not forget to save the archive!
                 zip1.Save
             End Using 
             </code></example>
      <param name="selectionCriteria">the string that specifies which entries to select</param>
      <returns>the number of entries removed</returns>
    </member>
    <member name="M:Ionic.Zip.ZipFile.RemoveSelectedEntries(System.String,System.String)">
      <summary>
             Remove entries from the zipfile by specified criteria, and within the specified 
             path in the archive.
             </summary>
      <remarks>
        <para>
             This method allows callers to remove the collection of entries from the zipfile
             that fit the specified criteria.  The criteria are described in a string format, and
             can include patterns for the filename; constraints on the size of the entry;
             constraints on the last modified, created, or last accessed time for the file
             described by the entry; or the attributes of the entry.
             </para>
        <para>
             For details on the syntax for the selectionCriteria parameter, see <see cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String)" />.
             </para>
        <para>
             This method is intended for use with a ZipFile that has been read from storage.
             When creating a new ZipFile, this method will work only after the ZipArchive has
             been Saved to the disk (the ZipFile class subsequently and implicitly reads the Zip
             archive from storage.)  Calling SelectEntries on a ZipFile that has not yet been
             saved will deliver undefined results.
             </para>
      </remarks>
      <exception cref="T:System.Exception">
             Thrown if selectionCriteria has an invalid syntax.
             </exception>
      <example>
        <code>
             using (ZipFile zip1 = ZipFile.Read(ZipFileName))
             {
                 // remove all entries from prior to Jan 1, 2008
                 zip1.RemoveEntries("mtime &lt; 2008-01-01", "documents");
                 // a call to ZipFile.Save will make the modifications permanent
                 zip1.Save();
             }
             </code>
        <code lang="VB">
             Using zip As ZipFile = ZipFile.Read(ZipFileName)
                 ' remove all entries from prior to Jan 1, 2008
                 zip1.RemoveEntries("mtime &lt; 2008-01-01", "documents")
                 ' a call to ZipFile.Save will make the modifications permanent
                 zip1.Save
             End Using 
             </code>
      </example>
      <param name="selectionCriteria">the string that specifies which entries to select</param>
      <param name="directoryPathInArchive">
             the directory in the archive from which to select entries. If null, then 
             all directories in the archive are used. 
             </param>
      <returns>the number of entries removed</returns>
    </member>
    <member name="M:Ionic.Zip.ZipFile.ExtractSelectedEntries(System.String)">
      <summary>
             Selects and Extracts a set of Entries from the ZipFile.
             </summary>
      <remarks>
        <para>
             The entries are extracted into the current working directory. 
             </para>
        <para>
             If any of the files to be extracted already exist, then the action taken is as
             specified in the <see cref="P:Ionic.Zip.ZipEntry.ExtractExistingFile" /> property on the
             corresponding ZipEntry instance.  By default, the action taken in this case is to
             throw an exception.
             </para>
        <para>
             For information on the syntax of the selectionCriteria string,
             see <see cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String)" />.
             </para>
      </remarks>
      <example>
             This example shows how extract all XML files modified after 15 January 2009. 
             <code>
             using (ZipFile zip = ZipFile.Read(zipArchiveName))
             {
               zip.ExtractSelectedEntries("name = *.xml  and  mtime &gt; 2009-01-15");
             }
             </code></example>
      <param name="selectionCriteria">the selection criteria for entries to extract.</param>
      <seealso cref="M:Ionic.Zip.ZipFile.ExtractSelectedEntries(System.String,Ionic.Zip.ExtractExistingFileAction)" />
    </member>
    <member name="M:Ionic.Zip.ZipFile.ExtractSelectedEntries(System.String,Ionic.Zip.ExtractExistingFileAction)">
      <summary>
             Selects and Extracts a set of Entries from the ZipFile.
             </summary>
      <remarks>
        <para>
             The entries are extracted into the current working directory. When extraction would would
             overwrite an existing filesystem file, the action taken is as specified in the
             extractExistingFile parameter.
             </para>
        <para>
             For information on the syntax of the string describing the entry selection criteria, 
             see <see cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String)" />.
             </para>
      </remarks>
      <example>
             This example shows how extract all XML files modified after 15 January 2009, 
             overwriting any existing files. 
             <code>
             using (ZipFile zip = ZipFile.Read(zipArchiveName))
             {
               zip.ExtractSelectedEntries("name = *.xml  and  mtime &gt; 2009-01-15",
                                          ExtractExistingFileAction.OverwriteSilently);
             }
             </code></example>
      <param name="selectionCriteria">the selection criteria for entries to extract.</param>
      <param name="extractExistingFile">
             The action to take if extraction would overwrite an existing file.
             </param>
    </member>
    <member name="M:Ionic.Zip.ZipFile.ExtractSelectedEntries(System.String,System.String)">
      <summary>
             Selects and Extracts a set of Entries from the ZipFile.
             </summary>
      <remarks>
        <para>
             The entries are selected from the specified directory within the archive, and then 
             extracted into the current working directory. 
             </para>
        <para>
             If any of the files to be extracted already exist, then the action taken is as
             specified in the <see cref="P:Ionic.Zip.ZipEntry.ExtractExistingFile" /> property on the
             corresponding ZipEntry instance.  By default, the action taken in this case is to
             throw an exception.
             </para>
        <para>
             For information on the syntax of the string describing the entry selection criteria, 
             see <see cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String)" />.
             </para>
      </remarks>
      <example>
             This example shows how extract all XML files modified after 15 January 2009, 
             and writes them to the "unpack" directory.
             <code>
             using (ZipFile zip = ZipFile.Read(zipArchiveName))
             {
               zip.ExtractSelectedEntries("name = *.xml  and  mtime &gt; 2009-01-15","unpack");
             }
             </code></example>
      <param name="selectionCriteria">the selection criteria for entries to extract.</param>
      <param name="directoryPathInArchive">
             the directory in the archive from which to select entries. If null, then 
             all directories in the archive are used. 
             </param>
      <seealso cref="M:Ionic.Zip.ZipFile.ExtractSelectedEntries(System.String,System.String,System.String,Ionic.Zip.ExtractExistingFileAction)" />
    </member>
    <member name="M:Ionic.Zip.ZipFile.ExtractSelectedEntries(System.String,System.String,System.String)">
      <summary>
             Selects and Extracts a set of Entries from the ZipFile.
             </summary>
      <remarks>
        <para>
             The entries are extracted into the specified directory. If any of the files to be
             extracted already exist, an exception will be thrown.
             </para>
        <para>
             For information on the syntax of the string describing the entry selection criteria, 
             see <see cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String)" />.
             </para>
      </remarks>
      <param name="selectionCriteria">the selection criteria for entries to extract.</param>
      <param name="directoryInArchive">
             the directory in the archive from which to select entries. If null, then 
             all directories in the archive are used. 
             </param>
      <param name="extractDirectory">
             the directory on the disk into which to extract. It will be created 
             if it does not exist.
             </param>
    </member>
    <member name="M:Ionic.Zip.ZipFile.ExtractSelectedEntries(System.String,System.String,System.String,Ionic.Zip.ExtractExistingFileAction)">
      <summary>
             Selects and Extracts a set of Entries from the ZipFile.
             </summary>
      <remarks>
        <para>
             The entries are extracted into the specified directory. When extraction would would
             overwrite an existing filesystem file, the action taken is as specified in the
             extractExistingFile parameter.
             </para>
        <para>
             For information on the syntax of the string describing the entry selection criteria, 
             see <see cref="M:Ionic.Zip.ZipFile.AddSelectedFiles(System.String)" />.
             </para>
      </remarks>
      <example>
             This example shows how extract all files  with an XML extension or with  a size larger than 100,000 bytes, 
             and puts them in the unpack directory.  For any files that already exist in 
             that destination directory, they will not be overwritten.
             <code>
             using (ZipFile zip = ZipFile.Read(zipArchiveName))
             {
               zip.ExtractSelectedEntries("name = *.xml  or  size  &gt; 100000",
                                          null, 
                                          "unpack", 
                                          ExtractExistingFileAction.DontOverwrite);
             }
             </code></example>
      <param name="selectionCriteria">the selection criteria for entries to extract.</param>
      <param name="extractDirectory">
             The directory on the disk into which to extract. It will be created if it does not exist.
             </param>
      <param name="directoryPathInArchive">
             The directory in the archive from which to select entries. If null, then 
             all directories in the archive are used. 
             </param>
      <param name="extractExistingFile">
             The action to take if extraction would overwrite an existing file.
             </param>
    </member>
    <member name="M:Ionic.Zip.ZipFile.SaveSelfExtractor(System.String,Ionic.Zip.SelfExtractorFlavor,System.String)">
      <summary>
             Saves the ZipFile instance to a self-extracting zip archive, using the specified 
             default extract directory. 
             </summary>
      <remarks>
        <para>
             This method saves a self extracting archive, with a specified default extracting
             location.  Actually, the default extract directory applies only if the flavor is <see cref="F:Ionic.Zip.SelfExtractorFlavor.WinFormsApplication" />.  See the documentation for <see cref="M:Ionic.Zip.ZipFile.SaveSelfExtractor(System.String,Ionic.Zip.SelfExtractorFlavor)" /> for more details.
             </para>
        <para>
             The user who runs the SFX will have the opportunity to change the extract directory
             before extracting.  If at the time of extraction, the specified directory does not
             exist, the SFX will create the directory before extracting the files.
             </para>
      </remarks>
      <example>
             This example saves a self-extracting archive that will use c:\ExtractHere as the default 
             extract location.
             <code>
             string DirectoryPath = "c:\\Documents\\Project7";
             using (ZipFile zip = new ZipFile())
             {
                 zip.AddDirectory(DirectoryPath, System.IO.Path.GetFileName(DirectoryPath));
                 zip.Comment = "This will be embedded into a self-extracting console-based exe";
                 zip.SaveSelfExtractor("archive.exe", SelfExtractorFlavor.ConsoleApplication, "c:\\ExtractHere");
             }
             </code><code lang="VB">
             Dim DirectoryPath As String = "c:\Documents\Project7"
             Using zip As New ZipFile()
                 zip.AddDirectory(DirectoryPath, System.IO.Path.GetFileName(DirectoryPath))
                 zip.Comment = "This will be embedded into a self-extracting console-based exe"
                 zip.SaveSelfExtractor("archive.exe", SelfExtractorFlavor.ConsoleApplication, "c:\ExtractHere");
             End Using
             </code></example>
      <param name="exeToGenerate">The name of the EXE to generate.</param>
      <param name="flavor">Indicates whether a Winforms or Console self-extractor is desired.</param>
      <param name="defaultExtractDirectory">
             The default extract directory the user will see when running the self-extracting 
             archive. Passing null (or Nothing in VB) here will cause the Self Extractor to 
             use the the user's personal directory 
             (<see cref="F:System.Environment.SpecialFolder.Personal" />) for the default extract 
             location.
             </param>
    </member>
    <member name="M:Ionic.Zip.ZipFile.SaveSelfExtractor(System.String,Ionic.Zip.SelfExtractorFlavor,System.String,System.String)">
      <summary>
             Saves the ZipFile instance to a self-extracting zip archive, using the specified 
             default extract directory. 
             </summary>
      <remarks>
        <para>
             This method saves a self extracting archive, with a specified default extracting
             location.  Actually, the default extract directory applies only if the flavor is <see cref="F:Ionic.Zip.SelfExtractorFlavor.WinFormsApplication" />.  See the documentation for <see cref="M:Ionic.Zip.ZipFile.SaveSelfExtractor(System.String,Ionic.Zip.SelfExtractorFlavor)" /> for more details.
             </para>
        <para>
             The user who runs the SFX will have the opportunity to change the extract directory
             before extracting.  If at the time of extraction, the specified directory does not
             exist, the SFX will create the directory before extracting the files.
             </para>
      </remarks>
      <example>
             This example saves a self-extracting archive that will use c:\ExtractHere as the default 
             extract location.
             <code>
             string DirectoryPath = "c:\\Documents\\Project7";
             using (ZipFile zip = new ZipFile())
             {
                 zip.AddDirectory(DirectoryPath, System.IO.Path.GetFileName(DirectoryPath));
                 zip.Comment = "This will be embedded into a self-extracting console-based exe";
                 zip.SaveSelfExtractor("archive.exe", SelfExtractorFlavor.ConsoleApplication, "c:\\ExtractHere");
             }
             </code><code lang="VB">
             Dim DirectoryPath As String = "c:\Documents\Project7"
             Using zip As New ZipFile()
                 zip.AddDirectory(DirectoryPath, System.IO.Path.GetFileName(DirectoryPath))
                 zip.Comment = "This will be embedded into a self-extracting console-based exe"
                 zip.SaveSelfExtractor("archive.exe", SelfExtractorFlavor.ConsoleApplication, "c:\ExtractHere");
             End Using
             </code></example>
      <param name="exeToGenerate">The name of the EXE to generate.</param>
      <param name="flavor">Indicates whether a Winforms or Console self-extractor is desired.</param>
      <param name="defaultExtractDirectory">
             The default extract directory the user will see when running the self-extracting
             archive. Passing null (or Nothing in VB) here, if flavor is
             <c>SelfExtractorFlavor.WinFormsApplication</c>, will cause the Self Extractor to
             use the the user's personal directory (<see cref="F:System.Environment.SpecialFolder.Personal" />) for the default extract location.
             Passing null when flavor is <c>SelfExtractorFlavor.ConsoleApplication</c> will
             cause the self-extractor to use the current directory for the default extract
             location; it will also be settable on the command line when the SFX is executed.
             </param>
      <param name="postExtractCommandToExecute">
             The command to execute on the user's machine, after unpacking the archive. If the
             flavor is <c>SelfExtractorFlavor.ConsoleApplication</c>, then the SFX changes the
             current directory to the extract directory, and starts the post-extract command
             and waits for it to exit.  The exit code of the post-extract command line is
             returned as the exit code of the self-extractor exe.  A non-zero exit code is
             typically used to indicated a failure by the program. In the case of an SFX, a
             non-zero exit code may indicate a failure during extraction, OR, it may indicate a
             failure of the run-on-extract program if specified. There is no way to distinguish
             these conditions from the calling shell, aside from parsing output.  The GUI self
             extractor simply starts the post-extract command and exits; it does not wait for
             the command to exit first.
             </param>
    </member>
    <member name="M:Ionic.Zip.ZipFile.SaveSelfExtractor(System.String,Ionic.Zip.SelfExtractorFlavor)">
      <summary>
             Saves the ZipFile instance to a self-extracting zip archive.
             </summary>
      <remarks>
        <para>
             The generated exe image will execute on any machine that has the .NET Framework 2.0
             installed on it.  The generated exe image is also a valid ZIP file, readable with DotNetZip
             or another Zip library or tool such as WinZip. 
             </para>
        <para>
             There are two "flavors" of self-extracting archive.  The <c>WinFormsApplication</c>
             version will pop up a GUI and allow the user to select a target directory into which
             to extract. There's also a checkbox allowing the user to specify to overwrite
             existing files, and another checkbox to allow the user to request that Explorer be
             opened to see the extracted files after extraction.  The other flavor is
             <c>ConsoleApplication</c>.  A self-extractor generated with that flavor setting will
             run from the command line. It accepts command-line options to set the overwrite
             behavior, and to specify the target extraction directory.
             </para>
        <para>
             There are a few temporary files created during the saving to a self-extracting zip.
             These files are created in the directory pointed to by <see cref="P:Ionic.Zip.ZipFile.TempFileFolder" />, which defaults to <see cref="M:System.IO.Path.GetTempPath" />.  These temporary files are removed upon
             successful completion of this method.
             </para>
        <para>
             When a user runs the WinForms SFX, the user's personal directory (<see cref="F:System.Environment.SpecialFolder.Personal" />) will be used as the default extract
             location.  The user who runs the SFX will have the opportunity to change the extract
             directory before extracting. When the user runs the Command-Line SFX, the user must
             explicitly specify the directory to which to extract.  The .NET Framework 2.0 is
             required on the computer when the self-extracting archive is run.
             </para>
        <para>
             NB: This method is not available in the version of DotNetZip
             build for the .NET Compact Framework, nor in the "Reduced" DotNetZip library.  
             </para>
      </remarks>
      <example>
        <code>
             string DirectoryPath = "c:\\Documents\\Project7";
             using (ZipFile zip = new ZipFile())
             {
                 zip.AddDirectory(DirectoryPath, System.IO.Path.GetFileName(DirectoryPath));
                 zip.Comment = "This will be embedded into a self-extracting console-based exe";
                 zip.SaveSelfExtractor("archive.exe", SelfExtractorFlavor.ConsoleApplication);
             }
             </code>
        <code lang="VB">
             Dim DirectoryPath As String = "c:\Documents\Project7"
             Using zip As New ZipFile()
                 zip.AddDirectory(DirectoryPath, System.IO.Path.GetFileName(DirectoryPath))
                 zip.Comment = "This will be embedded into a self-extracting console-based exe"
                 zip.SaveSelfExtractor("archive.exe", SelfExtractorFlavor.ConsoleApplication)
             End Using
             </code>
      </example>
      <param name="exeToGenerate">a pathname, possibly fully qualified, to be created. Typically it will end in an .exe extension.</param>
      <param name="flavor">Indicates whether a Winforms or Console self-extractor is desired.</param>
    </member>
    <member name="M:Ionic.Zip.ZipFile.GetEnumerator">
      <summary>
             Generic IEnumerator support, for use of a ZipFile in an enumeration.  
             </summary>
      <remarks>
             You probably do not want to call <c>GetEnumerator</c> explicitly. Instead 
             it is implicitly called when you use a <see langword="foreach" /> loop in C#, or a 
             <c>For Each</c> loop in VB.NET.
             </remarks>
      <example>
             This example reads a zipfile of a given name, then enumerates the 
             entries in that zip file, and displays the information about each 
             entry on the Console.
             <code>
             using (ZipFile zip = ZipFile.Read(zipfile))
             {
               bool header = true;
               foreach (ZipEntry e in zip)
               {
                 if (header)
                 {
                    System.Console.WriteLine("Zipfile: {0}", zip.Name);
                    System.Console.WriteLine("Version Needed: 0x{0:X2}", e.VersionNeeded);
                    System.Console.WriteLine("BitField: 0x{0:X2}", e.BitField);
                    System.Console.WriteLine("Compression Method: 0x{0:X2}", e.CompressionMethod);
                    System.Console.WriteLine("\n{1,-22} {2,-6} {3,4}   {4,-8}  {0}",
                                 "Filename", "Modified", "Size", "Ratio", "Packed");
                    System.Console.WriteLine(new System.String('-', 72));
                    header = false;
                 }
            
                 System.Console.WriteLine("{1,-22} {2,-6} {3,4:F0}%   {4,-8}  {0}",
                             e.FileName,
                             e.LastModified.ToString("yyyy-MM-dd HH:mm:ss"),
                             e.UncompressedSize,
                             e.CompressionRatio,
                             e.CompressedSize);
            
                 e.Extract();
               }
             }
             </code><code lang="VB">
               Dim ZipFileToExtract As String = "c:\foo.zip"
               Using zip As ZipFile = ZipFile.Read(ZipFileToExtract)
                   Dim header As Boolean = True
                   Dim e As ZipEntry
                   For Each e In zip
                       If header Then
                           Console.WriteLine("Zipfile: {0}", zip.Name)
                           Console.WriteLine("Version Needed: 0x{0:X2}", e.VersionNeeded)
                           Console.WriteLine("BitField: 0x{0:X2}", e.BitField)
                           Console.WriteLine("Compression Method: 0x{0:X2}", e.CompressionMethod)
                           Console.WriteLine(ChrW(10) &amp; "{1,-22} {2,-6} {3,4}   {4,-8}  {0}", _
                             "Filename", "Modified", "Size", "Ratio", "Packed" )
                           Console.WriteLine(New String("-"c, 72))
                           header = False
                       End If
                       Console.WriteLine("{1,-22} {2,-6} {3,4:F0}%   {4,-8}  {0}", _
                         e.FileName, _
                         e.LastModified.ToString("yyyy-MM-dd HH:mm:ss"), _
                         e.UncompressedSize, _
                         e.CompressionRatio, _
                         e.CompressedSize )
                       e.Extract
                   Next
               End Using
             </code></example>
      <returns>A generic enumerator suitable for use  within a foreach loop.</returns>
    </member>
    <member name="M:Ionic.Zip.ZipFile.GetNewEnum">
      <summary>
             IEnumerator support, for use of a ZipFile in a foreach construct.  
             </summary>
      <remarks>
             This method is included for COM support.  An application generally does not call
             this method directly.  It is called implicitly by COM clients when enumerating
             the entries in the ZipFile instance.  In VBScript, this is done with a <c>For Each</c>
             statement.  In Javascript, this is done with <c>new Enumerator(zipfile)</c>.
             </remarks>
      <returns>
             The IEnumerator over the entries in the ZipFile. 
             </returns>
    </member>
    <member name="P:Ionic.Zip.ZipFile.Fullscan">
      <summary>
             Indicates whether to perform a full scan of the zipfile when reading it. 
             </summary>
      <remarks>
        <para> When reading a zip file, if this flag is true (True in VB), the entire
             zip archive will be scanned and searched for entries.  For large archives, this
             can take a very, long time. The much more efficient default behavior is to read
             the zip directory, at the end of the zip file. However, in some cases the
             directory is corrupted and it is desirable to perform a full scan of the zip
             file to determine the contents of the zip file.  </para>
        <para>
             If you want to track progress, you can set the ReadProgress event. 
             </para>
        <para>
             This flag is effective only when calling Initialize.
             The Initialize method may take a long time to run for large zip files,
             when <c>Fullscan</c> is true. 
             </para>
      </remarks>
      <example>
             This example shows how to read a zip file using the full scan approach,
             and then save it, thereby producing a corrected zip file. 
             <code lang="C#">
             using (var zip = new ZipFile())
             {
                 zip.Fullscan = true;
                 zip.Initialize(zipFileName);
                 zip.Save(newName);
             }
             </code><code lang="VB">
             Using zip As New ZipFile
                 zip.Fullscan = True
                 zip.Initialize(zipFileName)
                 zip.Save(newName)
             End Using
             </code></example>
    </member>
    <member name="P:Ionic.Zip.ZipFile.BufferSize">
      <summary>
             Size of the IO Buffer used while saving.
             </summary>
      <remarks>
        <para> First, let me say that you really don't need to bother with this.  It is
                 here to allow for optimizations that you probably won't make! It will work
                 fine if you don't set or get this property at all.  Ok?  </para>
        <para> Now that we have <em>that</em> out of the way, the fine print: This
                 property affects the size of the buffer that is used for I/O for each entry
                 contained in the zip file. When a file is read in to be compressed, it uses
                 a buffer given by the size here.  When you update a zip file, the data for
                 unmodified entries is copied from the first zip file to the other, through a
                 buffer given by the size here. </para>
        <para> Changing the buffer size affects a few things: first, for larger buffer
                 sizes, the memory used by the ZipFile, obviously, will be larger during I/O
                 operations.  This may make operations faster for very much larger files.
                 Last,
                 for any given entry, when you use a larger buffer there will be fewer
                 progress events during I/O operations, because there's one progress event
                 generated for each time the buffer is filled and then emptied.</para>
        <para> The default buffer size is 8k.  Increasing the buffer size may speed
                 things up as you compress larger files.  But there are no hard-and-fast
                 rules here, eh?  You won't know til you test it.  And there will be a limit
                 where ever larger buffers actually slow things down.  So as I said in the
                 beginning, it's probably best if you don't set or get this property at
                 all.</para>
      </remarks>
      <example>
             This example shows how you might set a large buffer size for efficiency when
             dealing with zip entries that are larger than 1gb. 
             <code lang="C#">
             using (ZipFile zip = new ZipFile())
             {
                 zip.SaveProgress += this.zip1_SaveProgress;
                 zip.AddDirectory(directoryToZip, "");
                 zip.UseZip64WhenSaving = Zip64Option.Always;
                 zip.BufferSize = 65536*8; // 65536 * 8 = 512k
                 zip.Save(ZipFileToCreate);
             }
             </code></example>
    </member>
    <member name="P:Ionic.Zip.ZipFile.CodecBufferSize">
      <summary>
            Size of the work buffer to use for the ZLIB codec during compression.
            </summary>
    </member>
    <member name="P:Ionic.Zip.ZipFile.Strategy">
      <summary>
             The compression strategy to use for all entries.
             </summary>
      <remarks>
             This refers to the Strategy used by the ZLIB-compatible compressor. Different
             compression strategies work better on different sorts of data. The strategy parameter
             can affect the compression ratio and the speed of compression but not the correctness
             of the compresssion.  For more information see <see cref="T:Ionic.Zlib.CompressionStrategy" />.
             </remarks>
    </member>
    <member name="P:Ionic.Zip.ZipFile.Name">
      <summary>
             The name of the zipfile, on disk.
             </summary>
      <remarks>
        <para>
             When the ZipFile instance was created by reading an archive using one of the
             ZipFile.Read methods, this property represents the name of the zipfile that was read.
             When the ZipFile instance was created by using the no-argument constructor, this value
             is null (Nothing in VB).
             </para>
        <para>
             If you use the no-argument constructor, and you then explicitly set this property,
             when you call <see cref="M:Ionic.Zip.ZipFile.Save" />, this name will specify the name of the
             zipfile created.  Doing so is equivalent to calling <see cref="M:Ionic.Zip.ZipFile.Save(System.String)" />.  When instantiating a ZipFile by reading from a stream
             or byte array, the Name property remains null.  When saving to a stream, the Name
             property is implicitly set to null.
             </para>
      </remarks>
    </member>
    <member name="P:Ionic.Zip.ZipFile.CompressionLevel">
      <summary>
            Sets the compression level to be used for entries when saving the zip archive.
            </summary>
      <remarks>
            The compression level setting is used at the time of Save(). The same level is applied
            to all ZipEntry instances contained in the ZipFile during the save.  If you do not set
            this property, the default compression level is used, which normally gives a good
            balance of compression efficiency and compression speed.  In some tests, using
            BEST_COMPRESSION can double the time it takes to compress, while delivering just a
            small increase in compression efficiency.  This behavior will vary with the type of
            data you compress.  If you are in doubt, just leave this setting alone, and accept the
            default.
            </remarks>
    </member>
    <member name="P:Ionic.Zip.ZipFile.Comment">
      <summary>
             A comment attached to the zip archive.
             </summary>
      <remarks>
        <para>
             This property is read/write for the zipfile. It allows the application to specify a
             comment for the zipfile, or read the comment for the zipfile.  After setting this
             property, changes are only made permanent when you call a <c>Save()</c> method.
             </para>
        <para>
             According to <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">PKWARE's zip
             specification</see>, the comment is not encrypted, even if there is a password set on
             the zip archive.
             </para>
        <para>
             The zip spec does not describe how to encode the comment string in a code page other
             than IBM437.  Therefore, for "compliant" zip tools and libraries, comments will use
             IBM437.  However, there are situations where you want an encoded Comment, for example
             using code page 950 "Big-5 Chinese".  DotNetZip will encode the comment in the code
             page specified by <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" />, at the time of the call
             to ZipFile.Save().
             </para>
        <para>
             When creating a zip archive using this library, it is possible to change the value of
             <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" /> between each entry you add, and between
             adding entries and the call to Save(). Don't do this.  It will likely result in a
             zipfile that is not readable by any tool or application.  For best interoperability,
             leave <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" /> alone, or specify it only once,
             before adding any entries to the ZipFile instance.
             </para>
      </remarks>
    </member>
    <member name="P:Ionic.Zip.ZipFile.Verbose">
      <summary>
             Indicates whether verbose output is sent to the StatusMessageTextWriter during
             <c>AddXxx()</c> and <c>ReadXxx()</c> operations.
             </summary>
      <remarks>
             This is a synthetic property.  It returns true if the <see cref="P:Ionic.Zip.ZipFile.StatusMessageTextWriter" /> is non-null.
             </remarks>
    </member>
    <member name="P:Ionic.Zip.ZipFile.CaseSensitiveRetrieval">
      <summary>
             Indicates whether to perform case-sensitive matching on the filename when retrieving
             entries in the zipfile via the string-based indexer.  
             </summary>
      <remarks>
             The default value is <c>false</c>, which means DON'T do case-sensitive matching. In
             other words, retrieving zip["ReadMe.Txt"] is the same as zip["readme.txt"].  It really
             makes sense to set this to <c>true</c> only if you are not running on Windows, which
             has case-insensitive filenames. But since this library is not built for non-Windows
             platforms, in most cases you should just leave this property alone.
             </remarks>
    </member>
    <member name="P:Ionic.Zip.ZipFile.UseUnicodeAsNecessary">
      <summary>
             Indicates whether to encode entry filenames and entry comments using Unicode 
             (UTF-8).
             </summary>
      <remarks>
        <para>
          <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">The PKWare zip
             specification</see> provides for encoding file names and file comments in either the
             IBM437 code page, or in UTF-8.  This flag selects the encoding according to that
             specification.  By default, this flag is false, and filenames and comments are encoded
             into the zip file in the IBM437 codepage.  Setting this flag to true will specify that
             filenames and comments that cannot be encoded with IBM437 will be encoded with UTF-8.
             </para>
        <para>
             Zip files created with strict adherence to the PKWare specification with respect to
             UTF-8 encoding can contain entries with filenames containing any combination of
             Unicode characters, including the full range of characters from Chinese, Latin,
             Hebrew, Greek, Cyrillic, and many other alphabets.  However, because at this time, the
             UTF-8 portion of the PKWare specification is not broadly supported by other zip
             libraries and utilities, such zip files may not be readable by your favorite zip tool
             or archiver. In other words, interoperability will decrease if you set this flag to
             true.
             </para>
        <para>
             In particular, Zip files created with strict adherence to the PKWare specification
             with respect to UTF-8 encoding will not work well with Explorer in Windows XP or
             Windows Vista, because Windows compressed folders, as far as I know, do not support
             UTF-8 in zip files.  Vista can read the zip files, but shows the filenames
             incorrectly. Unpacking from Windows Vista Explorer will result in filenames that have
             rubbish characters in place of the high-order UTF-8 bytes.
             </para>
        <para>
             Also, zip files that use UTF-8 encoding will not work well with Java applications that
             use the java.util.zip classes, as of v5.0 of the Java runtime. The Java runtime does
             not correctly implement the PKWare specification in this regard.
             </para>
        <para>
             As a result, we have the unfortunate situation that "correct" behavior by the
             DotNetZip library with regard to Unicode encoding of filenames during zip
             creation will result in zip files that are readable by strictly compliant and
             current tools (for example the most recent release of the commercial WinZip
             tool); but these zip files will not be readable by various other tools or
             libraries, including Windows Explorer.
             </para>
        <para>
             The DotNetZip library can read and write zip files with UTF8-encoded entries,
             according to the PKware spec.  If you use DotNetZip for both creating and reading the
             zip file, and you use UTF-8, there will be no loss of information in the
             filenames. For example, using a self-extractor created by this library will allow you
             to unpack files correctly with no loss of information in the filenames.
             </para>
        <para>
             If you do not set this flag, it will remain false.  If this flag is false, your
             ZipFile will encode all filenames and comments using the IBM437 codepage.  This can
             cause "loss of information" on some filenames, but the resulting zipfile will be more
             interoperable with other utilities. As an example of the loss of information,
             diacritics can be lost.  The o-tilde character will be down-coded to plain o.  The c
             with a cedilla (Unicode 0xE7) used in Portugese will be downcoded to a c.  Likewise,
             the O-stroke character (Unicode 248), used in Danish and Norwegian, will be down-coded
             to plain o. Chinese characters cannot be represented in codepage IBM437; when using
             the default encoding, Chinese characters in filenames will be represented as ?. These
             are all examples of "information loss".
             </para>
        <para>
             The loss of information associated to the use of the IBM437 encoding is inconvenient,
             and can also lead to runtime errors. For example, using IBM437, any sequence of 4
             Chinese characters will be encoded as ????.  If your application creates a ZipFile,
             then adds two files, each with names of four Chinese characters each, this will result
             in a duplicate filename exception.  In the case where you add a single file with a
             name containing four Chinese characters, calling Extract() on the entry that has
             question marks in the filename will result in an exception, because the question mark
             is not legal for use within filenames on Windows.  These are just a few examples of
             the problems associated to loss of information.
             </para>
        <para>
             This flag is independent of the encoding of the content within the entries in the zip
             file. Think of the zip file as a container - it supports an encoding.  Within the
             container are other "containers" - the file entries themselves.  The encoding within
             those entries is independent of the encoding of the zip archive container for those
             entries.
             </para>
        <para>
             Rather than specify the encoding in a binary fashion using this flag, an application
             can specify an arbitrary encoding via the <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" />
             property.  Setting the encoding explicitly when creating zip archives will result in
             non-compliant zip files that, curiously, are fairly interoperable.  The challenge is,
             the PKWare specification does not provide for a way to specify that an entry in a zip
             archive uses a code page that is neither IBM437 nor UTF-8.  Therefore if you set the
             encoding explicitly when creating a zip archive, you must take care upon reading the
             zip archive to use the same code page.  If you get it wrong, the behavior is undefined
             and may result in incorrect filenames, exceptions, stomach upset, hair loss, and acne.
             </para>
      </remarks>
      <seealso cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" />
    </member>
    <member name="P:Ionic.Zip.ZipFile.UseZip64WhenSaving">
      <summary>
             Specify whether to use ZIP64 extensions when saving a zip archive. 
             </summary>
      <remarks>
        <para>
             Designed many years ago, the <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">original zip
             specification from PKWARE</see> allowed for 32-bit quantities for the compressed and
             uncompressed sizes of zip entries, as well as a 32-bit quantity for specifying the
             length of the zip archive itself, and a maximum of 65535 entries.  These limits are
             now regularly exceeded in many backup and archival scenarios.  Recently, PKWare added
             extensions to the original zip spec, called "ZIP64 extensions", to raise those
             limitations.  This property governs whether the ZipFile instance will use those
             extensions when writing zip archives within a call to one of the Save() methods.  The
             use of these extensions is optional and explicit in DotNetZip because, despite the
             status of ZIP64 as a bona fide standard, many other zip tools and libraries do not
             support ZIP64, and therefore a zip file saved with ZIP64 extensions may be unreadable
             by some of those other tools.
             </para>
        <para>
             Set this property to <see cref="F:Ionic.Zip.Zip64Option.Always" /> to always use ZIP64 extensions
             when saving, regardless of whether your zip archive needs it.  Suppose you add 5 files,
             each under 100k, to a ZipFile.  If you specify Always for this flag before calling the
             Save() method, you will get a ZIP64 archive, though you do not need to use ZIP64
             because none of the original zip limits had been exceeded.
             </para>
        <para>
             Set this property to <see cref="F:Ionic.Zip.Zip64Option.Never" /> to tell the DotNetZip library to
             never use ZIP64 extensions.  This is useful for maximum compatibility and
             interoperability, at the expense of the capability of handling large files or large
             archives.  NB: Windows Explorer in Windows XP and Windows Vista cannot currently
             extract files from a zip64 archive, so if you want to guarantee that a zip archive
             produced by this library will work in Windows Explorer, use <c>Never</c>. If you set
             this property to <see cref="F:Ionic.Zip.Zip64Option.Never" />, and your application creates a zip
             that would exceed one of the ZIP limits, the library will throw an exception during the
             Save().
             </para>
        <para>
             Set this property to <see cref="F:Ionic.Zip.Zip64Option.AsNecessary" /> to tell the DotNetZip
             library to use the zip64 extensions when required by the entry. After the file is
             compressed, the original and compressed sizes are checked, and if they exceed the
             limits described above, then zip64 can be used. That is the general idea, but there is
             an additional wrinkle when saving to a non-seekable device, like the ASP.NET
             <c>Response.OutputStream</c>, or <c>Console.Out</c>.  When using non-seekable streams
             for output, the entry header - which indicates whether zip64 is in use - is emitted
             before it is known if zip64 is necessary.  It is only after all entries have been saved
             that it can be known if ZIP64 will be required.  On seekable output streams, after
             saving all entries, the library can seek backward and re-emit the zip file header to be
             consistent with the actual ZIP64 requirement.  But using a non-seekable output stream,
             the library cannot seek backward, so the header can never be changed. In other words,
             the archive's use of ZIP64 extensions is not alterable after the header is emitted.
             Therefore, when saving to non-seekable streams, using <see cref="F:Ionic.Zip.Zip64Option.AsNecessary" /> is the same as using <see cref="F:Ionic.Zip.Zip64Option.Always" />:
             it will always produce a zip archive that uses zip64 extensions.
             </para>
        <para>
             The default value for the property is <see cref="F:Ionic.Zip.Zip64Option.Never" />. <see cref="F:Ionic.Zip.Zip64Option.AsNecessary" /> is safest, in the sense that you will not get an
             Exception if a pre-ZIP64 limit is exceeded.
             </para>
        <para>
             You may set the property at any time before calling Save(). 
             </para>
        <para>
             The ZipFile.Read() method will properly read ZIP64-endowed zip archives, regardless of
             the value of this property.  DotNetZip will always read ZIP64 archives.  This property
             governs whether DotNetZip will write them. Therefore, when updating archives, be careful
             about setting this property after reading an archive that may use ZIP64 extensions.
             </para>
        <para>
             An interesting question is, if you have set this property to <c>AsNecessary</c>, and
             then successfully saved, does the resulting archive use ZIP64 extensions or not?  To
             learn this, check the <see cref="P:Ionic.Zip.ZipFile.OutputUsedZip64" /> property, after calling Save().
             </para>
        <para>
             Have you thought about
             <see href="http://cheeso.members.winisp.net/DotNetZipDonate.aspx">donating</see>?
             </para>
      </remarks>
      <seealso cref="P:Ionic.Zip.ZipFile.RequiresZip64" />
    </member>
    <member name="P:Ionic.Zip.ZipFile.RequiresZip64">
      <summary>
            Indicates whether the archive requires ZIP64 extensions.
            </summary>
      <remarks>
        <para>
            This property is null (or Nothing in VB) if the archive has not been saved, and there are 
            fewer than 65334 ZipEntry items contained in the archive. 
            </para>
        <para>
            The Value is true if any of the following four conditions holds: the uncompressed size
            of any entry is larger than 0xFFFFFFFF; the compressed size of any entry is larger than
            0xFFFFFFFF; the relative offset of any entry within the zip archive is larger than
            0xFFFFFFFF; or there are more than 65534 entries in the archive.  (0xFFFFFFFF =
            4,294,967,295).  The result may not be known until a Save() is attempted on the zip
            archive.  The Value of this Nullable property may be set only AFTER one of the Save()
            methods has been called.
            </para>
        <para>
            If none of the four conditions holds, and the archive has been saved, then the Value is false.
            </para>
        <para>
            A Value of false does not indicate that the zip archive, as saved, does not use ZIP64.
            It merely indicates that ZIP64 is not required.  An archive may use ZIP64 even when not
            required if the <see cref="P:Ionic.Zip.ZipFile.UseZip64WhenSaving" /> property is set to <see cref="F:Ionic.Zip.Zip64Option.Always" />, or if the <see cref="P:Ionic.Zip.ZipFile.UseZip64WhenSaving" />
            property is set to <see cref="F:Ionic.Zip.Zip64Option.AsNecessary" /> and the output stream was not
            seekable. Use the <see cref="P:Ionic.Zip.ZipFile.OutputUsedZip64" /> property to determine if the most
            recent Save() method resulted in an archive that utilized the ZIP64 extensions.
            </para>
      </remarks>
      <seealso cref="P:Ionic.Zip.ZipFile.UseZip64WhenSaving" />
      <seealso cref="P:Ionic.Zip.ZipFile.OutputUsedZip64" />
    </member>
    <member name="P:Ionic.Zip.ZipFile.OutputUsedZip64">
      <summary>
             Describes whether the most recent Save() operation used ZIP64 extensions.
             </summary>
      <remarks>
        <para>
             The use of ZIP64 extensions within an archive is not always necessary, and for
             interoperability concerns, it may be desired to NOT use ZIP64 if possible.  The
             <see cref="P:Ionic.Zip.ZipFile.UseZip64WhenSaving" /> property can be set to use ZIP64
             extensions only when necessary.  In those cases, Sometimes applications want to
             know whether a Save() actually used ZIP64 extensions.  Applications can query
             this read-only property to learn whether ZIP64 has been used in a just-saved
             ZipFile.
             </para>
        <para>
             The value is null (or Nothing in VB) if the archive has not been saved.
             </para>
        <para>
             Non-null values (HasValue is true) indicate whether ZIP64 extensions were used during
             the most recent Save() operation.  The ZIP64 extensions may have been used as required
             by any particular entry because of its uncompressed or compressed size, or because the
             archive is larger than 4294967295 bytes, or because there are more than 65534 entries
             in the archive, or because the <c>UseZip64WhenSaving</c> property was set to <see cref="F:Ionic.Zip.Zip64Option.Always" />, or because the <c>UseZip64WhenSaving</c> property was set
             to <see cref="F:Ionic.Zip.Zip64Option.AsNecessary" /> and the output stream was not seekable.  The
             value of this property does not indicate the reason the ZIP64 extensions were used.
             </para>
      </remarks>
      <seealso cref="P:Ionic.Zip.ZipFile.UseZip64WhenSaving" />
      <seealso cref="P:Ionic.Zip.ZipFile.RequiresZip64" />
    </member>
    <member name="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding">
      <summary>
             The text encoding to use when writing new entries to the ZipFile, for those
             entries that cannot be encoded with the default (IBM437) encoding; or, the
             text encoding that was used when reading the entries from the ZipFile.
             </summary>
      <remarks>
        <para>
             In its AppNote.txt document, PKWare describes how to specify in the zip entry
             header that a filename or comment containing non-ANSI characters is encoded with
             UTF-8.  But, some archivers do not follow the specification, and instead encode
             super-ANSI characters using the system default code page.  For example, WinRAR
             when run on a machine in Shanghai may encode filenames with the Big-5 Chinese
             (950) code page.  This behavior is contrary to the Zip specification, but it
             occurs anyway.
             </para>
        <para>
             When using DotNetZip to write zip archives that will be read by one of these other
             archivers, set this property to specify the code page to use when encoding the <see cref="P:Ionic.Zip.ZipEntry.FileName" /> and <see cref="P:Ionic.Zip.ZipEntry.Comment" /> for each ZipEntry in the
             zip file, for values that cannot be encoded with the default codepage for zip files,
             IBM437.  This is why this property is "provisional".  In all cases, IBM437 is used
             where possible, in other words, where no loss of data would result. It is possible,
             therefore, to have a given entry with a Comment encoded in IBM437 and a FileName
             encoded with the specified "provisional" codepage.
             </para>
        <para>
             Be aware that a zip file created after you've explicitly set the <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" /> property to a value other than IBM437 may not be
             compliant to the PKWare specification, and may not be readable by compliant archivers.
             On the other hand, many (most?) archivers are non-compliant and can read zip files
             created in arbitrary code pages.  The trick is to use or specify the proper codepage
             when reading the zip.
             </para>
        <para>
             When creating a zip archive using this library, it is possible to change the value of
             <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" /> between each entry you add, and between
             adding entries and the call to Save(). Don't do this. It will likely result in a
             zipfile that is not readable.  For best interoperability, either leave <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" /> alone, or specify it only once, before adding
             any entries to the ZipFile instance.  There is one exception to this recommendation,
             described later.
             </para>
        <para>
             When using an arbitrary, non-UTF8 code page for encoding, there is no standard way for
             the creator application - whether DotNetZip, WinZip, WinRar, or something else - to
             formally specify in the zip file which codepage has been used for the entries. As a
             result, readers of zip files are not able to inspect the zip file and determine the
             codepage that was used for the entries contained within it.  It is left to the
             application or user to determine the necessary codepage when reading zipfiles encoded
             this way.  If you use an incorrect codepage when reading a zipfile, you will get
             entries with filenames that are incorrect, and the incorrect filenames may even contain
             characters that are not legal for use within filenames in Windows. Extracting entries
             with illegal characters in the filenames will lead to exceptions. It's too bad, but
             this is just the way things are with code pages in zip files. Caveat Emptor.
             </para>
        <para>
             When using DotNetZip to read a zip archive, and the zip archive uses an arbitrary code
             page, you must specify the encoding to use before or when the zipfile is READ.  This
             means you must use a ZipFile.Read() method that allows you to specify a
             System.Text.Encoding parameter.  Setting the ProvisionalAlternateEncoding property
             after your application has read in the zip archive will not affect the entry names of
             entries that have already been read in, and is probably not what you want.
             </para>
        <para>
             And now, the exception to the rule described above.  One strategy for specifying the
             code page for a given zip file is to describe the code page in a human-readable form in
             the Zip comment. For example, the comment may read "Entries in this archive are encoded
             in the Big5 code page".  For maximum interoperability, the Zip comment in this case
             should be encoded in the default, IBM437 code page.  In this case, the zip comment is
             encoded using a different page than the filenames.  To do this, specify
             ProvisionalAlternateEncoding to your desired region-specific code page, once before
             adding any entries, and then reset ProvisionalAlternateEncoding to IBM437 before
             setting the <see cref="P:Ionic.Zip.ZipFile.Comment" /> property and calling Save().
             </para>
      </remarks>
      <example>
             This example shows how to read a zip file using the Big-5 Chinese code page (950), 
             and extract each entry in the zip file.
             For this code to work as desired, the zipfile must have been created using the big5
             code page (CP950). This is typical, for example, when using WinRar on a machine with
             CP950 set as the default code page.  In that case, the names of entries within the Zip
             archive will be stored in that code page, and reading the zip archive must be done
             using that code page.  If the application did not use the correct code page in
             ZipFile.Read(), then names of entries within the zip archive would not be correctly
             retrieved.
             <code>
             using (var zip = ZipFile.Read(zipFileName, System.Text.Encoding.GetEncoding("big5")))
             {
                 // retrieve and extract an entry using a name encoded with CP950
                 zip[MyDesiredEntry].Extract("unpack");
             }
             </code><code lang="VB">
             Using zip As ZipFile = ZipFile.Read(ZipToExtract, System.Text.Encoding.GetEncoding(950))
                 ' retrieve and extract an entry using a name encoded with CP950
                 zip(MyDesiredEntry).Extract("unpack")
             End Using
             </code></example>
      <seealso cref="F:Ionic.Zip.ZipFile.DefaultEncoding">DefaultEncoding</seealso>
    </member>
    <member name="P:Ionic.Zip.ZipFile.StatusMessageTextWriter">
      <summary>
             Gets or sets the <c>TextWriter</c> to which status messages are delivered 
             for the instance. 
             </summary>
      <remarks>
             If the TextWriter is set to a non-null value, then verbose output is sent to the
             <c>TextWriter</c> during <c>Add</c><c>, Read</c><c>, Save</c> and <c>Extract</c>
             operations.  Typically, console applications might use <c>Console.Out</c> and
             graphical or headless applications might use a <c>System.IO.StringWriter</c>. The
             output of this is suitable for viewing by humans.
             </remarks>
      <example>
        <para>
             In this example, a console application instantiates a ZipFile, then sets
             the StatusMessageTextWriter to Console.Out.  At that point, all verbose
             status messages for that ZipFile are sent to the console. 
             </para>
        <code lang="C#">
             using (ZipFile zip= ZipFile.Read(FilePath))
             {
               zip.StatusMessageTextWriter= System.Console.Out;
               // messages are sent to the console during extraction
               zip.ExtractAll();
             }
             </code>
        <code lang="VB">
             Using zip As ZipFile = ZipFile.Read(FilePath)
               zip.StatusMessageTextWriter= System.Console.Out
               'Status Messages will be sent to the console during extraction
               zip.ExtractAll()
             End Using
             </code>
      </example>
    </member>
    <member name="P:Ionic.Zip.ZipFile.ForceNoCompression">
      <summary>
             Gets or sets the flag that indicates whether the ZipFile should use
             compression for subsequently added entries in the ZipFile instance.
             </summary>
      <remarks>
        <para> 
             When saving an entry into a zip archive, the DotNetZip by default compresses the
             file. That's what a ZIP archive is all about, isn't it?  For files that are already
             compressed, like MP3's or JPGs, the deflate algorithm can actually slightly expand the
             size of the data.  Setting this property to trye allows you to specify that
             compression should not be used.  The default value is false.
             </para>
        <para>
             Do not construe setting this flag to false as "Force Compression".  Setting it to
             false merely does NOT force No compression.  If you want to force the use of the
             deflate algorithm when storing each entry into the zip archive, define a <see cref="P:Ionic.Zip.ZipFile.WillReadTwiceOnInflation" /> callback, which always returns false, and a <see cref="P:Ionic.Zip.ZipFile.WantCompression" /> callback that always returns true.  This is probably the
             wrong thing to do, but you could do it. Forcing the use of the Deflate algorithm when
             storing an entry does not guarantee that the data size will get smaller. It could
             increase, as described above.
             </para>
        <para>
             Changes to this flag apply to all entries subsequently added to the archive. 
             The application can also set the <see cref="P:Ionic.Zip.ZipEntry.CompressionMethod" />
             property on each ZipEntry, for more granular control of this capability.
             </para>
      </remarks>
      <seealso cref="P:Ionic.Zip.ZipEntry.CompressionMethod" />
      <seealso cref="P:Ionic.Zip.ZipFile.CompressionLevel" />
      <seealso cref="P:Ionic.Zip.ZipFile.WantCompression" />
      <example>
             This example shows how to specify that Compression will not be used when adding files 
             to the zip archive. None of the files added to the archive in this example will use
             compression.
             <code>
             using (ZipFile zip = new ZipFile())
             {
               zip.ForceNoCompression = true;
               zip.AddDirectory(@"c:\reports\January");
               zip.Comment = "All files in this archive will be uncompressed.";
               zip.Save(ZipFileToCreate);
             }
             </code><code lang="VB">
             Using zip As New ZipFile()
               zip.ForceNoCompression = true
               zip.AddDirectory("c:\reports\January")
               zip.Comment = "All files in this archive will be uncompressed."
               zip.Save(ZipFileToCreate)
             End Using
             </code></example>
    </member>
    <member name="P:Ionic.Zip.ZipFile.TempFileFolder">
      <summary>
             Gets or sets the name for the folder to store the temporary file
             this library writes when saving a zip archive. 
             </summary>
      <remarks>
        <para>
             This library will create a temporary file when saving a Zip archive to a file.
             This file is written when calling one of the <c>Save()</c> methods that does
             not save to a stream, or one of the <c>SaveSelfExtractor()</c> methods.  
             <para></para>
             By default, the library will create the temporary file in the directory
             specified for the file itself, via the <see cref="P:Ionic.Zip.ZipFile.Name" /> property or via the
             <see cref="M:Ionic.Zip.ZipFile.Save(System.String)" /> method.
             </para>
        <para>
             Setting this property allows applications to override this default behavior, so
             that the library will create the temporary file in the specified folder. For
             example, to have the library create the temporary file in the current working
             directory, regardless where the ZipFile is saved, specfy ".".  To revert to the
             default behavior, set this property to null (Nothing in VB).
             </para>
        <para>
             When setting the property to a non-null value, the folder specified must exist;
             if it does not an exception is thrown.  The application should have write and
             delete permissions on the folder.  The permissions are not explicitly checked
             ahead of time; if the application does not have the appropriate rights, an
             exception will be thrown at the time <c>Save()</c> is called.
             </para>
        <para>
             There is no temporary file created when reading a zip archive.  When saving to a
             Stream, there is no temporary file created.  For example, if the application is an
             ASP.NET application and calls <c>Save()</c> specifying the
             <c>Response.OutputStream</c> as the output stream, there is no temporary file created.
             </para>
      </remarks>
      <exception cref="T:System.IO.FileNotFoundException">
             Thrown when setting the property if the directory does not exist. 
             </exception>
    </member>
    <member name="P:Ionic.Zip.ZipFile.Password">
      <summary>
             Sets the password to be used on the ZipFile instance.
             </summary>
      <remarks>
        <para>
             When writing a zip archive, this password is applied to the entries, not
             to the zip archive itself. It applies to any ZipEntry subsequently added 
             to the ZipFile, using one of the AddFile, AddDirectory, or AddItem methods. 
             When reading a zip archive, this property applies to any entry subsequently 
             extracted from the ZipFile using one of the Extract methods on the ZipFile class.  
             </para>
        <para>
             When writing a zip archive, keep this in mind: though the password is set on the
             ZipFile object, according to the Zip spec, the "directory" of the archive - in
             other words the list of entries contained in the archive - is not encrypted with
             the password, or protected in any way.  IF you set the Password property, the
             password actually applies to individual entries that are added to the archive,
             subsequent to the setting of this property.  The list of filenames in the
             archive that is eventually created will appear in clear text, but the contents
             of the individual files are encrypted.  This is how Zip encryption works.
             </para>
        <para>
             If you set the password on the zip archive, and then add a set of files to the 
             archive, then each entry is encrypted with that password.  You may also want 
             to change the password between adding different entries. If you set the 
             password, add an entry, then set the password to null, and add another entry,
             the first entry is encrypted and the second is not.
             </para>
        <para>
             When setting the Password, you may also want to explicitly set the <see cref="P:Ionic.Zip.ZipFile.Encryption" /> property, to specify how to encrypt the entries added to the
             ZipFile.  If you set the Password to a non-null value and do not set <see cref="P:Ionic.Zip.ZipFile.Encryption" />, then PKZip 2.0 ("Weak") encryption is used.  This
             encryption is relatively weak but is very interoperable. If you set the password
             to a null value (<c>Nothing</c> in VB), Encryption is reset to None.
             </para>
        <para>
             All of the preceding applies to writing zip archives - when you use one of the
             Save methods.  To use this property when reading or an existing ZipFile -
             calling Extract methods on the ZipFile or the ZipEntry instances - do the
             following: set the Password property, then call one of the ZipFile.Extract()
             overloads. In this case, the entry is extracted using the Password that is
             specified on the ZipFile instance. If you have not set the Password property,
             then the password is null, and the entry is extracted with no password.
             </para>
        <para> If you set the Password property on the ZipFile, then call Extract() an
             entry that has not been encrypted with a password, the password is not
             used for that entry, and the ZipEntry is extracted as normal. In other words,
             the password is used only if necessary. </para>
      </remarks>
      <example>
        <para>
             In this example, three files are added to a Zip archive. The ReadMe.txt file
             will be placed in the root of the archive, and will not be encrypted. 
             The .png file will be included into the zip, encrypted with the "123456!" password.
             The pdf file will be included, encrypted with "!Secret1" as the password.
             </para>
        <code>
             try
             {
               using (ZipFile zip = new ZipFile())
               {
                 zip.AddFile("ReadMe.txt");
                 zip.Password= "123456!";
                 zip.AddFile("MapToTheSite-7440-N49th.png");
                 zip.Password= "!Secret1";
                 zip.AddFile("2008-Regional-Sales-Report.pdf");
            
                 zip.Save("EncryptedArchive.zip");
               }
             }
             catch (System.Exception ex1)
             {
               System.Console.Error.WriteLine("exception: {0}", ex1);
             }
             </code>
        <code lang="VB">
             Try 
               Using zip As New ZipFile
                 zip.AddFile("ReadMe.txt")
                 zip.Password = "123456!"
                 zip.AddFile("MapToTheSite-7440-N49th.png")
                 zip.Password= "!Secret1";
                 zip.AddFile("2008-Regional-Sales-Report.pdf")
                 zip.Save("EncryptedArchive.zip")
               End Using
             Catch ex1 As System.Exception
               System.Console.Error.WriteLine("exception: {0}", ex1)
             End Try
             </code>
      </example>
      <seealso cref="P:Ionic.Zip.ZipFile.Encryption" />
    </member>
    <member name="P:Ionic.Zip.ZipFile.ExtractExistingFile">
      <summary>
             The action the library should take when extracting a file that already exists.
             </summary>
      <remarks>
        <para>
             This property affects the behavior of the Extract methods (one of the <c>Extract()</c>
             or <c>ExtractWithPassword()</c> overloads), when extraction would would overwrite an
             existing filesystem file. If you do not set this property, the library throws an
             exception when extracting an entry would overwrite an existing file.
             </para>
        <para>
             This property has no effect when extracting to a stream, or when the file to be
             extracted does not already exist. 
             </para>
      </remarks>
      <seealso cref="P:Ionic.Zip.ZipEntry.ExtractExistingFile" />
    </member>
    <member name="P:Ionic.Zip.ZipFile.Encryption">
      <summary>
             The Encryption to use for entries added to the ZipFile.
             </summary>
      <remarks>
        <para>
             The specified Encryption is applied to the entries subsequently added to the ZipFile instance.  
             </para>
        <para>
             If you set this to something other than EncryptionAlgorithm.None, you will also need to set 
             the <see cref="P:Ionic.Zip.ZipFile.Password" />.
             </para>
        <para>
             As with other properties (like <see cref="P:Ionic.Zip.ZipFile.Password" /> and <see cref="P:Ionic.Zip.ZipFile.ForceNoCompression" />), setting this property a ZipFile instance will cause that
             EncryptionAlgorithm to be used on all ZipEntry items that are subsequently added to
             the ZipFile instance. In other words, if you set this property after you have added
             items to the ZipFile, but before you have called Save(), those items will not be
             encrypted or protected with a password in the resulting zip archive. To get a zip
             archive with encrypted entries, set this property, along with the <see cref="P:Ionic.Zip.ZipFile.Password" /> property, before calling <c>AddFile</c>, <c>AddItem</c>, or
             <c>AddDirectory</c> (etc.) on the ZipFile instance.
             </para>
      </remarks>
      <example>
        <code>
             try
             {
               using (ZipFile zip = new ZipFile())
               {
                 zip.Encryption= EncryptionAlgorithm.WinZipAes256;
                 zip.Password= "Top.Secret.No.Peeking!";
                 zip.AddFile("ReadMe.txt");
                 zip.AddFile("7440-N49th.png");
                 zip.AddFile("2008-Regional-Sales-Report.pdf");
                 zip.Save("EncryptedArchive.zip");
               }
             }
             catch (System.Exception ex1)
             {
               System.Console.Error.WriteLine("exception: {0}", ex1);
             }
             </code>
        <code lang="VB">
             Try 
               Using zip As New ZipFile()
                 zip.Encryption= EncryptionAlgorithm.WinZipAes256
                 zip.Password= "Top.Secret.No.Peeking!"
                 zip.AddFile("ReadMe.txt")
                 zip.AddFile("7440-N49th.png")
                 zip.AddFile("2008-Regional-Sales-Report.pdf")
                 zip.Save("EncryptedArchive.zip")
               End Using
             Catch ex1 As System.Exception
               System.Console.Error.WriteLine("exception: {0}", ex1)
             End Try
             </code>
      </example>
      <seealso cref="P:Ionic.Zip.ZipFile.Password" />
    </member>
    <member name="P:Ionic.Zip.ZipFile.WillReadTwiceOnInflation">
      <summary>
             A callback that allows the application to specify whether multiple reads of the
             stream should be performed, in the case that a compression operation actually
             inflates the size of the file data.  
             </summary>
      <remarks>
        <para>
             In some cases, applying the Deflate compression algorithm in <c>DeflateStream</c> can
             result an increase in the size of the data.  This "inflation" can happen with
             previously compressed files, such as a zip, jpg, png, mp3, and so on.  In a few
             tests, inflation on zip files can be as large as 60%!  Inflation can also happen
             with very small files.  In these cases, by default, the DotNetZip library
             discards the compressed bytes, and stores the uncompressed file data into the
             zip archive.  This is an optimization where smaller size is preferred over
             longer run times.
             </para>
        <para>
             The application can specify that compression is not even tried, by setting the
             ForceNoCompression flag.  In this case, the compress-and-check-sizes process as
             decribed above, is not done.
             </para>
        <para>
             In some cases, neither choice is optimal.  The application wants compression,
             but in some cases also wants to avoid reading the stream more than once.  This
             may happen when the stream is very large, or when the read is very expensive, or
             when the difference between the compressed and uncompressed sizes is not
             significant.
             </para>
        <para>
             To satisfy these applications, this delegate allows the DotNetZip library to ask
             the application to for approval for re-reading the stream, in the case where
             inflation occurs.  The callback is invoked only in the case of inflation; that
             is to say when the uncompressed stream is smaller than the compressed stream.
             </para>
        <para>
             As with other properties (like <see cref="P:Ionic.Zip.ZipFile.Password" /> and <see cref="P:Ionic.Zip.ZipFile.ForceNoCompression" />), setting the corresponding delegate on a ZipFile instance
             will caused it to be applied to all ZipEntry items that are subsequently added to the
             ZipFile instance. In other words, if you set this callback after you have added files
             to the ZipFile, but before you have called Save(), those items will not be governed by
             the callback when you do call Save(). Your best bet is to set this callback before
             adding any entries.
             </para>
        <para>
             Of course, if you want to have different callbacks for different entries, you may do so. 
             </para>
      </remarks>
      <example>
        <para>
             In this example, the application callback checks to see if the difference
             between the compressed and uncompressed data is greater than 25%.  If it is,
             then the callback returns true, and the application tells the library to re-read
             the stream.  If not, then the callback returns false, and the library just keeps
             the "inflated" file data.
             </para>
        <code>
            
             public bool ReadTwiceCallback(long uncompressed, long compressed, string filename)
             {
                 return ((uncompressed * 1.0/compressed) &gt; 1.25);
             }
             
             public void CreateTheZip()
             {
                 using (ZipFile zip = new ZipFile())
                 {
                     // set the callback before adding files to the zip
                     zip2.WillReadTwiceOnInflation = ReadTwiceCallback;
                     zip2.AddFile(filename1);
                     zip2.AddFile(filename2);
                     zip2.Save(ZipFileToCreate);
                 }
             }
             </code>
      </example>
      <seealso cref="P:Ionic.Zip.ZipFile.WantCompression" />
      <seealso cref="T:Ionic.Zip.WantCompressionCallback" />
      <seealso cref="P:Ionic.Zip.ZipEntry.WillReadTwiceOnInflation" />
    </member>
    <member name="P:Ionic.Zip.ZipFile.WantCompression">
      <summary>
             A callback that allows the application to specify whether compression should
             be used for entries subsequently added to the zip archive.
             </summary>
      <remarks>
        <para>
             In some cases, applying the Deflate compression algorithm to an entry *may*
             result a slight increase in the size of the data.  This "inflation" can
             happen with previously compressed files, such as a zip, jpg, png, mp3, and
             so on; it results from adding DEFLATE framing data around incompressible data.
             Inflation can also happen with very small files. Applications may wish to
             avoid the use of compression in these cases. As well, applications may wish
             to avoid compression to save time.
             </para>
        <para>
             By default, the DotNetZip library takes this approach to decide whether to
             apply compression: first it applies a heuristic, to determine whether it
             should try to compress a file or not.  The library checks the extension of
             the entry, and if it is one of a known list of uncompressible file types
             (mp3, zip, docx, and others), the library will not attempt to compress the
             entry.  The library does not actually check the content of the entry.  If
             you name a text file "Text.mp3", and then attempt to add it to a zip
             archive, this library will, by default, not attempt to compress the entry,
             based on the extension of the filename.
             </para>
        <para>
             If this default behavior is not satisfactory, there are two options. First,
             the application can override it by setting this <see cref="P:Ionic.Zip.ZipFile.WantCompression" /> callback.  This affords maximum control to
             the application.  With this callback, the application can supply its own
             logic for determining whether to apply the Deflate algorithm or not.  For
             example, an application may desire that files over 40mb in size are never
             compressed, or always compressed.  An application may desire that the first
             7 entries added to an archive are compressed, and the remaining ones are
             not.  The WantCompression callback allows the application full control, on
             an entry-by-entry basis.
             </para>
        <para>
             The second option for overriding the default logic regarding whether to
             apply compression is the ForceNoCompression flag.  If this flag is set to
             true, the compress-and-check-sizes process as decribed above, is not done,
             nor is the callback invoked.  In other words, if you set ForceNoCompression
             to true, andalso set the WantCompression callback, only the
             ForceNoCompression flag is considered.
             </para>
        <para>
             This is how the library determines whether compression will be attempted for 
             an entry.  If it is to be attempted, the library reads the entry, runs it through
             the deflate algorithm, and then checks the size of the result.  If applying
             the Deflate algorithm increases the size of the data, then the library
             discards the compressed bytes, re-reads the raw entry data, and stores the
             uncompressed file data into the zip archive, in compliance with the zip
             spec.  This is an optimization where smaller size is preferred over longer
             run times. The re-reading is gated on the <see cref="P:Ionic.Zip.ZipFile.WillReadTwiceOnInflation" /> callback, if it is set. This callback applies
             independently of the WantCompression callback.
             </para>
        <para>
             If by the logic described above, compression is not to be attempted for an entry, 
             the library reads the entry, and simply stores the entry data uncompressed. 
             </para>
        <para>
             And, if you have read this far, I would like to point out that a single
             person wrote all the code that does what is described above, and also wrote
             the description.  Isn't it about time you 
             <see href="http://cheeso.members.winisp.net/DotNetZipDonate.aspx">donated $5 in appreciation?</see>  The
             money goes to a charity. 
             </para>
      </remarks>
      <seealso cref="P:Ionic.Zip.ZipFile.WillReadTwiceOnInflation" />
    </member>
    <member name="P:Ionic.Zip.ZipFile.LibraryVersion">
      <summary>
             Returns the version number on the DotNetZip assembly.
             </summary>
      <remarks>
             This property is exposed as a convenience.  Callers
             could also get the version value by retrieving  GetName().Version 
             on the System.Reflection.Assembly object pointing to the
             DotNetZip assembly. But sometimes it is not clear which
             assembly is being loaded.  This property makes it clear. 
             </remarks>
    </member>
    <member name="P:Ionic.Zip.ZipFile.Item(System.Int32)">
      <summary>
             This is an integer indexer into the Zip archive.
             </summary>
      <remarks>
        <para>
             This property is read-write. But don't get too excited: When setting the value, the
             only legal value is null. If you assign a non-null value
             (non Nothing in VB), the setter will throw an exception.
             </para>
        <para>
             Setting the value to null is equivalent to calling <see cref="M:Ionic.Zip.ZipFile.RemoveEntry(System.String)" />
             with the filename for the given entry.
             </para>
      </remarks>
      <exception cref="T:System.ArgumentException">
             Thrown if the caller attempts to assign a non-null value to the indexer, 
             or if the caller uses an out-of-range index value.
             </exception>
      <param name="ix">
             The index value.
             </param>
      <returns>
             The ZipEntry within the Zip archive at the specified index. If the 
             entry does not exist in the archive, this indexer throws.
             </returns>
    </member>
    <member name="P:Ionic.Zip.ZipFile.Item(System.String)">
      <summary>
             This is a name-based indexer into the Zip archive.  
             </summary>
      <remarks>
        <para>
             Retrieval by the string-based indexer is done on a case-insensitive basis, 
             by default.  Set the <see cref="P:Ionic.Zip.ZipFile.CaseSensitiveRetrieval" /> property to use case-sensitive 
             comparisons. 
             </para>
        <para>
             This property is read-write. When setting the value, the only legal value is
             null. Setting the value to null is equivalent to calling <see cref="M:Ionic.Zip.ZipFile.RemoveEntry(System.String)" /> with the filename.
             </para>
        <para>
             If you assign a non-null value (non Nothing in VB), the setter will throw an
             exception.
             </para>
        <para>
             It is can be true that <c>this[value].FileName == value</c>, but not always. In
             other words, the FileName property of the ZipEntry you retrieve with this indexer, can
             be equal to the index value, but not always.  In the case of
             directory entries in the archive, you may retrieve them with the name of the directory
             with no trailing slash, even though in the entry itself, the actual <see cref="P:Ionic.Zip.ZipEntry.FileName" /> property may include a trailing slash.  In other words, for
             a directory entry named "dir1", you may find <c>zip["dir1"].FileName ==
             "dir1/"</c>. Also, for any entry with slashes, they are stored in the zip file as
             forward slashes, but you may retrieve them with either forward or backslashes.  So,
             <c>zip["dir1\\entry1.txt"].FileName == "dir1/entry.txt"</c>.
             </para>
      </remarks>
      <example>
             This example extracts only the entries in a zip file that are .txt files.
             <code>
             using (ZipFile zip = ZipFile.Read("PackedDocuments.zip"))
             {
               foreach (string s1 in zip.EntryFilenames)
               {
                 if (s1.EndsWith(".txt"))
                   zip[s1].Extract("textfiles");
               }
             }
             </code><code lang="VB">
               Using zip As ZipFile = ZipFile.Read("PackedDocuments.zip")
                   Dim s1 As String
                   For Each s1 In zip.EntryFilenames
                       If s1.EndsWith(".txt") Then
                           zip(s1).Extract("textfiles")
                       End If
                   Next
               End Using
             </code></example>
      <seealso cref="M:Ionic.Zip.ZipFile.RemoveEntry(System.String)" />
      <exception cref="T:System.ArgumentException">
             Thrown if the caller attempts to assign a non-null value to the indexer.
             </exception>
      <param name="fileName">
             The name of the file, including any directory path, to retrieve from the zip. 
             The filename match is not case-sensitive by default; you can use the
             <see cref="P:Ionic.Zip.ZipFile.CaseSensitiveRetrieval" /> property to change this behavior. The
             pathname can use forward-slashes or backward slashes.
             </param>
      <returns>
             The ZipEntry within the Zip archive, given by the specified filename. If the named
             entry does not exist in the archive, this indexer returns null.
             </returns>
    </member>
    <member name="P:Ionic.Zip.ZipFile.EntryFileNames">
      <summary>
             The list of filenames for the entries contained within the zip archive.  
             </summary>
      <remarks>
             According to the ZIP specification, the names of the entries use forward slashes in pathnames. 
             If you are scanning through the list, you may have to swap forward slashes for backslashes.
             </remarks>
      <seealso cref="P:Ionic.Zip.ZipFile.Item(System.String)" />
      <example>
             This example shows one way to test if a filename is already contained within 
             a zip archive.
             <code>
             String ZipFileToRead= "PackedDocuments.zip";
             string Candidate = "DatedMaterial.xps";
             using (ZipFile zip = new ZipFile(ZipFileToRead))
             {
               if (zip.EntryFilenames.Contains(Candidate))
                 Console.WriteLine("The file '{0}' exists in the zip archive '{1}'",
                                   Candidate,
                                   ZipFileName);
               else
                 Console.WriteLine("The file, '{0}', does not exist in the zip archive '{1}'",
                                   Candidate,
                                   ZipFileName);
               Console.WriteLine();
             }
             </code><code lang="VB">
               Dim ZipFileToRead As String = "PackedDocuments.zip"
               Dim Candidate As String = "DatedMaterial.xps"
               Using zip As New ZipFile(ZipFileToRead)
                   If zip.EntryFilenames.Contains(Candidate) Then
                       Console.WriteLine("The file '{0}' exists in the zip archive '{1}'", _
                                   Candidate, _
                                   ZipFileName)
                   Else
                     Console.WriteLine("The file, '{0}', does not exist in the zip archive '{1}'", _
                                   Candidate, _
                                   ZipFileName)
                   End If
                   Console.WriteLine
               End Using
             </code></example>
      <returns>
             The list of strings for the filenames contained within the Zip archive.
             </returns>
    </member>
    <member name="P:Ionic.Zip.ZipFile.Entries">
      <summary>
            Returns the readonly collection of entries in the Zip archive.
            </summary>
      <remarks>
            If there are no entries in the current ZipFile, the value returned is a non-null zero-element collection.
            </remarks>
    </member>
    <member name="P:Ionic.Zip.ZipFile.Count">
      <summary>
            Returns the number of entries in the Zip archive.
            </summary>
    </member>
    <member name="E:Ionic.Zip.ZipFile.SaveProgress">
      <summary>
             An event handler invoked when a Save() starts, before and after each entry has been
             written to the archive, when a Save() completes, and during other Save events.
             </summary>
      <remarks>
        <para>
             Depending on the particular event, different properties on the
             SaveProgressEventArgs parameter are set.  The following table 
             summarizes the available EventTypes and the conditions under which this 
             event handler is invoked with a SaveProgressEventArgs with the given EventType.
             </para>
        <list type="table">
          <listheader>
            <term>value of EntryType</term>
            <description>Meaning and conditions</description>
          </listheader>
          <item>
            <term>ZipProgressEventType.Saving_Started</term>
            <description>Fired when ZipFile.Save() begins. 
             </description>
          </item>
          <item>
            <term>ZipProgressEventType.Saving_BeforeSaveEntry</term>
            <description>Fired within ZipFile.Save(), just before writing data for each particular entry. 
             </description>
          </item>
          <item>
            <term>ZipProgressEventType.Saving_AfterSaveEntry</term>
            <description>Fired within ZipFile.Save(), just after having finished writing data for each 
             particular entry. 
             </description>
          </item>
          <item>
            <term>ZipProgressEventType.Saving_Completed</term>
            <description>Fired when ZipFile.Save() has completed. 
             </description>
          </item>
          <item>
            <term>ZipProgressEventType.Saving_AfterSaveTempArchive</term>
            <description>Fired after the temporary file has been created.  This happens only
             when saving to a disk file.  This event will not be invoked when saving to a stream.
             </description>
          </item>
          <item>
            <term>ZipProgressEventType.Saving_BeforeRenameTempArchive</term>
            <description>Fired just before renaming the temporary file to the permanent location.  This 
             happens only when saving to a disk file.  This event will not be invoked when saving to a stream.
             </description>
          </item>
          <item>
            <term>ZipProgressEventType.Saving_AfterRenameTempArchive</term>
            <description>Fired just after renaming the temporary file to the permanent location.  This 
             happens only when saving to a disk file.  This event will not be invoked when saving to a stream.
             </description>
          </item>
          <item>
            <term>ZipProgressEventType.Saving_AfterCompileSelfExtractor</term>
            <description>Fired after a self-extracting archive has finished compiling. 
             This EventType is used only within SaveSelfExtractor().
             </description>
          </item>
          <item>
            <term>ZipProgressEventType.Saving_BytesRead</term>
            <description>Set during the save of a particular entry, to update progress of the Save(). 
             When this EventType is set, the BytesTransferred is the number of bytes that have been read from the 
             source stream.  The TotalBytesToTransfer is the number of bytes in the uncompressed file.
             </description>
          </item>
        </list>
      </remarks>
      <example>
        <code lang="C#">
             static bool justHadByteUpdate= false;
             public static void SaveProgress(object sender, SaveProgressEventArgs e)
             {
                 if (e.EventType == ZipProgressEventType.Saving_Started)
                     Console.WriteLine("Saving: {0}", e.ArchiveName);
             
                 else if (e.EventType == ZipProgressEventType.Saving_Completed)
                 {
                     justHadByteUpdate= false; 
                     Console.WriteLine();
                     Console.WriteLine("Done: {0}", e.ArchiveName);
                 }
             
                 else if (e.EventType == ZipProgressEventType.Saving_BeforeWriteEntry)
                 {
                     if (justHadByteUpdate) 
                         Console.WriteLine();
                     Console.WriteLine("  Writing: {0} ({1}/{2})",  
                                       e.CurrentEntry.FileName, e.EntriesSaved, e.EntriesTotal);
                     justHadByteUpdate= false;
                 }
             
                 else if (e.EventType == ZipProgressEventType.Saving_EntryBytesRead)
                 {
                     if (justHadByteUpdate)
                         Console.SetCursorPosition(0, Console.CursorTop);
                      Console.Write("     {0}/{1} ({2:N0}%)", e.BytesTransferred, e.TotalBytesToTransfer,
                                   e.BytesTransferred / (0.01 * e.TotalBytesToTransfer ));
                     justHadByteUpdate= true;
                 }
             }
             
             public static ZipUp(string targetZip, string directory)
             {
               using (var zip = new ZipFile()) {
                 zip.SaveProgress += SaveProgress; 
                 zip.AddDirectory(directory);
                 zip.Save(targetZip);
               }
             }
            
             </code>
        <code lang="VB">
             Public Sub ZipUp(ByVal targetZip As String, ByVal directory As String)
                 Try 
                     Using zip As ZipFile = New ZipFile
                         AddHandler zip.SaveProgress, AddressOf MySaveProgress
                         zip.AddDirectory(directory)
                         zip.Save(targetZip)
                     End Using
                 Catch ex1 As Exception
                     Console.Error.WriteLine(("exception: " &amp; ex1.ToString))
                 End Try
             End Sub
             
             Private Shared justHadByteUpdate As Boolean = False
             
             Public Shared Sub MySaveProgress(ByVal sender As Object, ByVal e As SaveProgressEventArgs)
                 If (e.EventType Is ZipProgressEventType.Saving_Started) Then
                     Console.WriteLine("Saving: {0}", e.ArchiveName)
             
                 ElseIf (e.EventType Is ZipProgressEventType.Saving_Completed) Then
                     justHadByteUpdate = False
                     Console.WriteLine
                     Console.WriteLine("Done: {0}", e.ArchiveName)
             
                 ElseIf (e.EventType Is ZipProgressEventType.Saving_BeforeWriteEntry) Then
                     If justHadByteUpdate Then
                         Console.WriteLine
                     End If
                     Console.WriteLine("  Writing: {0} ({1}/{2})", e.CurrentEntry.FileName, e.EntriesSaved, e.EntriesTotal)
                     justHadByteUpdate = False
             
                 ElseIf (e.EventType Is ZipProgressEventType.Saving_EntryBytesRead) Then
                     If justHadByteUpdate Then
                         Console.SetCursorPosition(0, Console.CursorTop)
                     End If
                     Console.Write("     {0}/{1} ({2:N0}%)", e.BytesTransferred, _
                                   e.TotalBytesToTransfer, _
                                   (CDbl(e.BytesTransferred) / (0.01 * e.TotalBytesToTransfer)))
                     justHadByteUpdate = True
                 End If
             End Sub
             </code>
        <para>
             This is an example of using the SaveProgress events in a WinForms app.
             </para>
        <code>
             delegate void SaveEntryProgress(SaveProgressEventArgs e);
             delegate void ButtonClick(object sender, EventArgs e);
            
             public class WorkerOptions
             {
                 public string ZipName;
                 public string Folder;
                 public string Encoding;
                 public string Comment;
                 public int ZipFlavor;
                 public Zip64Option Zip64;
             }
            
             private int _progress2MaxFactor;
             private bool _saveCanceled;
             private long _totalBytesBeforeCompress;
             private long _totalBytesAfterCompress;
             private Thread _workerThread;
            
            
             private void btnZipup_Click(object sender, EventArgs e)
             {
                 KickoffZipup();
             }
            
             private void btnCancel_Click(object sender, EventArgs e)
             {
                 if (this.lblStatus.InvokeRequired)
                 {
                     this.lblStatus.Invoke(new ButtonClick(this.btnCancel_Click), new object[] { sender, e });
                 }
                 else
                 {
                     _saveCanceled = true;
                     lblStatus.Text = "Canceled...";
                     ResetState();
                 }
             }
            
             private void KickoffZipup()
             {
                 _folderName = tbDirName.Text;
            
                 if (_folderName == null || _folderName == "") return;
                 if (this.tbZipName.Text == null || this.tbZipName.Text == "") return;
            
                 // check for existence of the zip file:
                 if (System.IO.File.Exists(this.tbZipName.Text))
                 {
                     var dlgResult = MessageBox.Show(String.Format("The file you have specified ({0}) already exists." + 
                                                                   "  Do you want to overwrite this file?", this.tbZipName.Text), 
                                                     "Confirmation is Required", MessageBoxButtons.YesNo, MessageBoxIcon.Question);
                     if (dlgResult != DialogResult.Yes) return;
                     System.IO.File.Delete(this.tbZipName.Text);
                 }
            
                  _saveCanceled = false;
                 _nFilesCompleted = 0;
                 _totalBytesAfterCompress = 0;
                 _totalBytesBeforeCompress = 0;
                 this.btnOk.Enabled = false;
                 this.btnOk.Text = "Zipping...";
                 this.btnCancel.Enabled = true;
                 lblStatus.Text = "Zipping...";
            
                 var options = new WorkerOptions
                 {
                     ZipName = this.tbZipName.Text,
                     Folder = _folderName,
                     Encoding = "ibm437"
                 };
            
                 if (this.comboBox1.SelectedIndex != 0)
                 {
                     options.Encoding = this.comboBox1.SelectedItem.ToString();
                 }
            
                 if (this.radioFlavorSfxCmd.Checked)
                     options.ZipFlavor = 2;
                 else if (this.radioFlavorSfxGui.Checked)
                     options.ZipFlavor = 1;
                 else options.ZipFlavor = 0;
            
                 if (this.radioZip64AsNecessary.Checked)
                     options.Zip64 = Zip64Option.AsNecessary;
                 else if (this.radioZip64Always.Checked)
                     options.Zip64 = Zip64Option.Always;
                 else options.Zip64 = Zip64Option.Never;
            
                 options.Comment = String.Format("Encoding:{0} || Flavor:{1} || ZIP64:{2}\r\nCreated at {3} || {4}\r\n",
                             options.Encoding,
                             FlavorToString(options.ZipFlavor),
                             options.Zip64.ToString(),
                             System.DateTime.Now.ToString("yyyy-MMM-dd HH:mm:ss"),
                             this.Text);
            
                 if (this.tbComment.Text != TB_COMMENT_NOTE)
                     options.Comment += this.tbComment.Text;
            
                 _workerThread = new Thread(this.DoSave);
                 _workerThread.Name = "Zip Saver thread";
                 _workerThread.Start(options);
                 this.Cursor = Cursors.WaitCursor;
              }
            
            
             private void DoSave(Object p)
             {
                 WorkerOptions options = p as WorkerOptions;
                 try
                 {
                     using (var zip1 = new ZipFile())
                     {
                         zip1.ProvisionalAlternateEncoding = System.Text.Encoding.GetEncoding(options.Encoding);
                         zip1.Comment = options.Comment;
                         zip1.AddDirectory(options.Folder);
                         _entriesToZip = zip1.EntryFileNames.Count;
                         SetProgressBars();
                         zip1.SaveProgress += this.zip1_SaveProgress;
            
                         zip1.UseZip64WhenSaving = options.Zip64;
            
                         if (options.ZipFlavor == 1)
                             zip1.SaveSelfExtractor(options.ZipName, SelfExtractorFlavor.WinFormsApplication);
                         else if (options.ZipFlavor == 2)
                             zip1.SaveSelfExtractor(options.ZipName, SelfExtractorFlavor.ConsoleApplication);
                         else
                             zip1.Save(options.ZipName);
                     }
                 }
                 catch (System.Exception exc1)
                 {
                     MessageBox.Show(String.Format("Exception while zipping: {0}", exc1.Message));
                     btnCancel_Click(null, null);
                 }
             }
            
            
            
             void zip1_SaveProgress(object sender, SaveProgressEventArgs e)
             {
                 switch (e.EventType)
                 {
                     case ZipProgressEventType.Saving_AfterWriteEntry:
                         StepArchiveProgress(e);
                         break;
                     case ZipProgressEventType.Saving_EntryBytesRead:
                         StepEntryProgress(e);
                         break;
                     case ZipProgressEventType.Saving_Completed:
                         SaveCompleted();
                         break;
                     case ZipProgressEventType.Saving_AfterSaveTempArchive:
                         // this event only occurs when saving an SFX file
                         TempArchiveSaved();
                         break;
                 }
                 if (_saveCanceled)
                     e.Cancel = true;
             }
            
            
            
             private void StepArchiveProgress(SaveProgressEventArgs e)
             {
                 if (this.progressBar1.InvokeRequired)
                 {
                     this.progressBar1.Invoke(new SaveEntryProgress(this.StepArchiveProgress), new object[] { e });
                 }
                 else
                 {
                     if (!_saveCanceled)
                     {
                         _nFilesCompleted++;
                         this.progressBar1.PerformStep();
                         _totalBytesAfterCompress += e.CurrentEntry.CompressedSize;
                         _totalBytesBeforeCompress += e.CurrentEntry.UncompressedSize;
            
                         // reset the progress bar for the entry:
                         this.progressBar2.Value = this.progressBar2.Maximum = 1;
            
                         this.Update();
                     }
                 }
             }
            
            
             private void StepEntryProgress(SaveProgressEventArgs e)
             {
                 if (this.progressBar2.InvokeRequired)
                 {
                     this.progressBar2.Invoke(new SaveEntryProgress(this.StepEntryProgress), new object[] { e });
                 }
                 else
                 {
                     if (!_saveCanceled)
                     {
                         if (this.progressBar2.Maximum == 1)
                         {
                             // reset
                             Int64 max = e.TotalBytesToTransfer;
                             _progress2MaxFactor = 0;
                             while (max &gt; System.Int32.MaxValue)
                             {
                                 max /= 2;
                                 _progress2MaxFactor++;
                             }
                             this.progressBar2.Maximum = (int)max;
                             lblStatus.Text = String.Format("{0} of {1} files...({2})",
                                 _nFilesCompleted + 1, _entriesToZip, e.CurrentEntry.FileName);
                         }
            
                          int xferred = e.BytesTransferred &gt;&gt; _progress2MaxFactor;
            
                          this.progressBar2.Value = (xferred &gt;= this.progressBar2.Maximum)
                             ? this.progressBar2.Maximum
                             : xferred;
            
                          this.Update();
                     }
                 }
             }
            
             private void SaveCompleted()
             {
                 if (this.lblStatus.InvokeRequired)
                 {
                     this.lblStatus.Invoke(new MethodInvoker(this.SaveCompleted));
                 }
                 else
                 {
                     lblStatus.Text = String.Format("Done, Compressed {0} files, {1:N0}% of original.",
                         _nFilesCompleted, (100.00 * _totalBytesAfterCompress) / _totalBytesBeforeCompress);
                      ResetState();
                 }
             }
            
             private void ResetState()
             {
                 this.btnCancel.Enabled = false;
                 this.btnOk.Enabled = true;
                 this.btnOk.Text = "Zip it!";
                 this.progressBar1.Value = 0;
                 this.progressBar2.Value = 0;
                 this.Cursor = Cursors.Default;
                 if (!_workerThread.IsAlive)
                     _workerThread.Join();
             }
             </code>
      </example>
    </member>
    <member name="E:Ionic.Zip.ZipFile.ReadProgress">
      <summary>
             An event handler invoked before, during, and after the reading of a zip archive.
             </summary>
      <remarks>
        <para>
             Depending on the particular event being signaled, different properties on the
             ReadProgressEventArgs parameter are set.  The following table 
             summarizes the available EventTypes and the conditions under which this 
             event handler is invoked with a ReadProgressEventArgs with the given EventType.
             </para>
        <list type="table">
          <listheader>
            <term>value of EntryType</term>
            <description>Meaning and conditions</description>
          </listheader>
          <item>
            <term>ZipProgressEventType.Reading_Started</term>
            <description>Fired just as ZipFile.Read() begins. Meaningful properties: ArchiveName.
             </description>
          </item>
          <item>
            <term>ZipProgressEventType.Reading_Completed</term>
            <description>Fired when ZipFile.Read() has completed. Meaningful properties: ArchiveName.
             </description>
          </item>
          <item>
            <term>ZipProgressEventType.Reading_ArchiveBytesRead</term>
            <description>Fired while reading, updates the number of bytes read for the entire archive. 
             Meaningful properties: ArchiveName, CurrentEntry, BytesTransferred, TotalBytesToTransfer.
             </description>
          </item>
          <item>
            <term>ZipProgressEventType.Reading_BeforeReadEntry</term>
            <description>Indicates an entry is about to be read from the archive.
             Meaningful properties: ArchiveName, EntriesTotal.
             </description>
          </item>
          <item>
            <term>ZipProgressEventType.Reading_AfterReadEntry</term>
            <description>Indicates an entry has just been read from the archive.
             Meaningful properties: ArchiveName, EntriesTotal, CurrentEntry.
             </description>
          </item>
        </list>
      </remarks>
    </member>
    <member name="E:Ionic.Zip.ZipFile.ExtractProgress">
      <summary>
             An event handler invoked before, during, and after extraction of entries 
             in the zip archive. 
             </summary>
      <remarks>
        <para>
             Depending on the particular event, different properties on the
             ExtractProgressEventArgs parameter are set.  The following table 
             summarizes the available EventTypes and the conditions under which this 
             event handler is invoked with a ExtractProgressEventArgs with the given EventType.
             </para>
        <list type="table">
          <listheader>
            <term>value of EntryType</term>
            <description>Meaning and conditions</description>
          </listheader>
          <item>
            <term>ZipProgressEventType.Extracting_BeforeExtractAll</term>
            <description>Set when ExtractAll() begins.  The ArchiveName, Overwrite,
             and ExtractLocation properties are meaningful.</description>
          </item>
          <item>
            <term>ZipProgressEventType.Extracting_AfterExtractAll</term>
            <description>Set when ExtractAll() has completed.  The ArchiveName, 
             Overwrite, and ExtractLocation properties are meaningful.
             </description>
          </item>
          <item>
            <term>ZipProgressEventType.Extracting_BeforeExtractEntry</term>
            <description>Set when an Extract() on an entry in the ZipFile has begun.  
             Properties that are meaningful:  ArchiveName, EntriesTotal, CurrentEntry, Overwrite, 
             ExtractLocation, EntriesExtracted.
             </description>
          </item>
          <item>
            <term>ZipProgressEventType.Extracting_AfterExtractEntry</term>
            <description>Set when an Extract() on an entry in the ZipFile has completed.  
             Properties that are meaningful:  ArchiveName, EntriesTotal, CurrentEntry, Overwrite, 
             ExtractLocation, EntriesExtracted.
             </description>
          </item>
          <item>
            <term>ZipProgressEventType.Extracting_EntryBytesWritten</term>
            <description>Set within a call to Extract() on an entry in the ZipFile, as
             data is extracted for the entry.  Properties that are meaningful:  ArchiveName, 
             CurrentEntry, BytesTransferred, TotalBytesToTransfer. 
             </description>
          </item>
        </list>
      </remarks>
      <example>
        <code>
             private static bool justHadByteUpdate = false;
             public static void ExtractProgress(object sender, ExtractProgressEventArgs e)
             {
               if(e.EventType == ZipProgressEventType.Extracting_EntryBytesWritten)
               {
                 if (justHadByteUpdate)
                   Console.SetCursorPosition(0, Console.CursorTop);
            
                 Console.Write("   {0}/{1} ({2:N0}%)", e.BytesTransferred, e.TotalBytesToTransfer,
                               e.BytesTransferred / (0.01 * e.TotalBytesToTransfer ));
                 justHadByteUpdate = true;
               }
               else if(e.EventType == ZipProgressEventType.Extracting_BeforeExtractEntry)
               {
                 if (justHadByteUpdate) 
                   Console.WriteLine();
                 Console.WriteLine("Extracting: {0}", e.CurrentEntry.FileName);
                 justHadByteUpdate= false;
               }
             }
            
             public static ExtractZip(string zipToExtract, string directory)
             {
               string TargetDirectory= "extract";
               using (var zip = ZipFile.Read(zipToExtract)) {
                 zip.ExtractProgress += ExtractProgress; 
                 foreach (var e in zip1)
                 {
                   e.Extract(TargetDirectory, true);
                 }
               }
             }
            
             </code>
        <code lang="VB">
             Public Shared Sub Main(ByVal args As String())
                 Dim ZipToUnpack As String = "C1P3SML.zip"
                 Dim TargetDir As String = "ExtractTest_Extract"
                 Console.WriteLine("Extracting file {0} to {1}", ZipToUnpack, TargetDir)
                 Using zip1 As ZipFile = ZipFile.Read(ZipToUnpack)
                     AddHandler zip1.ExtractProgress, AddressOf MyExtractProgress
                     Dim e As ZipEntry
                     For Each e In zip1
                         e.Extract(TargetDir, True)
                     Next
                 End Using
             End Sub
             
             Private Shared justHadByteUpdate As Boolean = False
             
             Public Shared Sub MyExtractProgress(ByVal sender As Object, ByVal e As ExtractProgressEventArgs)
                 If (e.EventType Is ZipProgressEventType.Extracting_EntryBytesWritten) Then
                     If ExtractTest.justHadByteUpdate Then
                         Console.SetCursorPosition(0, Console.CursorTop)
                     End If
                     Console.Write("   {0}/{1} ({2:N0}%)", e.BytesTransferred, e.TotalBytesToTransfer, (CDbl(e.BytesTransferred) / (0.01 * e.TotalBytesToTransfer)))
                     ExtractTest.justHadByteUpdate = True
                 ElseIf (e.EventType Is ZipProgressEventType.Extracting_BeforeExtractEntry) Then
                     If ExtractTest.justHadByteUpdate Then
                         Console.WriteLine
                     End If
                     Console.WriteLine("Extracting: {0}", e.CurrentEntry.FileName)
                     ExtractTest.justHadByteUpdate = False
                 End If
             End Sub
             </code>
      </example>
    </member>
    <member name="E:Ionic.Zip.ZipFile.AddProgress">
      <summary>
             An event handler invoked before, during, and after Adding entries to a zip archive.
             </summary>
      <remarks> Adding a large number of entries to a zip file can take a long
                 time.  For example, when calling <see cref="M:Ionic.Zip.ZipFile.AddDirectory(System.String)" /> on a
                 directory that contains 50,000 files, it could take 3 minutes or so.
                 This event handler allws an application to track the progress of the Add
                 operation.  </remarks>
      <example>
        <code lang="C#">
            
             int _numEntriesToAdd= 0;
             int _numEntriesAdded= 0;
             void AddProgressHandler(object sender, AddProgressEventArgs e)
             {
                 switch (e.EventType)
                 {
                     case ZipProgressEventType.Adding_Started:
                         Console.WriteLine("Adding files to the zip...");
                         break;
                      case ZipProgressEventType.Adding_AfterAddEntry:
                         _numEntriesAdded++;
                         Console.WriteLine(String.Format("Adding file {0}/{1} :: {2}",
                                                  _numEntriesAdded, _numEntriesToAdd, e.CurrentEntry.FileName));
                         break;
                         
                     case ZipProgressEventType.Adding_Completed:
                         Console.WriteLine("Added all files");
                         break;
                 }
             }
                
             void CreateTheZip()
             {
                 using (ZipFile zip = new ZipFile())
                 {
                     zip.AddProgress += AddProgressHandler;
                     zip.AddDirectory(System.IO.Path.GetFileName(DirToZip));
                     zip.BufferSize = 4096;
                     zip.SaveProgress += SaveProgressHandler;
                     zip.Save(ZipFileToCreate);
                 }
             }
                 
             </code>
      </example>
    </member>
    <member name="T:Ionic.Zip.Zip64Option">
      <summary>
            Options for using ZIP64 extensions when saving zip archives. 
            </summary>
    </member>
    <member name="F:Ionic.Zip.Zip64Option.Default">
      <summary>
            The default behavior, which is "Never".
            (For COM clients, this is a 0 (zero).)
            </summary>
    </member>
    <member name="F:Ionic.Zip.Zip64Option.Never">
      <summary>
            Do not use ZIP64 extensions when writing zip archives.
            (For COM clients, this is a 0 (zero).)
            </summary>
    </member>
    <member name="F:Ionic.Zip.Zip64Option.AsNecessary">
      <summary>
            Use ZIP64 extensions when writing zip archives, as necessary. 
            For example, when a single entry exceeds 0xFFFFFFFF in size, or when the archive as a whole 
            exceeds 0xFFFFFFFF in size, or when there are more than 65535 entries in an archive.
            (For COM clients, this is a 1.)
            </summary>
    </member>
    <member name="F:Ionic.Zip.Zip64Option.Always">
      <summary>
            Always use ZIP64 extensions when writing zip archives, even when unnecessary.
            (For COM clients, this is a 2.)
            </summary>
    </member>
    <member name="T:Ionic.Zip.SelfExtractorFlavor">
      <summary>
            An enum that provides the different self-extractor flavors
            </summary>
    </member>
    <member name="F:Ionic.Zip.SelfExtractorFlavor.ConsoleApplication">
      <summary>
            A self-extracting zip archive that runs from the console or command line. 
            </summary>
    </member>
    <member name="F:Ionic.Zip.SelfExtractorFlavor.WinFormsApplication">
      <summary>
            A self-extracting zip archive that presents a graphical user interface when it is executed.. 
            </summary>
    </member>
    <member name="T:Ionic.Zlib.CRC32">
      <summary>
            Calculates a 32bit Cyclic Redundancy Checksum (CRC) using the
            same polynomial used by Zip. This type is used internally by DotNetZip; it is generally not used directly
            by applications wishing to create, read, or manipulate zip archive files.
            </summary>
    </member>
    <member name="M:Ionic.Zlib.CRC32.GetCrc32(System.IO.Stream)">
      <summary>
            Returns the CRC32 for the specified stream.
            </summary>
      <param name="input">The stream over which to calculate the CRC32</param>
      <returns>the CRC32 calculation</returns>
    </member>
    <member name="M:Ionic.Zlib.CRC32.GetCrc32AndCopy(System.IO.Stream,System.IO.Stream)">
      <summary>
            Returns the CRC32 for the specified stream, and writes the input into the output stream.
            </summary>
      <param name="input">The stream over which to calculate the CRC32</param>
      <param name="output">The stream into which to deflate the input</param>
      <returns>the CRC32 calculation</returns>
    </member>
    <member name="M:Ionic.Zlib.CRC32.ComputeCrc32(System.Int32,System.Byte)">
      <summary>
            Get the CRC32 for the given (word,byte) combo. 
            This is a computation defined by PKzip.
            </summary>
      <param name="W">The word to start with.</param>
      <param name="B">The byte to combine it with.</param>
      <returns>The CRC-ized result.</returns>
    </member>
    <member name="M:Ionic.Zlib.CRC32.SlurpBlock(System.Byte[],System.Int32,System.Int32)">
      <summary>
            Update the value for the running CRC32 using the given block of bytes.
            This is useful when using the CRC32() class in a Stream.
            </summary>
      <param name="block">block of bytes to slurp</param>
      <param name="offset">starting point in the block</param>
      <param name="count">how many bytes within the block to slurp</param>
    </member>
    <member name="P:Ionic.Zlib.CRC32.TotalBytesRead">
      <summary>
            indicates the total number of bytes read on the CRC stream.
            This is used when writing the ZipDirEntry when compressing files.
            </summary>
    </member>
    <member name="P:Ionic.Zlib.CRC32.Crc32Result">
      <summary>
            Indicates the current CRC for all blocks slurped in.
            </summary>
    </member>
    <member name="T:Ionic.Zlib.CrcCalculatorStream">
      <summary>
             A Stream that calculates a CRC32 (a checksum) on all bytes read, 
             or on all bytes written.
             </summary>
      <remarks>
        <para>
             This class can be used to verify the CRC of a ZipEntry when reading from a stream, 
             or to calculate a CRC when writing to a stream.  The stream should be used to either 
             read, or write, but not both.  If you intermix reads and writes, the results are
             not defined. 
             </para>
        <para>This class is intended primarily for use internally by the DotNetZip library.</para>
      </remarks>
    </member>
    <member name="M:Ionic.Zlib.CrcCalculatorStream.#ctor(System.IO.Stream)">
      <summary>
            The default constructor.
            </summary>
      <remarks>
            Instances returned from this constructor will leave the underlying stream open
            upon Close().
            </remarks>
      <param name="stream">The underlying stream</param>
    </member>
    <member name="M:Ionic.Zlib.CrcCalculatorStream.#ctor(System.IO.Stream,System.Boolean)">
      <summary>
            The constructor allows the caller to specify how to handle the underlying stream at close.
            </summary>
      <param name="stream">The underlying stream</param>
      <param name="leaveOpen">true to leave the underlying stream 
            open upon close of the CrcCalculatorStream.; false otherwise.</param>
    </member>
    <member name="M:Ionic.Zlib.CrcCalculatorStream.#ctor(System.IO.Stream,System.Int64)">
      <summary>
            A constructor allowing the specification of the length of the stream to read.
            </summary>
      <remarks>
            Instances returned from this constructor will leave the underlying stream open
            upon Close().
            </remarks>
      <param name="stream">The underlying stream</param>
      <param name="length">The length of the stream to slurp</param>
    </member>
    <member name="M:Ionic.Zlib.CrcCalculatorStream.#ctor(System.IO.Stream,System.Int64,System.Boolean)">
      <summary>
            A constructor allowing the specification of the length of the stream to read, as
            well as whether to keep the underlying stream open upon Close().
            </summary>
      <param name="stream">The underlying stream</param>
      <param name="length">The length of the stream to slurp</param>
      <param name="leaveOpen">true to leave the underlying stream 
            open upon close of the CrcCalculatorStream.; false otherwise.</param>
    </member>
    <member name="M:Ionic.Zlib.CrcCalculatorStream.Read(System.Byte[],System.Int32,System.Int32)">
      <summary>
            Read from the stream
            </summary>
      <param name="buffer">the buffer to read</param>
      <param name="offset">the offset at which to start</param>
      <param name="count">the number of bytes to read</param>
      <returns>the number of bytes actually read</returns>
    </member>
    <member name="M:Ionic.Zlib.CrcCalculatorStream.Write(System.Byte[],System.Int32,System.Int32)">
      <summary>
            Write to the stream. 
            </summary>
      <param name="buffer">the buffer from which to write</param>
      <param name="offset">the offset at which to start writing</param>
      <param name="count">the number of bytes to write</param>
    </member>
    <member name="M:Ionic.Zlib.CrcCalculatorStream.Flush">
      <summary>
            Flush the stream.
            </summary>
    </member>
    <member name="M:Ionic.Zlib.CrcCalculatorStream.Seek(System.Int64,System.IO.SeekOrigin)">
      <summary>
            Not implemented.
            </summary>
      <param name="offset">N/A</param>
      <param name="origin">N/A</param>
      <returns>N/A</returns>
    </member>
    <member name="M:Ionic.Zlib.CrcCalculatorStream.SetLength(System.Int64)">
      <summary>
            Not implemented.
            </summary>
      <param name="value">N/A</param>
    </member>
    <member name="M:Ionic.Zlib.CrcCalculatorStream.Close">
      <summary>
            Closes the stream.
            </summary>
    </member>
    <member name="P:Ionic.Zlib.CrcCalculatorStream.TotalBytesSlurped">
      <summary>
             Gets the total number of bytes run through the CRC32 calculator.
             </summary>
      <remarks>
             This is either the total number of bytes read, or the total number
             of bytes written, depending on the direction of this stream.
             </remarks>
    </member>
    <member name="P:Ionic.Zlib.CrcCalculatorStream.Crc32">
      <summary>
            Provides the current CRC for all blocks slurped in.
            </summary>
    </member>
    <member name="P:Ionic.Zlib.CrcCalculatorStream.LeaveOpen">
      <summary>
            Indicates whether the underlying stream will be left open when the CrcCalculatorStream is Closed.
            </summary>
    </member>
    <member name="P:Ionic.Zlib.CrcCalculatorStream.CanRead">
      <summary>
            Indicates whether the stream supports reading. 
            </summary>
    </member>
    <member name="P:Ionic.Zlib.CrcCalculatorStream.CanSeek">
      <summary>
            Indicates whether the stream supports seeking. 
            </summary>
    </member>
    <member name="P:Ionic.Zlib.CrcCalculatorStream.CanWrite">
      <summary>
            Indicates whether the stream supports writing. 
            </summary>
    </member>
    <member name="P:Ionic.Zlib.CrcCalculatorStream.Length">
      <summary>
            Not implemented.
            </summary>
    </member>
    <member name="P:Ionic.Zlib.CrcCalculatorStream.Position">
      <summary>
            Not implemented.
            </summary>
    </member>
    <member name="T:Ionic.Zlib.DeflateStream">
      <summary>
             A class for compressing and decompressing streams using the Deflate algorithm.
             </summary>
      <remarks>
        <para>
             The DeflateStream is a <see href="http://en.wikipedia.org/wiki/Decorator_pattern">Decorator</see> on a <see cref="T:System.IO.Stream" />.  It adds DEFLATE compression or decompression to any stream.
             </para>
        <para> Using this stream, applications can compress or decompress data via
             stream <c>Read</c> and <c>Write</c> operations.  Either compresssion or
             decompression can occur through either reading or writing. The compression
             format used is DEFLATE, which is documented in <see href="http://www.ietf.org/rfc/rfc1951.txt">IETF RFC 1951</see>, "DEFLATE
             Compressed Data Format Specification version 1.3.".</para>
        <para>
             This class is similar to <see cref="T:Ionic.Zlib.ZlibStream" />, except that <c>ZlibStream</c>
             adds the <see href="http://www.ietf.org/rfc/rfc1950.txt">RFC 1950 - ZLIB</see>
             framing bytes to a compressed stream when compressing, or expects the RFC1950
             framing bytes when decompressing. The <c>DeflateStream</c> does not.
             </para>
      </remarks>
      <seealso cref="T:Ionic.Zlib.DeflateStream" />
      <seealso cref="T:Ionic.Zlib.GZipStream" />
    </member>
    <member name="M:Ionic.Zlib.DeflateStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode)">
      <summary>
            Create a DeflateStream using the specified CompressionMode.
            </summary>
      <remarks> When mode is <c>CompressionMode.Compress</c>, the DeflateStream
            will use the default compression level. The "captive" stream will be closed
            when the DeflateStream is closed.  </remarks>
      <example>
            This example uses a DeflateStream to compress data from a file, and writes
            the compressed data to another file.
            <code>
            using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
            {
                using (var raw = System.IO.File.Create(fileToCompress + ".deflated"))
                {
                    using (Stream compressor = new DeflateStream(raw, CompressionMode.Compress))
                    {
                        byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                        int n;
                        while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                        {
                            compressor.Write(buffer, 0, n);
                        }
                    }
                }
            }
            </code><code lang="VB">
            Using input As Stream = File.OpenRead(fileToCompress)
                Using raw As FileStream = File.Create(fileToCompress &amp; ".deflated")
                    Using compressor As Stream = New DeflateStream(raw, CompressionMode.Compress)
                        Dim buffer As Byte() = New Byte(4096) {}
                        Dim n As Integer = -1
                        Do While (n &lt;&gt; 0)
                            If (n &gt; 0) Then
                                compressor.Write(buffer, 0, n)
                            End If
                            n = input.Read(buffer, 0, buffer.Length)
                        Loop
                    End Using
                End Using
            End Using
            </code></example>
      <param name="stream">The stream which will be read or written.</param>
      <param name="mode">Indicates whether the DeflateStream will compress or decompress.</param>
    </member>
    <member name="M:Ionic.Zlib.DeflateStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode,Ionic.Zlib.CompressionLevel)">
      <summary>
             Create a DeflateStream using the specified CompressionMode and the specified CompressionLevel.
             </summary>
      <remarks>
        <para> When mode is <c>CompressionMode.Decompress</c>, the level parameter
             is ignored.  The "captive" stream will be closed when the DeflateStream is
             closed.
             </para>
      </remarks>
      <example>
             This example uses a DeflateStream to compress data from a file, and writes
             the compressed data to another file.
             <code>
             using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
             {
                 using (var raw = System.IO.File.Create(fileToCompress + ".deflated"))
                 {
                     using (Stream compressor = new DeflateStream(raw,
                                                                  CompressionMode.Compress, 
                                                                  CompressionLevel.BestCompression))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n= -1;
                         while (n != 0)
                         {
                             if (n &gt; 0) 
                                 compressor.Write(buffer, 0, n);
                             n= input.Read(buffer, 0, buffer.Length);
                         }
                     }
                 }
             }
             </code><code lang="VB">
             Using input As Stream = File.OpenRead(fileToCompress)
                 Using raw As FileStream = File.Create(fileToCompress &amp; ".deflated")
                     Using compressor As Stream = New DeflateStream(raw, CompressionMode.Compress, CompressionLevel.BestCompression)
                         Dim buffer As Byte() = New Byte(4096) {}
                         Dim n As Integer = -1
                         Do While (n &lt;&gt; 0)
                             If (n &gt; 0) Then
                                 compressor.Write(buffer, 0, n)
                             End If
                             n = input.Read(buffer, 0, buffer.Length)
                         Loop
                     End Using
                 End Using
             End Using
             </code></example>
      <param name="stream">The stream to be read or written while deflating or inflating.</param>
      <param name="mode">Indicates whether the DeflateStream will compress or decompress.</param>
      <param name="level">A tuning knob to trade speed for effectiveness.</param>
    </member>
    <member name="M:Ionic.Zlib.DeflateStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode,System.Boolean)">
      <summary>
             Create a DeflateStream using the specified CompressionMode, and explicitly specify 
             whether the stream should be left open after Deflation or Inflation.
             </summary>
      <remarks>
        <para> This constructor allows the application to request that the captive
             stream remain open after the deflation or inflation occurs.  By default,
             after Close() is called on the stream, the captive stream is also closed. In
             some cases this is not desired, for example if the stream is a memory stream
             that will be re-read after compression.  Specify true for the leaveOpen
             parameter to leave the stream open.  </para>
        <para>
             The DeflateStream will use the default compression level.
             </para>
        <para>
             See the other overloads of this constructor for example code.
             </para>
      </remarks>
      <param name="stream">The stream which will be read or written. This is called the 
             "captive" stream in other places in this documentation.</param>
      <param name="mode">Indicates whether the DeflateStream will compress or decompress.</param>
      <param name="leaveOpen">true if the application would like the stream to
             remain open after inflation/deflation.</param>
    </member>
    <member name="M:Ionic.Zlib.DeflateStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode,Ionic.Zlib.CompressionLevel,System.Boolean)">
      <summary> Create a DeflateStream using the specified CompressionMode and the
             specified CompressionLevel, and explicitly specify whether the stream should
             be left open after Deflation or Inflation.  </summary>
      <remarks>
        <para>
             When mode is <c>CompressionMode.Decompress</c>, the level parameter is ignored. 
             </para>
        <para>
             This constructor allows the application to request that the captive stream
             remain open after the deflation or inflation occurs.  By default, after Close()
             is called on the stream, the captive stream is also closed. In some cases this
             is not desired, for example if the stream is a <see cref="T:System.IO.MemoryStream" /> that will be re-read after compression.  Specify
             true for the leaveOpen parameter to leave the stream open.
             </para>
      </remarks>
      <example>
             This example shows how to use a DeflateStream to compress data from a file, and store
             the compressed data into another file.
             <code>
             using (var output = System.IO.File.Create(fileToCompress + ".deflated"))
             {
                 using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
                 {
                     using (Stream compressor = new DeflateStream(output, CompressionMode.Compress, CompressionLevel.BestCompression, true))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n= -1;
                         while (n != 0)
                         {
                             if (n &gt; 0) 
                                 compressor.Write(buffer, 0, n);
                             n= input.Read(buffer, 0, buffer.Length);
                         }
                     }
                 }
                 // can write additional data to the output stream here
             }
             </code><code lang="VB">
             Using output As FileStream = File.Create(fileToCompress &amp; ".deflated")
                 Using input As Stream = File.OpenRead(fileToCompress)
                     Using compressor As Stream = New DeflateStream(output, CompressionMode.Compress, CompressionLevel.BestCompression, True)
                         Dim buffer As Byte() = New Byte(4096) {}
                         Dim n As Integer = -1
                         Do While (n &lt;&gt; 0)
                             If (n &gt; 0) Then
                                 compressor.Write(buffer, 0, n)
                             End If
                             n = input.Read(buffer, 0, buffer.Length)
                         Loop
                     End Using
                 End Using
                 ' can write additional data to the output stream here.
             End Using
             </code></example>
      <param name="stream">The stream which will be read or written.</param>
      <param name="mode">Indicates whether the DeflateStream will compress or decompress.</param>
      <param name="leaveOpen">true if the application would like the stream to remain open after inflation/deflation.</param>
      <param name="level">A tuning knob to trade speed for effectiveness.</param>
    </member>
    <member name="M:Ionic.Zlib.DeflateStream.Dispose(System.Boolean)">
      <summary>
            Dispose the stream.  
            </summary>
      <remarks>
            This may or may not result in a Close() call on the captive stream. 
            See the constructors that have a leaveOpen parameter for more information.
            </remarks>
    </member>
    <member name="M:Ionic.Zlib.DeflateStream.Flush">
      <summary>
            Flush the stream.
            </summary>
    </member>
    <member name="M:Ionic.Zlib.DeflateStream.Read(System.Byte[],System.Int32,System.Int32)">
      <summary>
             Read data from the stream. 
             </summary>
      <remarks>
        <para> If you wish to use the DeflateStream to compress data while reading,
             you can create a DeflateStream with CompressionMode.Compress, providing an
             uncompressed data stream.  Then call Read() on that DeflateStream, and the
             data read will be compressed as you read.  If you wish to use the
             DeflateStream to decompress data while reading, you can create a
             DeflateStream with CompressionMode.Decompress, providing a readable
             compressed data stream.  Then call Read() on that DeflateStream, and the
             data read will be decompressed as you read.  </para>
        <para>
             A DeflateStream can be used for Read() or Write(), but not both. 
             </para>
      </remarks>
      <param name="buffer">The buffer into which the read data should be placed.</param>
      <param name="offset">the offset within that data array to put the first byte read.</param>
      <param name="count">the number of bytes to read.</param>
      <returns>the number of bytes actually read</returns>
    </member>
    <member name="M:Ionic.Zlib.DeflateStream.Seek(System.Int64,System.IO.SeekOrigin)">
      <summary>
            Calling this method always throws a <see cref="T:System.NotImplementedException" />.
            </summary>
      <param name="offset">this is irrelevant, since it will always throw!</param>
      <param name="origin">this is irrelevant, since it will always throw!</param>
      <returns>irrelevant!</returns>
    </member>
    <member name="M:Ionic.Zlib.DeflateStream.SetLength(System.Int64)">
      <summary>
            Calling this method always throws a NotImplementedException.
            </summary>
      <param name="value">this is irrelevant, since it will always throw!</param>
    </member>
    <member name="M:Ionic.Zlib.DeflateStream.Write(System.Byte[],System.Int32,System.Int32)">
      <summary>
            Write data to the stream. 
            </summary>
      <remarks>
        <para>
            If you wish to use the DeflateStream to compress data while writing, you can
            create a DeflateStream with CompressionMode.Compress, and a writable output
            stream.  Then call Write() on that DeflateStream, providing uncompressed
            data as input.  The data sent to the output stream will be the compressed
            form of the data written.  If you wish to use the DeflateStream to
            decompress data while writing, you can create a DeflateStream with
            CompressionMode.Decompress, and a writable output stream.  Then call Write()
            on that stream, providing previously compressed data. The data sent to the
            output stream will be the decompressed form of the data written.
            </para>
        <para>
            A DeflateStream can be used for Read() or Write(), but not both. 
            </para>
      </remarks>
      <param name="buffer">The buffer holding data to write to the stream.</param>
      <param name="offset">the offset within that data array to find the first byte to write.</param>
      <param name="count">the number of bytes to write.</param>
    </member>
    <member name="P:Ionic.Zlib.DeflateStream.FlushMode">
      <summary>
            This property sets the flush behavior on the stream.  
            </summary>
      <remarks> See the ZLIB documentation for the meaning of the flush behavior.
            </remarks>
    </member>
    <member name="P:Ionic.Zlib.DeflateStream.BufferSize">
      <summary>
             The size of the working buffer for the compression codec. 
             </summary>
      <remarks>
        <para>
             The working buffer is used for all stream operations.  The default size is 1024 bytes.
             The minimum size is 128 bytes. You may get better performance with a larger buffer.
             Then again, you might not.  You would have to test it.
             </para>
        <para>
             Set this before the first call to Read()  or Write() on the stream. If you try to set it 
             afterwards, it will throw.
             </para>
      </remarks>
    </member>
    <member name="P:Ionic.Zlib.DeflateStream.Strategy">
      <summary>The ZLIB strategy to be used during compression.</summary>
      <remarks>By tweaking this parameter, you may be able to optimize the compression for 
            data with particular characteristics.</remarks>
    </member>
    <member name="P:Ionic.Zlib.DeflateStream.TotalIn">
      <summary> Returns the total number of bytes input so far.</summary>
    </member>
    <member name="P:Ionic.Zlib.DeflateStream.TotalOut">
      <summary> Returns the total number of bytes output so far.</summary>
    </member>
    <member name="P:Ionic.Zlib.DeflateStream.CanRead">
      <summary>
            Indicates whether the stream can be read.
            </summary>
      <remarks>
            The return value depends on whether the captive stream supports reading.
            </remarks>
    </member>
    <member name="P:Ionic.Zlib.DeflateStream.CanSeek">
      <summary>
            Indicates whether the stream supports Seek operations.
            </summary>
      <remarks>
            Always returns false.
            </remarks>
    </member>
    <member name="P:Ionic.Zlib.DeflateStream.CanWrite">
      <summary>
            Indicates whether the stream can be written.
            </summary>
      <remarks>
            The return value depends on whether the captive stream supports writing.
            </remarks>
    </member>
    <member name="P:Ionic.Zlib.DeflateStream.Length">
      <summary>
            Reading this property always throws a NotImplementedException.
            </summary>
    </member>
    <member name="P:Ionic.Zlib.DeflateStream.Position">
      <summary>
            The position of the stream pointer. 
            </summary>
      <remarks>
            Writing this property always throws a NotImplementedException. Reading will
            return the total bytes written out, if used in writing, or the total bytes 
            read in, if used in reading.   The count may refer to compressed bytes or 
            uncompressed bytes, depending on how you've used the stream.
            </remarks>
    </member>
    <member name="T:Ionic.Zlib.GZipStream">
      <summary>
             A class for compressing and decompressing GZIP streams.
             </summary>
      <remarks>
        <para>
             The GZipStream is a <see href="http://en.wikipedia.org/wiki/Decorator_pattern">Decorator</see> on a <see cref="T:System.IO.Stream" />.  It adds GZIP compression or decompression to any stream.
             </para>
        <para> Like the <c>System.IO.Compression.GZipStream</c> in the .NET Base
             Class Library, the Ionic.Zlib.GZipStream can compress while writing, or decompress
             while reading, but not vice versa.  The compression method used is GZIP, which is
             documented in <see href="http://www.ietf.org/rfc/rfc1952.txt">IETF RFC 1952</see>,
             "GZIP file format specification version 4.3".</para>
        <para> A GZipStream can be used to decompress data (through Read()) or to compress
             data (through Write()), but not both.  </para>
        <para> If you wish to use the GZipStream to compress data, you must wrap it around a
             write-able stream. As you call Write() on the GZipStream, the data will be
             compressed into the GZIP format.  If you want to decompress data, you must wrap the
             GZipStream around a readable stream that contains an IETF RFC 1952-compliant stream.
             The data will be decompressed as you call Read() on the GZipStream.  </para>
        <para> Though the GZIP format allows data from multiple files to be concatenated
             together, this stream handles only a single segment of GZIP format, typically
             representing a single file.  </para>
        <para>
             This class is similar to <see cref="T:Ionic.Zlib.ZlibStream" /> and <see cref="T:Ionic.Zlib.DeflateStream" />.
             <c>ZlibStream</c> handles RFC1950-compliant streams.  <see cref="T:Ionic.Zlib.DeflateStream" />
             handles RFC1951-compliant streams. This class handles RFC1952-compliant streams.
             </para>
      </remarks>
      <seealso cref="T:Ionic.Zlib.DeflateStream" />
      <seealso cref="T:Ionic.Zlib.ZlibStream" />
    </member>
    <member name="F:Ionic.Zlib.GZipStream.LastModified">
      <summary>
             The last modified time for the GZIP stream.
             </summary>
      <remarks> GZIP allows the storage of a last modified time with each GZIP entry.
             When compressing data, you can set this before the first call to Write().  When
             decompressing, you can retrieve this value any time after the first call to
             Read().  </remarks>
    </member>
    <member name="M:Ionic.Zlib.GZipStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode)">
      <summary>
             Create a GZipStream using the specified CompressionMode. 
             </summary>
      <remarks>
        <para> When mode is <c>CompressionMode.Compress</c>, the GZipStream will use the
             default compression level.  </para>
        <para> As noted in the class documentation, the CompressionMode (Compress or
             Decompress) also establishes the "direction" of the stream.  A GZipStream with
             CompressionMode.Compress works only through Write().  A GZipStream with
             CompressionMode.Decompress works only through Read().  </para>
      </remarks>
      <example>
             This example shows how to use a GZipStream to compress data.
             <code>
             using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
             {
                 using (var raw = System.IO.File.Create(outputFile))
                 {
                     using (Stream compressor = new GZipStream(raw, CompressionMode.Compress))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n;
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             compressor.Write(buffer, 0, n);
                         }
                     }
                 }
             }
             </code><code lang="VB">
             Dim outputFile As String = (fileToCompress &amp; ".compressed")
             Using input As Stream = File.OpenRead(fileToCompress)
                 Using raw As FileStream = File.Create(outputFile)
                 Using compressor As Stream = New GZipStream(raw, CompressionMode.Compress)
                     Dim buffer As Byte() = New Byte(4096) {}
                     Dim n As Integer = -1
                     Do While (n &lt;&gt; 0)
                         If (n &gt; 0) Then
                             compressor.Write(buffer, 0, n)
                         End If
                         n = input.Read(buffer, 0, buffer.Length)
                     Loop
                 End Using
                 End Using
             End Using
             </code></example>
      <param name="stream">The stream which will be read or written.</param>
      <param name="mode">Indicates whether the GZipStream will compress or decompress.</param>
    </member>
    <member name="M:Ionic.Zlib.GZipStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode,Ionic.Zlib.CompressionLevel)">
      <summary>
             Create a GZipStream using the specified CompressionMode and the specified CompressionLevel.
             </summary>
      <remarks>
        <para>
             The CompressionMode (Compress or Decompress) also establishes the "direction" of the
             stream.  A GZipStream with CompressionMode.Compress works only through Write().  A
             GZipStream with CompressionMode.Decompress works only through Read().
             </para>
      </remarks>
      <example>
             This example shows how to use a GZipStream to compress a file into a .gz file.
             <code>
             using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
             {
                 using (var raw = System.IO.File.Create(fileToCompress + ".gz"))
                 {
                     using (Stream compressor = new GZipStream(raw,
                                                               CompressionMode.Compress, 
                                                               CompressionLevel.BestCompression))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n;
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             compressor.Write(buffer, 0, n);
                         }
                     }
                 }
             }
             </code><code lang="VB">
             Using input As Stream = File.OpenRead(fileToCompress)
                 Using raw As FileStream = File.Create(fileToCompress &amp; ".gz")
                     Using compressor As Stream = New GZipStream(raw, CompressionMode.Compress, CompressionLevel.BestCompression)
                         Dim buffer As Byte() = New Byte(4096) {}
                         Dim n As Integer = -1
                         Do While (n &lt;&gt; 0)
                             If (n &gt; 0) Then
                                 compressor.Write(buffer, 0, n)
                             End If
                             n = input.Read(buffer, 0, buffer.Length)
                         Loop
                     End Using
                 End Using
             End Using
             </code></example>
      <param name="stream">The stream to be read or written while deflating or inflating.</param>
      <param name="mode">Indicates whether the GZipStream will compress or decompress.</param>
      <param name="level">A tuning knob to trade speed for effectiveness.</param>
    </member>
    <member name="M:Ionic.Zlib.GZipStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode,System.Boolean)">
      <summary>
             Create a GZipStream using the specified CompressionMode, and explicitly specify whether
             the stream should be left open after Deflation or Inflation.
             </summary>
      <remarks>
        <para>
             This constructor allows the application to request that the captive stream remain open after
             the deflation or inflation occurs.  By default, after Close() is called on the stream, the 
             captive stream is also closed. In some cases this is not desired, for example if the stream 
             is a memory stream that will be re-read after compressed data has been written to it.  Specify true for the 
             leaveOpen parameter to leave the stream open. 
             </para>
        <para>
             As noted in the class documentation, 
             the CompressionMode (Compress or Decompress) also establishes the "direction" of the stream.  
             A GZipStream with CompressionMode.Compress works only through Write().  A GZipStream with 
             CompressionMode.Decompress works only through Read().
             </para>
        <para>
             The DeflateStream will use the default compression level.
             </para>
        <para>
             See the other overloads of this constructor for example code.
             </para>
      </remarks>
      <param name="stream">The stream which will be read or written. This is called the 
             "captive" stream in other places in this documentation.</param>
      <param name="mode">Indicates whether the GZipStream will compress or decompress.</param>
      <param name="leaveOpen">true if the application would like the base stream to remain open after inflation/deflation.</param>
    </member>
    <member name="M:Ionic.Zlib.GZipStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode,Ionic.Zlib.CompressionLevel,System.Boolean)">
      <summary>
            Create a GZipStream using the specified CompressionMode and the specified CompressionLevel,
            and explicitly specify whether the stream should be left open after Deflation or Inflation.
            </summary>
      <remarks>
        <para>
            This constructor allows the application to request that the captive stream remain open after
            the deflation or inflation occurs.  By default, after Close() is called on the stream, the 
            captive stream is also closed. In some cases this is not desired, for example if the stream 
            is a memory stream that will be re-read after compressed data has been written to it.  Specify true for the 
            leaveOpen parameter to leave the stream open. 
            </para>
        <para>
            As noted in the class documentation, 
            the CompressionMode (Compress or Decompress) also establishes the "direction" of the stream.  
            A GZipStream with CompressionMode.Compress works only through Write().  A GZipStream with 
            CompressionMode.Decompress works only through Read().
            </para>
      </remarks>
      <example>
            This example shows how to use a DeflateStream to compress data.
            <code>
            using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
            {
                using (var raw = System.IO.File.Create(outputFile))
                {
                    using (Stream compressor = new GZipStream(raw, CompressionMode.Compress, CompressionLevel.BestCompression, true))
                    {
                        byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                        int n;
                        while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                        {
                            compressor.Write(buffer, 0, n);
                        }
                    }
                }
            }
            </code><code lang="VB">
            Dim outputFile As String = (fileToCompress &amp; ".compressed")
            Using input As Stream = File.OpenRead(fileToCompress)
                Using raw As FileStream = File.Create(outputFile)
                Using compressor As Stream = New GZipStream(raw, CompressionMode.Compress, CompressionLevel.BestCompression, True)
                    Dim buffer As Byte() = New Byte(4096) {}
                    Dim n As Integer = -1
                    Do While (n &lt;&gt; 0)
                        If (n &gt; 0) Then
                            compressor.Write(buffer, 0, n)
                        End If
                        n = input.Read(buffer, 0, buffer.Length)
                    Loop
                End Using
                End Using
            End Using
            </code></example>
      <param name="stream">The stream which will be read or written.</param>
      <param name="mode">Indicates whether the GZipStream will compress or decompress.</param>
      <param name="leaveOpen">true if the application would like the stream to remain open after inflation/deflation.</param>
      <param name="level">A tuning knob to trade speed for effectiveness.</param>
    </member>
    <member name="M:Ionic.Zlib.GZipStream.Dispose(System.Boolean)">
      <summary>
            Dispose the stream.  
            </summary>
      <remarks>
            This may or may not result in a Close() call on the captive stream. 
            See the ctor's with leaveOpen parameters for more information.
            </remarks>
    </member>
    <member name="M:Ionic.Zlib.GZipStream.Flush">
      <summary>
            Flush the stream.
            </summary>
    </member>
    <member name="M:Ionic.Zlib.GZipStream.Read(System.Byte[],System.Int32,System.Int32)">
      <summary>
            Read and decompress data from the source stream.
            </summary>
      <remarks>
            With a GZipStream, decompression is done through reading.
            </remarks>
      <example>
        <code>
            byte[] working = new byte[WORKING_BUFFER_SIZE];
            using (System.IO.Stream input = System.IO.File.OpenRead(_CompressedFile))
            {
                using (Stream decompressor= new Ionic.Zlib.GZipStream(input, CompressionMode.Decompress, true))
                {
                    using (var output = System.IO.File.Create(_DecompressedFile))
                    {
                        int n;
                        while ((n= decompressor.Read(working, 0, working.Length)) !=0)
                        {
                            output.Write(working, 0, n);
                        }
                    }
                }
            }
            </code>
      </example>
      <param name="buffer">The buffer into which the decompressed data should be placed.</param>
      <param name="offset">the offset within that data array to put the first byte read.</param>
      <param name="count">the number of bytes to read.</param>
      <returns>the number of bytes actually read</returns>
    </member>
    <member name="M:Ionic.Zlib.GZipStream.Seek(System.Int64,System.IO.SeekOrigin)">
      <summary>
            Calling this method always throws a <see cref="T:System.NotImplementedException" />.
            </summary>
      <param name="offset">this is irrelevant, since it will always throw!</param>
      <param name="origin">this is irrelevant, since it will always throw!</param>
      <returns>irrelevant!</returns>
    </member>
    <member name="M:Ionic.Zlib.GZipStream.SetLength(System.Int64)">
      <summary>
            Calling this method always throws a NotImplementedException.
            </summary>
      <param name="value">this is irrelevant, since it will always throw!</param>
    </member>
    <member name="M:Ionic.Zlib.GZipStream.Write(System.Byte[],System.Int32,System.Int32)">
      <summary>
            Write data to the stream. 
            </summary>
      <remarks>
        <para>
            If you wish to use the GZipStream to compress data while writing, you can create a
            GZipStream with CompressionMode.Compress, and a writable output stream.  Then call
            Write() on that GZipStream, providing uncompressed data as input.  The data sent
            to the output stream will be the compressed form of the data written.  
            </para>
        <para>
            A GZipStream can be used for Read() or Write(), but not both. Writing implies compression. 
            Reading implies decompression.
            </para>
      </remarks>
      <param name="buffer">The buffer holding data to write to the stream.</param>
      <param name="offset">the offset within that data array to find the first byte to write.</param>
      <param name="count">the number of bytes to write.</param>
    </member>
    <member name="P:Ionic.Zlib.GZipStream.Comment">
      <summary>
             The Comment on the GZIP stream.
             </summary>
      <remarks>
        <para>
             The GZIP format allows for each file to optionally have an associated comment stored with the
             file.  The comment is encoded with the ISO-8859-1 code page.  To include a comment in
             a GZIP stream you create, set this property before calling Write() for the first time
             on the GZipStream.  
             </para>
        <para>
             When using GZipStream to decompress, you can retrieve this property after the first
             call to Read().  If no comment has been set in the GZIP bytestream, the Comment
             property will return null (Nothing in VB).
             </para>
      </remarks>
    </member>
    <member name="P:Ionic.Zlib.GZipStream.FileName">
      <summary>
            The FileName for the GZIP stream.
            </summary>
      <remarks>
        <para>
            The GZIP format optionally allows each file to have an associated filename.  When
            compressing data (through Write()), set this FileName before calling Write() the first
            time on the GZipStream.  The actual filename is encoded into the GZIP bytestream with
            the ISO-8859-1 code page, according to RFC 1952. It is the application's responsibility to 
            insure that the FileName can be encoded and decoded correctly with this code page. 
            </para>
        <para>
            When decompressing (through Read()), you can retrieve this value any time after the
            first Read().  In the case where there was no filename encoded into the GZIP
            bytestream, the property will return null (Nothing in VB).
            </para>
      </remarks>
    </member>
    <member name="P:Ionic.Zlib.GZipStream.Crc32">
      <summary>
            The CRC on the GZIP stream. 
            </summary>
      <remarks>
            This is used for internal error checking. You probably don't need to look at this property.
            </remarks>
    </member>
    <member name="P:Ionic.Zlib.GZipStream.FlushMode">
      <summary>
            This property sets the flush behavior on the stream.  
            </summary>
    </member>
    <member name="P:Ionic.Zlib.GZipStream.BufferSize">
      <summary>
             The size of the working buffer for the compression codec. 
             </summary>
      <remarks>
        <para>
             The working buffer is used for all stream operations.  The default size is 1024 bytes.
             The minimum size is 128 bytes. You may get better performance with a larger buffer.
             Then again, you might not.  You would have to test it.
             </para>
        <para>
             Set this before the first call to Read()  or Write() on the stream. If you try to set it 
             afterwards, it will throw.
             </para>
      </remarks>
    </member>
    <member name="P:Ionic.Zlib.GZipStream.TotalIn">
      <summary> Returns the total number of bytes input so far.</summary>
    </member>
    <member name="P:Ionic.Zlib.GZipStream.TotalOut">
      <summary> Returns the total number of bytes output so far.</summary>
    </member>
    <member name="P:Ionic.Zlib.GZipStream.CanRead">
      <summary>
            Indicates whether the stream can be read.
            </summary>
      <remarks>
            The return value depends on whether the captive stream supports reading.
            </remarks>
    </member>
    <member name="P:Ionic.Zlib.GZipStream.CanSeek">
      <summary>
            Indicates whether the stream supports Seek operations.
            </summary>
      <remarks>
            Always returns false.
            </remarks>
    </member>
    <member name="P:Ionic.Zlib.GZipStream.CanWrite">
      <summary>
            Indicates whether the stream can be written.
            </summary>
      <remarks>
            The return value depends on whether the captive stream supports writing.
            </remarks>
    </member>
    <member name="P:Ionic.Zlib.GZipStream.Length">
      <summary>
            Reading this property always throws a NotImplementedException.
            </summary>
    </member>
    <member name="P:Ionic.Zlib.GZipStream.Position">
      <summary>
            The position of the stream pointer. 
            </summary>
      <remarks>
            Writing this property always throws a NotImplementedException. Reading will
            return the total bytes written out, if used in writing, or the total bytes 
            read in, if used in reading.   The count may refer to compressed bytes or 
            uncompressed bytes, depending on how you've used the stream.
            </remarks>
    </member>
    <member name="T:Ionic.Zlib.ZlibConstants">
      <summary>
            A bunch of constants used in the Zlib interface.
            </summary>
    </member>
    <member name="F:Ionic.Zlib.ZlibConstants.WindowBitsMax">
      <summary>
            The maximum number of window bits for the Deflate algorithm.
            </summary>
    </member>
    <member name="F:Ionic.Zlib.ZlibConstants.WindowBitsDefault">
      <summary>
            The default number of window bits for the Deflate algorithm.
            </summary>
    </member>
    <member name="F:Ionic.Zlib.ZlibConstants.Z_OK">
      <summary>
            indicates everything is A-OK
            </summary>
    </member>
    <member name="F:Ionic.Zlib.ZlibConstants.Z_STREAM_END">
      <summary>
            Indicates that the last operation reached the end of the stream.
            </summary>
    </member>
    <member name="F:Ionic.Zlib.ZlibConstants.Z_NEED_DICT">
      <summary>
            The operation ended in need of a dictionary. 
            </summary>
    </member>
    <member name="F:Ionic.Zlib.ZlibConstants.Z_STREAM_ERROR">
      <summary>
            There was an error with the stream - not enough data, not open and readable, etc.
            </summary>
    </member>
    <member name="F:Ionic.Zlib.ZlibConstants.Z_DATA_ERROR">
      <summary>
            There was an error with the data - not enough data, bad data, etc.
            </summary>
    </member>
    <member name="F:Ionic.Zlib.ZlibConstants.Z_BUF_ERROR">
      <summary>
            There was an error with the working buffer.
            </summary>
    </member>
    <member name="F:Ionic.Zlib.ZlibConstants.WorkingBufferSizeDefault">
      <summary>
            The size of the working buffer used in the ZlibCodec class. Defaults to 8192 bytes.
            </summary>
    </member>
    <member name="F:Ionic.Zlib.ZlibConstants.WorkingBufferSizeMin">
      <summary>
            The minimum size of the working buffer used in the ZlibCodec class.  Currently it is 128 bytes.
            </summary>
    </member>
    <member name="T:Ionic.Zlib.FlushType">
      <summary>
            Describes how to flush the current deflate operation. 
            </summary>
      <remarks>
            The different FlushType values are useful when using a Deflate in a streaming application.
            </remarks>
    </member>
    <member name="F:Ionic.Zlib.FlushType.None">
      <summary>No flush at all.</summary>
    </member>
    <member name="F:Ionic.Zlib.FlushType.Partial">
      <summary>Closes the current block, but doesn't flush it to
            the output. Used internally only in hypothetical
            scenarios.  This was supposed to be removed by Zlib, but it is
            still in use in some edge cases. 
            </summary>
    </member>
    <member name="F:Ionic.Zlib.FlushType.Sync">
      <summary>
            Use this during compression to specify that all pending output should be
            flushed to the output buffer and the output should be aligned on a byte
            boundary.  You might use this in a streaming communication scenario, so that
            the decompressor can get all input data available so far.  When using this
            with a ZlibCodec, <c>AvailableBytesIn</c> will be zero after the call if
            enough output space has been provided before the call.  Flushing will
            degrade compression and so it should be used only when necessary.
            </summary>
    </member>
    <member name="F:Ionic.Zlib.FlushType.Full">
      <summary>
            Use this during compression to specify that all output should be flushed, as
            with <c>FlushType.Sync</c>, but also, the compression state should be reset
            so that decompression can restart from this point if previous compressed
            data has been damaged or if random access is desired.  Using
            <c>FlushType.Full</c> too often can significantly degrade the compression.
            </summary>
    </member>
    <member name="F:Ionic.Zlib.FlushType.Finish">
      <summary>Signals the end of the compression/decompression stream.</summary>
    </member>
    <member name="T:Ionic.Zlib.CompressionLevel">
      <summary>
            The compression level to be used when using a DeflateStream or ZlibStream with CompressionMode.Compress.
            </summary>
    </member>
    <member name="F:Ionic.Zlib.CompressionLevel.None">
      <summary>
            None means that the data will be simply stored, with no change at all.
            </summary>
    </member>
    <member name="F:Ionic.Zlib.CompressionLevel.Level0">
      <summary>
            Same as None.
            </summary>
    </member>
    <member name="F:Ionic.Zlib.CompressionLevel.BestSpeed">
      <summary>
            The fastest but least effective compression.
            </summary>
    </member>
    <member name="F:Ionic.Zlib.CompressionLevel.Level1">
      <summary>
            A synonym for BestSpeed.
            </summary>
    </member>
    <member name="F:Ionic.Zlib.CompressionLevel.Level2">
      <summary>
            A little slower, but better, than level 1.
            </summary>
    </member>
    <member name="F:Ionic.Zlib.CompressionLevel.Level3">
      <summary>
            A little slower, but better, than level 2.
            </summary>
    </member>
    <member name="F:Ionic.Zlib.CompressionLevel.LevelL4">
      <summary>
            A little slower, but better, than level 3.
            </summary>
    </member>
    <member name="F:Ionic.Zlib.CompressionLevel.Level5">
      <summary>
            A little slower than level 4, but with better compression.
            </summary>
    </member>
    <member name="F:Ionic.Zlib.CompressionLevel.Default">
      <summary>
            The default compression level, with a good balance of speed and compression efficiency.   
            </summary>
    </member>
    <member name="F:Ionic.Zlib.CompressionLevel.Level6">
      <summary>
            A synonym for Default.
            </summary>
    </member>
    <member name="F:Ionic.Zlib.CompressionLevel.Level7">
      <summary>
            Pretty good compression!
            </summary>
    </member>
    <member name="F:Ionic.Zlib.CompressionLevel.Level8">
      <summary>
             Better compression than Level7!
            </summary>
    </member>
    <member name="F:Ionic.Zlib.CompressionLevel.BestCompression">
      <summary>
            The "best" compression, where best means greatest reduction in size of the input data stream. 
            This is also the slowest compression.
            </summary>
    </member>
    <member name="F:Ionic.Zlib.CompressionLevel.Level9">
      <summary>
            A synonym for BestCompression.
            </summary>
    </member>
    <member name="T:Ionic.Zlib.CompressionStrategy">
      <summary>
            Describes options for how the compression algorithm is executed.  Different strategies
            work better on different sorts of data.  The strategy parameter can affect the compression
            ratio and the speed of compression but not the correctness of the compresssion.
            </summary>
    </member>
    <member name="F:Ionic.Zlib.CompressionStrategy.Default">
      <summary>
            The default strategy is probably the best for normal data. 
            </summary>
    </member>
    <member name="F:Ionic.Zlib.CompressionStrategy.Filtered">
      <summary>
            The <c>Filtered</c> strategy is intended to be used most effectively with data produced by a
            filter or predictor.  By this definition, filtered data consists mostly of small
            values with a somewhat random distribution.  In this case, the compression algorithm
            is tuned to compress them better.  The effect of <c>Filtered</c> is to force more Huffman
            coding and less string matching; it is a half-setp between <c>Default</c> and <c>HuffmanOnly</c>.
            </summary>
    </member>
    <member name="F:Ionic.Zlib.CompressionStrategy.HuffmanOnly">
      <summary>
            Using <c>HuffmanOnly</c> will force the compressor to do Huffman encoding only, with no
            string matching.
            </summary>
    </member>
    <member name="T:Ionic.Zlib.CompressionMode">
      <summary>
            An enum to specify the direction of transcoding - whether to compress or decompress.
            </summary>
    </member>
    <member name="F:Ionic.Zlib.CompressionMode.Compress">
      <summary>
            Used to specify that the stream should compress the data.
            </summary>
    </member>
    <member name="F:Ionic.Zlib.CompressionMode.Decompress">
      <summary>
            Used to specify that the stream should decompress the data.
            </summary>
    </member>
    <member name="T:Ionic.Zlib.ZlibException">
      <summary>
            A general purpose exception class for exceptions in the Zlib library.
            </summary>
    </member>
    <member name="M:Ionic.Zlib.ZlibException.#ctor">
      <summary>
            The ZlibException class captures exception information generated
            by the Zlib library. 
            </summary>
    </member>
    <member name="M:Ionic.Zlib.ZlibException.#ctor(System.String)">
      <summary>
            This ctor collects a message attached to the exception.
            </summary>
      <param name="s">
      </param>
    </member>
    <member name="M:Ionic.Zlib.SharedUtils.URShift(System.Int32,System.Int32)">
      <summary>
            Performs an unsigned bitwise right shift with the specified number
            </summary>
      <param name="number">Number to operate on</param>
      <param name="bits">Ammount of bits to shift</param>
      <returns>The resulting number from the shift operation</returns>
    </member>
    <member name="M:Ionic.Zlib.SharedUtils.URShift(System.Int64,System.Int32)">
      <summary>
            Performs an unsigned bitwise right shift with the specified number
            </summary>
      <param name="number">Number to operate on</param>
      <param name="bits">Ammount of bits to shift</param>
      <returns>The resulting number from the shift operation</returns>
    </member>
    <member name="M:Ionic.Zlib.SharedUtils.ReadInput(System.IO.TextReader,System.Byte[],System.Int32,System.Int32)">
      <summary>Reads a number of characters from the current source TextReader and writes the data to the target array at the specified index.</summary>
      <param name="sourceTextReader">The source TextReader to read from</param>
      <param name="target">Contains the array of characteres read from the source TextReader.</param>
      <param name="start">The starting index of the target array.</param>
      <param name="count">The maximum number of characters to read from the source TextReader.</param>
      <returns>The number of characters read. The number will be less than or equal to count depending on the data available in the source TextReader. Returns -1 if the end of the stream is reached.</returns>
    </member>
    <member name="T:Ionic.Zlib.Adler">
      <summary>
            Computes an Adler-32 checksum. 
            </summary>
      <remarks>
            The Adler checksum is similar to a CRC checksum, but faster to compute, though less
            reliable.  It is used in producing RFC1950 compressed streams.  The Adler checksum
            is a required part of the "ZLIB" standard.  Applications will almost never need to
            use this class directly.
            </remarks>
    </member>
    <member name="T:Ionic.Zlib.ZlibStream">
      <summary>
             Represents a Zlib stream for compression or decompression.
             </summary>
      <remarks>
        <para>
             The ZlibStream is a <see href="http://en.wikipedia.org/wiki/Decorator_pattern">Decorator</see> on a <see cref="T:System.IO.Stream" />.  It adds ZLIB compression or decompression to any
             stream.
             </para>
        <para> Using this stream, applications can compress or decompress data via
             stream <c>Read</c> and <c>Write</c> operations.  Either compresssion or
             decompression can occur through either reading or writing. The compression
             format used is ZLIB, which is documented in <see href="http://www.ietf.org/rfc/rfc1950.txt">IETF RFC 1950</see>, "ZLIB Compressed
             Data Format Specification version 3.3". This implementation of ZLIB always uses
             DEFLATE as the compression method.  (see <see href="http://www.ietf.org/rfc/rfc1951.txt">IETF RFC 1951</see>, "DEFLATE
             Compressed Data Format Specification version 1.3.") </para>
        <para>
             The ZLIB format allows for varying compression methods, window sizes, and dictionaries.
             This implementation always uses the DEFLATE compression method, a preset dictionary,
             and 15 window bits by default.  
             </para>
        <para>
             This class is similar to <see cref="T:Ionic.Zlib.DeflateStream" />, except that it adds the
             RFC1950 header and trailer bytes to a compressed stream when compressing, or expects
             the RFC1950 header and trailer bytes when decompressing.  It is also similar to the
             <see cref="T:Ionic.Zlib.GZipStream" />.
             </para>
      </remarks>
      <seealso cref="T:Ionic.Zlib.DeflateStream" />
      <seealso cref="T:Ionic.Zlib.GZipStream" />
    </member>
    <member name="M:Ionic.Zlib.ZlibStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode)">
      <summary>
             Create a ZlibStream using the specified CompressionMode.
             </summary>
      <remarks>
        <para> When mode is <c>CompressionMode.Compress</c>, the ZlibStream will use
             the default compression level. The "captive" stream will be closed when the
             ZlibStream is closed.</para>
      </remarks>
      <example>
             This example uses a ZlibStream to compress a file, and writes the compressed 
             data to another file.
             <code>
             using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
             {
                 using (var raw = System.IO.File.Create(fileToCompress + ".zlib"))
                 {
                     using (Stream compressor = new ZlibStream(raw, CompressionMode.Compress))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n;
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             compressor.Write(buffer, 0, n);
                         }
                     }
                 }
             }
             </code><code lang="VB">
             Using input As Stream = File.OpenRead(fileToCompress)
                 Using raw As FileStream = File.Create(fileToCompress &amp; ".zlib")
                 Using compressor As Stream = New ZlibStream(raw, CompressionMode.Compress)
                     Dim buffer As Byte() = New Byte(4096) {}
                     Dim n As Integer = -1
                     Do While (n &lt;&gt; 0)
                         If (n &gt; 0) Then
                             compressor.Write(buffer, 0, n)
                         End If
                         n = input.Read(buffer, 0, buffer.Length)
                     Loop
                 End Using
                 End Using
             End Using
             </code></example>
      <param name="stream">The stream which will be read or written.</param>
      <param name="mode">Indicates whether the ZlibStream will compress or decompress.</param>
    </member>
    <member name="M:Ionic.Zlib.ZlibStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode,Ionic.Zlib.CompressionLevel)">
      <summary>
             Create a ZlibStream using the specified CompressionMode and the specified CompressionLevel.
             </summary>
      <remarks>
        <para>
             When mode is <c>CompressionMode.Decompress</c>, the level parameter is ignored.
             The "captive" stream will be closed when the ZlibStream is closed.
             </para>
      </remarks>
      <example>
             This example uses a ZlibStream to compress data from a file, and writes the
             compressed data to another file.
             <code>
             using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
             {
                 using (var raw = System.IO.File.Create(fileToCompress + ".zlib"))
                 {
                     using (Stream compressor = new ZlibStream(raw,
                                                               CompressionMode.Compress, 
                                                               CompressionLevel.BestCompression))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n;
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             compressor.Write(buffer, 0, n);
                         }
                     }
                 }
             }
             </code><code lang="VB">
             Using input As Stream = File.OpenRead(fileToCompress)
                 Using raw As FileStream = File.Create(fileToCompress &amp; ".zlib")
                     Using compressor As Stream = New ZlibStream(raw, CompressionMode.Compress, CompressionLevel.BestCompression)
                         Dim buffer As Byte() = New Byte(4096) {}
                         Dim n As Integer = -1
                         Do While (n &lt;&gt; 0)
                             If (n &gt; 0) Then
                                 compressor.Write(buffer, 0, n)
                             End If
                             n = input.Read(buffer, 0, buffer.Length)
                         Loop
                     End Using
                 End Using
             End Using
             </code></example>
      <param name="stream">The stream to be read or written while deflating or inflating.</param>
      <param name="mode">Indicates whether the ZlibStream will compress or decompress.</param>
      <param name="level">A tuning knob to trade speed for effectiveness.</param>
    </member>
    <member name="M:Ionic.Zlib.ZlibStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode,System.Boolean)">
      <summary>
             Create a ZlibStream using the specified CompressionMode, and explicitly specify 
             whether the captive stream should be left open after Deflation or Inflation.
             </summary>
      <remarks>
        <para> When mode is <c>CompressionMode.Compress</c>, the ZlibStream will use
             the default compression level.  </para>
        <para>
             This constructor allows the application to request that the captive stream
             remain open after the deflation or inflation occurs.  By default, after Close()
             is called on the stream, the captive stream is also closed. In some cases this
             is not desired, for example if the stream is a <see cref="T:System.IO.MemoryStream" /> that will be re-read after compression.  Specify
             true for the leaveOpen parameter to leave the stream open.
             </para>
        <para>
             See the other overloads of this constructor for example code.
             </para>
      </remarks>
      <param name="stream">The stream which will be read or written. This is called the 
             "captive" stream in other places in this documentation.</param>
      <param name="mode">Indicates whether the ZlibStream will compress or decompress.</param>
      <param name="leaveOpen">true if the application would like the stream to remain
             open after inflation/deflation.</param>
    </member>
    <member name="M:Ionic.Zlib.ZlibStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode,Ionic.Zlib.CompressionLevel,System.Boolean)">
      <summary>
             Create a ZlibStream using the specified CompressionMode and the specified
             CompressionLevel, and explicitly specify whether the stream should be left open
             after Deflation or Inflation.
             </summary>
      <remarks>
        <para>
             This constructor allows the application to request that the captive stream
             remain open after the deflation or inflation occurs.  By default, after Close()
             is called on the stream, the captive stream is also closed. In some cases this
             is not desired, for example if the stream is a <see cref="T:System.IO.MemoryStream" /> that will be re-read after compression.  Specify
             true for the leaveOpen parameter to leave the stream open.
             </para>
        <para>
             When mode is <c>CompressionMode.Decompress</c>, the level parameter is ignored. 
             </para>
      </remarks>
      <example>
             This example shows how to use a ZlibStream to compress the data from a file,
             and store the result into another file. The filestream remains open to allow
             additional data to be written to it.
             <code>
             using (var output = System.IO.File.Create(fileToCompress + ".zlib"))
             {
                 using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
                 {
                     using (Stream compressor = new ZlibStream(output, CompressionMode.Compress, CompressionLevel.BestCompression, true))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n;
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             compressor.Write(buffer, 0, n);
                         }
                     }
                 }
                 // can write additional data to the output stream here
             }
             </code><code lang="VB">
             Using output As FileStream = File.Create(fileToCompress &amp; ".zlib")
                 Using input As Stream = File.OpenRead(fileToCompress)
                     Using compressor As Stream = New ZlibStream(output, CompressionMode.Compress, CompressionLevel.BestCompression, True)
                         Dim buffer As Byte() = New Byte(4096) {}
                         Dim n As Integer = -1
                         Do While (n &lt;&gt; 0)
                             If (n &gt; 0) Then
                                 compressor.Write(buffer, 0, n)
                             End If
                             n = input.Read(buffer, 0, buffer.Length)
                         Loop
                     End Using
                 End Using
                 ' can write additional data to the output stream here.
             End Using
             </code></example>
      <param name="stream">The stream which will be read or written.</param>
      <param name="mode">Indicates whether the ZlibStream will compress or decompress.</param>
      <param name="leaveOpen">
             true if the application would like the stream to remain open after inflation/deflation.
             </param>
      <param name="level">
             A tuning knob to trade speed for effectiveness. This parameter is effective only when
             mode is <c>CompressionMode.Compress</c>.
             </param>
    </member>
    <member name="M:Ionic.Zlib.ZlibStream.Dispose(System.Boolean)">
      <summary>
            Dispose the stream.  
            </summary>
      <remarks>
            This may or may not result in a Close() call on the captive stream. 
            See the constructors that have a leaveOpen parameter for more information.
            </remarks>
    </member>
    <member name="M:Ionic.Zlib.ZlibStream.Flush">
      <summary>
            Flush the stream.
            </summary>
    </member>
    <member name="M:Ionic.Zlib.ZlibStream.Read(System.Byte[],System.Int32,System.Int32)">
      <summary>
             Read data from the stream. 
             </summary>
      <remarks>
        <para>
             If you wish to use the ZlibStream to compress data while reading, you can create a
             ZlibStream with CompressionMode.Compress, providing an uncompressed data stream.  Then
             call Read() on that ZlibStream, and the data read will be compressed.  If you wish to
             use the ZlibStream to decompress data while reading, you can create a ZlibStream with
             CompressionMode.Decompress, providing a readable compressed data stream.  Then call
             Read() on that ZlibStream, and the data will be decompressed as it is read.
             </para>
        <para>
             A ZlibStream can be used for Read() or Write(), but not both. 
             </para>
      </remarks>
      <param name="buffer">The buffer into which the read data should be placed.</param>
      <param name="offset">the offset within that data array to put the first byte read.</param>
      <param name="count">the number of bytes to read.</param>
    </member>
    <member name="M:Ionic.Zlib.ZlibStream.Seek(System.Int64,System.IO.SeekOrigin)">
      <summary>
            Calling this method always throws a NotImplementedException.
            </summary>
    </member>
    <member name="M:Ionic.Zlib.ZlibStream.SetLength(System.Int64)">
      <summary>
            Calling this method always throws a NotImplementedException.
            </summary>
    </member>
    <member name="M:Ionic.Zlib.ZlibStream.Write(System.Byte[],System.Int32,System.Int32)">
      <summary>
             Write data to the stream. 
             </summary>
      <remarks>
        <para>
             If you wish to use the ZlibStream to compress data while writing, you can create a
             ZlibStream with CompressionMode.Compress, and a writable output stream.  Then call
             Write() on that ZlibStream, providing uncompressed data as input.  The data sent to
             the output stream will be the compressed form of the data written.  If you wish to use
             the ZlibStream to decompress data while writing, you can create a ZlibStream with
             CompressionMode.Decompress, and a writable output stream.  Then call Write() on that
             stream, providing previously compressed data. The data sent to the output stream will
             be the decompressed form of the data written.
             </para>
        <para>
             A ZlibStream can be used for Read() or Write(), but not both. 
             </para>
      </remarks>
      <param name="buffer">The buffer holding data to write to the stream.</param>
      <param name="offset">the offset within that data array to find the first byte to write.</param>
      <param name="count">the number of bytes to write.</param>
    </member>
    <member name="P:Ionic.Zlib.ZlibStream.FlushMode">
      <summary>
            This property sets the flush behavior on the stream.  
            Sorry, though, not sure exactly how to describe all the various settings.
            </summary>
    </member>
    <member name="P:Ionic.Zlib.ZlibStream.BufferSize">
      <summary>
             The size of the working buffer for the compression codec. 
             </summary>
      <remarks>
        <para>
             The working buffer is used for all stream operations.  The default size is 1024 bytes.
             The minimum size is 128 bytes. You may get better performance with a larger buffer.
             Then again, you might not.  You would have to test it.
             </para>
        <para>
             Set this before the first call to Read()  or Write() on the stream. If you try to set it 
             afterwards, it will throw.
             </para>
      </remarks>
    </member>
    <member name="P:Ionic.Zlib.ZlibStream.TotalIn">
      <summary> Returns the total number of bytes input so far.</summary>
    </member>
    <member name="P:Ionic.Zlib.ZlibStream.TotalOut">
      <summary> Returns the total number of bytes output so far.</summary>
    </member>
    <member name="P:Ionic.Zlib.ZlibStream.CanRead">
      <summary>
            Indicates whether the stream can be read.
            </summary>
      <remarks>
            The return value depends on whether the captive stream supports reading.
            </remarks>
    </member>
    <member name="P:Ionic.Zlib.ZlibStream.CanSeek">
      <summary>
            Indicates whether the stream supports Seek operations.
            </summary>
      <remarks>
            Always returns false.
            </remarks>
    </member>
    <member name="P:Ionic.Zlib.ZlibStream.CanWrite">
      <summary>
            Indicates whether the stream can be written.
            </summary>
      <remarks>
            The return value depends on whether the captive stream supports writing.
            </remarks>
    </member>
    <member name="P:Ionic.Zlib.ZlibStream.Length">
      <summary>
            Reading this property always throws a NotImplementedException.
            </summary>
    </member>
    <member name="P:Ionic.Zlib.ZlibStream.Position">
      <summary>
            The position of the stream pointer. 
            </summary>
      <remarks>
            Writing this property always throws a NotImplementedException. Reading will
            return the total bytes written out, if used in writing, or the total bytes 
            read in, if used in reading.   The count may refer to compressed bytes or 
            uncompressed bytes, depending on how you've used the stream.
            </remarks>
    </member>
    <member name="T:Ionic.Zlib.ZlibCodec">
      <summary>
             Encoder and Decoder for ZLIB and DEFLATE (IETF RFC1950 and RFC1951).
             </summary>
      <remarks>
             This class compresses and decompresses data according to the Deflate algorithm
             and optionally, the ZLIB format, as documented in <see href="http://www.ietf.org/rfc/rfc1950.txt">RFC 1950 - ZLIB</see> and <see href="http://www.ietf.org/rfc/rfc1951.txt">RFC 1951 - DEFLATE</see>.
             </remarks>
    </member>
    <member name="F:Ionic.Zlib.ZlibCodec.InputBuffer">
      <summary>
            The buffer from which data is taken.
            </summary>
    </member>
    <member name="F:Ionic.Zlib.ZlibCodec.NextIn">
      <summary>
            An index into the InputBuffer array, indicating where to start reading. 
            </summary>
    </member>
    <member name="F:Ionic.Zlib.ZlibCodec.AvailableBytesIn">
      <summary>
            The number of bytes available in the InputBuffer, starting at NextIn. 
            </summary>
      <remarks>
            Generally you should set this to InputBuffer.Length before the first Inflate() or Deflate() call. 
            The class will update this number as calls to Inflate/Deflate are made.
            </remarks>
    </member>
    <member name="F:Ionic.Zlib.ZlibCodec.TotalBytesIn">
      <summary>
            Total number of bytes read so far, through all calls to Inflate()/Deflate().
            </summary>
    </member>
    <member name="F:Ionic.Zlib.ZlibCodec.OutputBuffer">
      <summary>
            Buffer to store output data.
            </summary>
    </member>
    <member name="F:Ionic.Zlib.ZlibCodec.NextOut">
      <summary>
            An index into the OutputBuffer array, indicating where to start writing. 
            </summary>
    </member>
    <member name="F:Ionic.Zlib.ZlibCodec.AvailableBytesOut">
      <summary>
            The number of bytes available in the OutputBuffer, starting at NextOut. 
            </summary>
      <remarks>
            Generally you should set this to OutputBuffer.Length before the first Inflate() or Deflate() call. 
            The class will update this number as calls to Inflate/Deflate are made.
            </remarks>
    </member>
    <member name="F:Ionic.Zlib.ZlibCodec.TotalBytesOut">
      <summary>
            Total number of bytes written to the output so far, through all calls to Inflate()/Deflate().
            </summary>
    </member>
    <member name="F:Ionic.Zlib.ZlibCodec.Message">
      <summary>
            used for diagnostics, when something goes wrong!
            </summary>
    </member>
    <member name="F:Ionic.Zlib.ZlibCodec.CompressLevel">
      <summary>
            The compression level to use in this codec.  Useful only in compression mode.
            </summary>
    </member>
    <member name="F:Ionic.Zlib.ZlibCodec.WindowBits">
      <summary>
            The number of Window Bits to use.  
            </summary>
      <remarks>
            This gauges the size of the sliding window, and hence the 
            compression effectiveness as well as memory consumption. It's best to just leave this 
            setting alone if you don't know what it is.  The maximum value is 15 bits, which implies
            a 32k window.  
            </remarks>
    </member>
    <member name="F:Ionic.Zlib.ZlibCodec.Strategy">
      <summary>
            The compression strategy to use.
            </summary>
      <remarks>
            This is only effective in compression.  The theory offered by ZLIB is that different
            strategies could potentially produce significant differences in compression behavior
            for different data sets.  Unfortunately I don't have any good recommendations for how
            to set it differently.  When I tested changing the strategy I got minimally different
            compression performance. It's best to leave this property alone if you don't have a
            good feel for it.  Or, you may want to produce a test harness that runs through the
            different strategy options and evaluates them on different file types. If you do that,
            let me know your results.
            </remarks>
    </member>
    <member name="M:Ionic.Zlib.ZlibCodec.#ctor">
      <summary>
            Create a ZlibCodec.
            </summary>
      <remarks>
            If you use this default constructor, you will later have to explicitly call 
            InitializeInflate() or InitializeDeflate() before using the ZlibCodec to compress 
            or decompress. 
            </remarks>
    </member>
    <member name="M:Ionic.Zlib.ZlibCodec.#ctor(Ionic.Zlib.CompressionMode)">
      <summary>
            Create a ZlibCodec that either compresses or decompresses.
            </summary>
      <param name="mode">
            Indicates whether the codec should compress (deflate) or decompress (inflate).
            </param>
    </member>
    <member name="M:Ionic.Zlib.ZlibCodec.InitializeInflate">
      <summary>
            Initialize the inflation state. 
            </summary>
      <remarks>
            It is not necessary to call this before using the ZlibCodec to inflate data; 
            It is implicitly called when you call the constructor.
            </remarks>
      <returns>Z_OK if everything goes well.</returns>
    </member>
    <member name="M:Ionic.Zlib.ZlibCodec.InitializeInflate(System.Boolean)">
      <summary>
             Initialize the inflation state with an explicit flag to
             govern the handling of RFC1950 header bytes.
             </summary>
      <remarks>
             By default, the ZLIB header defined in <see href="http://www.ietf.org/rfc/rfc1950.txt">RFC 1950</see> is expected.  If
             you want to read a zlib stream you should specify true for
             expectRfc1950Header.  If you have a deflate stream, you will want to specify
             false. It is only necessary to invoke this initializer explicitly if you
             want to specify false.
             </remarks>
      <param name="expectRfc1950Header">whether to expect an RFC1950 header byte
             pair when reading the stream of data to be inflated.</param>
      <returns>Z_OK if everything goes well.</returns>
    </member>
    <member name="M:Ionic.Zlib.ZlibCodec.InitializeInflate(System.Int32)">
      <summary>
            Initialize the ZlibCodec for inflation, with the specified number of window bits. 
            </summary>
      <param name="windowBits">The number of window bits to use. If you need to ask what that is, 
            then you shouldn't be calling this initializer.</param>
      <returns>Z_OK if all goes well.</returns>
    </member>
    <member name="M:Ionic.Zlib.ZlibCodec.InitializeInflate(System.Int32,System.Boolean)">
      <summary>
             Initialize the inflation state with an explicit flag to govern the handling of
             RFC1950 header bytes. 
             </summary>
      <remarks>
             If you want to read a zlib stream you should specify true for
             expectRfc1950Header. In this case, the library will expect to find a ZLIB
             header, as defined in <see href="http://www.ietf.org/rfc/rfc1950.txt">RFC
             1950</see>, in the compressed stream.  If you will be reading a DEFLATE or
             GZIP stream, which does not have such a header, you will want to specify
             false.
             </remarks>
      <param name="expectRfc1950Header">whether to expect an RFC1950 header byte pair when reading 
             the stream of data to be inflated.</param>
      <param name="windowBits">The number of window bits to use. If you need to ask what that is, 
             then you shouldn't be calling this initializer.</param>
      <returns>Z_OK if everything goes well.</returns>
    </member>
    <member name="M:Ionic.Zlib.ZlibCodec.Inflate(Ionic.Zlib.FlushType)">
      <summary>
             Inflate the data in the InputBuffer, placing the result in the OutputBuffer.
             </summary>
      <remarks>
             You must have set InputBuffer and OutputBuffer, NextIn and NextOut, and AvailableBytesIn and 
             AvailableBytesOut  before calling this method.
             </remarks>
      <example>
        <code>
             private void InflateBuffer()
             {
                 int bufferSize = 1024;
                 byte[] buffer = new byte[bufferSize];
                 ZlibCodec decompressor = new ZlibCodec();
             
                 Console.WriteLine("\n============================================");
                 Console.WriteLine("Size of Buffer to Inflate: {0} bytes.", CompressedBytes.Length);
                 MemoryStream ms = new MemoryStream(DecompressedBytes);
             
                 int rc = decompressor.InitializeInflate();
             
                 decompressor.InputBuffer = CompressedBytes;
                 decompressor.NextIn = 0;
                 decompressor.AvailableBytesIn = CompressedBytes.Length;
             
                 decompressor.OutputBuffer = buffer;
             
                 // pass 1: inflate 
                 do
                 {
                     decompressor.NextOut = 0;
                     decompressor.AvailableBytesOut = buffer.Length;
                     rc = decompressor.Inflate(ZlibConstants.Z_NO_FLUSH);
             
                     if (rc != ZlibConstants.Z_OK &amp;&amp; rc != ZlibConstants.Z_STREAM_END)
                         throw new Exception("inflating: " + decompressor.Message);
             
                     ms.Write(decompressor.OutputBuffer, 0, buffer.Length - decompressor.AvailableBytesOut);
                 }
                 while (decompressor.AvailableBytesIn &gt; 0 || decompressor.AvailableBytesOut == 0);
             
                 // pass 2: finish and flush
                 do
                 {
                     decompressor.NextOut = 0;
                     decompressor.AvailableBytesOut = buffer.Length;
                     rc = decompressor.Inflate(ZlibConstants.Z_FINISH);
             
                     if (rc != ZlibConstants.Z_STREAM_END &amp;&amp; rc != ZlibConstants.Z_OK)
                         throw new Exception("inflating: " + decompressor.Message);
             
                     if (buffer.Length - decompressor.AvailableBytesOut &gt; 0)
                         ms.Write(buffer, 0, buffer.Length - decompressor.AvailableBytesOut);
                 }
                 while (decompressor.AvailableBytesIn &gt; 0 || decompressor.AvailableBytesOut == 0);
             
                 decompressor.EndInflate();
             }
            
             </code>
      </example>
      <param name="flush">The flush to use when inflating.</param>
      <returns>Z_OK if everything goes well.</returns>
    </member>
    <member name="M:Ionic.Zlib.ZlibCodec.EndInflate">
      <summary>
            Ends an inflation session. 
            </summary>
      <remarks>
            Call this after successively calling Inflate().  This will cause all buffers to be flushed. 
            After calling this you cannot call Inflate() without a intervening call to one of the
            InitializeInflate() overloads.
            </remarks>
      <returns>Z_OK if everything goes well.</returns>
    </member>
    <member name="M:Ionic.Zlib.ZlibCodec.SyncInflate">
      <summary>
            I don't know what this does!
            </summary>
      <returns>Z_OK if everything goes well.</returns>
    </member>
    <member name="M:Ionic.Zlib.ZlibCodec.InitializeDeflate">
      <summary>
            Initialize the ZlibCodec for deflation operation.
            </summary>
      <remarks>
            The codec will use the MAX window bits and the default level of compression.
            </remarks>
      <example>
        <code>
             int bufferSize = 40000;
             byte[] CompressedBytes = new byte[bufferSize];
             byte[] DecompressedBytes = new byte[bufferSize];
             
             ZlibCodec compressor = new ZlibCodec();
             
             compressor.InitializeDeflate(CompressionLevel.Default);
             
             compressor.InputBuffer = System.Text.ASCIIEncoding.ASCII.GetBytes(TextToCompress);
             compressor.NextIn = 0;
             compressor.AvailableBytesIn = compressor.InputBuffer.Length;
             
             compressor.OutputBuffer = CompressedBytes;
             compressor.NextOut = 0;
             compressor.AvailableBytesOut = CompressedBytes.Length;
             
             while (compressor.TotalBytesIn != TextToCompress.Length &amp;&amp; compressor.TotalBytesOut &lt; bufferSize)
             {
               compressor.Deflate(ZlibConstants.Z_NO_FLUSH);
             }
             
             while (true)
             {
               int rc= compressor.Deflate(ZlibConstants.Z_FINISH);
               if (rc == ZlibConstants.Z_STREAM_END) break;
             }
             
             compressor.EndDeflate();
              
            </code>
      </example>
      <returns>Z_OK if all goes well. You generally don't need to check the return code.</returns>
    </member>
    <member name="M:Ionic.Zlib.ZlibCodec.InitializeDeflate(Ionic.Zlib.CompressionLevel)">
      <summary>
            Initialize the ZlibCodec for deflation operation, using the specified CompressionLevel.
            </summary>
      <remarks>
            The codec will use the maximum window bits (15) and the specified
            CompressionLevel.  It will emit a ZLIB stream as it compresses.
            </remarks>
      <param name="level">The compression level for the codec.</param>
      <returns>Z_OK if all goes well.</returns>
    </member>
    <member name="M:Ionic.Zlib.ZlibCodec.InitializeDeflate(Ionic.Zlib.CompressionLevel,System.Boolean)">
      <summary>
            Initialize the ZlibCodec for deflation operation, using the specified CompressionLevel, 
            and the explicit flag governing whether to emit an RFC1950 header byte pair.
            </summary>
      <remarks>
            The codec will use the maximum window bits (15) and the specified CompressionLevel.
            If you want to generate a zlib stream, you should specify true for
            wantRfc1950Header. In this case, the library will emit a ZLIB
            header, as defined in <see href="http://www.ietf.org/rfc/rfc1950.txt">RFC
            1950</see>, in the compressed stream.  
            </remarks>
      <param name="level">The compression level for the codec.</param>
      <param name="wantRfc1950Header">whether to emit an initial RFC1950 byte pair in the compressed stream.</param>
      <returns>Z_OK if all goes well.</returns>
    </member>
    <member name="M:Ionic.Zlib.ZlibCodec.InitializeDeflate(Ionic.Zlib.CompressionLevel,System.Int32)">
      <summary>
            Initialize the ZlibCodec for deflation operation, using the specified CompressionLevel, 
            and the specified number of window bits. 
            </summary>
      <remarks>
            The codec will use the specified number of window bits and the specified CompressionLevel.
            </remarks>
      <param name="level">The compression level for the codec.</param>
      <param name="bits">the number of window bits to use.  If you don't know what this means, don't use this method.</param>
      <returns>Z_OK if all goes well.</returns>
    </member>
    <member name="M:Ionic.Zlib.ZlibCodec.InitializeDeflate(Ionic.Zlib.CompressionLevel,System.Int32,System.Boolean)">
      <summary>
             Initialize the ZlibCodec for deflation operation, using the specified
             CompressionLevel, the specified number of window bits, and the explicit flag
             governing whether to emit an RFC1950 header byte pair.
             </summary>
      <param name="level">The compression level for the codec.</param>
      <param name="wantRfc1950Header">whether to emit an initial RFC1950 byte pair in the compressed stream.</param>
      <param name="bits">the number of window bits to use.  If you don't know what this means, don't use this method.</param>
      <returns>Z_OK if all goes well.</returns>
    </member>
    <member name="M:Ionic.Zlib.ZlibCodec.Deflate(Ionic.Zlib.FlushType)">
      <summary>
            Deflate one batch of data.
            </summary>
      <remarks>
            You must have set InputBuffer and OutputBuffer before calling this method.
            </remarks>
      <example>
        <code>
            private void DeflateBuffer(CompressionLevel level)
            {
                int bufferSize = 1024;
                byte[] buffer = new byte[bufferSize];
                ZlibCodec compressor = new ZlibCodec();
            
                Console.WriteLine("\n============================================");
                Console.WriteLine("Size of Buffer to Deflate: {0} bytes.", UncompressedBytes.Length);
                MemoryStream ms = new MemoryStream();
            
                int rc = compressor.InitializeDeflate(level);
            
                compressor.InputBuffer = UncompressedBytes;
                compressor.NextIn = 0;
                compressor.AvailableBytesIn = UncompressedBytes.Length;
            
                compressor.OutputBuffer = buffer;
            
                // pass 1: deflate 
                do
                {
                    compressor.NextOut = 0;
                    compressor.AvailableBytesOut = buffer.Length;
                    rc = compressor.Deflate(ZlibConstants.Z_NO_FLUSH);
            
                    if (rc != ZlibConstants.Z_OK &amp;&amp; rc != ZlibConstants.Z_STREAM_END)
                        throw new Exception("deflating: " + compressor.Message);
            
                    ms.Write(compressor.OutputBuffer, 0, buffer.Length - compressor.AvailableBytesOut);
                }
                while (compressor.AvailableBytesIn &gt; 0 || compressor.AvailableBytesOut == 0);
            
                // pass 2: finish and flush
                do
                {
                    compressor.NextOut = 0;
                    compressor.AvailableBytesOut = buffer.Length;
                    rc = compressor.Deflate(ZlibConstants.Z_FINISH);
            
                    if (rc != ZlibConstants.Z_STREAM_END &amp;&amp; rc != ZlibConstants.Z_OK)
                        throw new Exception("deflating: " + compressor.Message);
            
                    if (buffer.Length - compressor.AvailableBytesOut &gt; 0)
                        ms.Write(buffer, 0, buffer.Length - compressor.AvailableBytesOut);
                }
                while (compressor.AvailableBytesIn &gt; 0 || compressor.AvailableBytesOut == 0);
            
                compressor.EndDeflate();
            
                ms.Seek(0, SeekOrigin.Begin);
                CompressedBytes = new byte[compressor.TotalBytesOut];
                ms.Read(CompressedBytes, 0, CompressedBytes.Length);
            }
            </code>
      </example>
      <param name="flush">whether to flush all data as you deflate. Generally you will want to 
            use Z_NO_FLUSH here, in a series of calls to Deflate(), and then call EndDeflate() to 
            flush everything. 
            </param>
      <returns>Z_OK if all goes well.</returns>
    </member>
    <member name="M:Ionic.Zlib.ZlibCodec.EndDeflate">
      <summary>
            End a deflation session.
            </summary>
      <remarks>
            Call this after making a series of one or more calls to Deflate(). All buffers are flushed.
            </remarks>
      <returns>Z_OK if all goes well.</returns>
    </member>
    <member name="M:Ionic.Zlib.ZlibCodec.ResetDeflate">
      <summary>
            Reset a codec for another deflation session.
            </summary>
      <remarks>
            Call this to reset the deflation state.  For example if a thread is deflating
            non-consecutive blocks, you can call Reset() after the Deflate(Sync) of the first
            block and before the next Deflate(None) of the second block.
            </remarks>
      <returns>Z_OK if all goes well.</returns>
    </member>
    <member name="M:Ionic.Zlib.ZlibCodec.SetDeflateParams(Ionic.Zlib.CompressionLevel,Ionic.Zlib.CompressionStrategy)">
      <summary>
            Set the CompressionStrategy and CompressionLevel for a deflation session.
            </summary>
      <param name="level">the level of compression to use.</param>
      <param name="strategy">the strategy to use for compression.</param>
      <returns>Z_OK if all goes well.</returns>
    </member>
    <member name="M:Ionic.Zlib.ZlibCodec.SetDictionary(System.Byte[])">
      <summary>
            Set the dictionary to be used for either Inflation or Deflation.
            </summary>
      <param name="dictionary">The dictionary bytes to use.</param>
      <returns>Z_OK if all goes well.</returns>
    </member>
    <member name="P:Ionic.Zlib.ZlibCodec.Adler32">
      <summary>
            The Adler32 checksum on the data transferred through the codec so far. You probably don't need to look at this.
            </summary>
    </member>
  </members>
</doc>